"""
Упрощенные интеграционные тесты для работы с базой данных
"""
import pytest
import asyncio
from sqlalchemy import select, text, delete
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.user import Users


@pytest.mark.integration
class TestDatabaseIntegration:
    """Интеграционные тесты для работы с БД."""

    @pytest.mark.asyncio
    async def test_user_crud_operations(self, test_db_session: AsyncSession):
        """Тест полного цикла CRUD операций с пользователями."""
        user_data = {
            "login": "crud_test",
            "email": "crud_test@example.com",
            "password_hash": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4J/8K5K5K.",
            "is_active": True,
            "role": "reader"
        }

        try:
            # CREATE
            user = Users(**user_data)
            test_test_db_session.add(user)
            await test_db_session.commit()
            await test_db_session.refresh(user)
            
            assert user is not None
            assert user.email == user_data["email"]
            assert user.login == user_data["login"]
            assert user.is_active is True

            # READ
            result = await test_db_session.execute(
                select(Users).where(Users.id == user.id)
            )
            retrieved_user = result.scalar_one_or_none()
            assert retrieved_user is not None
            assert retrieved_user.email == user_data["email"]

            # UPDATE
            retrieved_user.is_active = False
            retrieved_user.login = "updated_crud_user"
            await test_db_session.commit()
            await test_db_session.refresh(retrieved_user)
            
            assert retrieved_user.login == "updated_crud_user"
            assert retrieved_user.is_active is False

            # DELETE
            await test_db_session.delete(retrieved_user)
            await test_db_session.commit()
            
            # Verify deletion
            result = await test_db_session.execute(
                select(Users).where(Users.id == user.id)
            )
            deleted_user = result.scalar_one_or_none()
            assert deleted_user is None

        except Exception as e:
            await test_db_session.rollback()
            raise e

    @pytest.mark.asyncio
    async def test_database_transaction_rollback(self, db_session: AsyncSession):
        """Тест отката транзакции при ошибке."""
        user_data = {
            "login": "transaction_test",
            "email": "transaction_test@example.com",
            "password_hash": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4J/8K5K5K.",
            "is_active": True,
            "role": "reader"
        }

        try:
            # Start transaction
            async with test_db_session.begin_nested():
                # Create user
                user = Users(**user_data)
                test_test_db_session.add(user)
                await test_db_session.flush()
                
                # Simulate error - this should cause rollback
                raise Exception("Simulated error")

        except Exception:
            pass  # Expected exception
            
        # Assert - User should not exist due to rollback
        result = await test_db_session.execute(
            select(Users).where(Users.email == user_data["email"])
        )
        user = result.scalar_one_or_none()
        assert user is None

    @pytest.mark.asyncio
    async def test_concurrent_user_creation(self, db_session: AsyncSession):
        """Тест создания пользователей в конкурентном режиме."""
        user_data_list = [
            {
                "login": f"concurrent_test_{i}",
                "email": f"concurrent_test_{i}@example.com",
                "password_hash": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4J/8K5K5K.",
                "is_active": True,
                "role": "reader"
            }
            for i in range(5)
        ]

        try:
            # Create users sequentially (concurrent creation would require separate sessions)
            for user_data in user_data_list:
                user = Users(**user_data)
                test_test_db_session.add(user)
            
            await test_db_session.commit()

            # Verify all users exist in database
            for user_data in user_data_list:
                result = await test_db_session.execute(
                    select(Users).where(Users.email == user_data["email"])
                )
                user = result.scalar_one_or_none()
                assert user is not None

        finally:
            # Cleanup
            for user_data in user_data_list:
                try:
                    await test_db_session.execute(
                        delete(Users).where(Users.email == user_data["email"])
                    )
                except:
                    pass
            await test_db_session.commit()

    @pytest.mark.asyncio
    async def test_database_connection(self, db_session: AsyncSession):
        """Тест подключения к базе данных."""
        # Simple query to test connection
        result = await test_db_session.execute(text("SELECT 1 as test_value"))
        row = result.fetchone()
        assert row[0] == 1

    @pytest.mark.asyncio
    async def test_database_schema(self, db_session: AsyncSession):
        """Тест схемы базы данных."""
        # Check if users table exists
        result = await test_db_session.execute(text("""
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_name = 'users'
        """))
        table_exists = result.fetchone()
        assert table_exists is not None

    @pytest.mark.asyncio
    async def test_user_constraints(self, db_session: AsyncSession):
        """Тест ограничений базы данных."""
        # Test unique constraint on login
        user1_data = {
            "login": "unique_test",
            "email": "unique_test1@example.com",
            "password_hash": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4J/8K5K5K.",
            "is_active": True,
            "role": "reader"
        }
        
        user2_data = {
            "login": "unique_test",  # Same login
            "email": "unique_test2@example.com",  # Different email
            "password_hash": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4J/8K5K5K.",
            "is_active": True,
            "role": "reader"
        }
        
        try:
            # Create first user
            user1 = Users(**user1_data)
            test_db_session.add(user1)
            await test_db_session.commit()
            
            # Try to create second user with same login
            user2 = Users(**user2_data)
            test_db_session.add(user2)
            
            # This should raise an exception due to unique constraint
            with pytest.raises(Exception):
                await test_db_session.commit()
            
        except Exception as e:
            await test_db_session.rollback()
            
        finally:
            # Cleanup
            try:
                await test_db_session.execute(
                    delete(Users).where(Users.login == "unique_test")
                )
                await test_db_session.commit()
            except:
                pass
