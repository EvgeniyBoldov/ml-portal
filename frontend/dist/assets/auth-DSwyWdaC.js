import{r as D,g as C,R as F}from"./index-FkM6qUsl.js";import{a as E,r as J,c as R,s as L}from"./http-B8UuqdIS.js";const N={},k=e=>{let r;const n=new Set,s=(m,g)=>{const S=typeof m=="function"?m(r):m;if(!Object.is(S,r)){const l=r;r=g??(typeof S!="object"||S===null)?S:Object.assign({},r,S),n.forEach(v=>v(r,l))}},o=()=>r,y={setState:s,getState:o,getInitialState:()=>c,subscribe:m=>(n.add(m),()=>n.delete(m)),destroy:()=>{(N?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}},c=r=e(s,o,y);return y},U=e=>e?k(e):k;var T={exports:{}},j={},z={exports:{}},x={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _=D;function W(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var G=typeof Object.is=="function"?Object.is:W,M=_.useState,B=_.useEffect,K=_.useLayoutEffect,Q=_.useDebugValue;function X(e,r){var n=r(),s=M({inst:{value:n,getSnapshot:r}}),o=s[0].inst,t=s[1];return K(function(){o.value=n,o.getSnapshot=r,I(o)&&t({inst:o})},[e,n,r]),B(function(){return I(o)&&t({inst:o}),e(function(){I(o)&&t({inst:o})})},[e]),Q(n),n}function I(e){var r=e.getSnapshot;e=e.value;try{var n=r();return!G(e,n)}catch{return!0}}function Y(e,r){return r()}var Z=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Y:X;x.useSyncExternalStore=_.useSyncExternalStore!==void 0?_.useSyncExternalStore:Z;z.exports=x;var q=z.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var w=D,V=q;function ee(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var te=typeof Object.is=="function"?Object.is:ee,re=V.useSyncExternalStore,ne=w.useRef,oe=w.useEffect,se=w.useMemo,ae=w.useDebugValue;j.useSyncExternalStoreWithSelector=function(e,r,n,s,o){var t=ne(null);if(t.current===null){var d={hasValue:!1,value:null};t.current=d}else d=t.current;t=se(function(){function y(l){if(!c){if(c=!0,m=l,l=s(l),o!==void 0&&d.hasValue){var v=d.value;if(o(v,l))return g=v}return g=l}if(v=g,te(m,l))return v;var u=s(l);return o!==void 0&&o(v,u)?(m=l,v):(m=l,g=u)}var c=!1,m,g,S=n===void 0?null:n;return[function(){return y(r())},S===null?void 0:function(){return y(S())}]},[r,n,s,o]);var f=re(e,t[0],t[1]);return oe(function(){d.hasValue=!0,d.value=f},[f]),ae(f),f};T.exports=j;var ie=T.exports;const ue=C(ie),H={},{useDebugValue:ce}=F,{useSyncExternalStoreWithSelector:le}=ue;let $=!1;const de=e=>e;function fe(e,r=de,n){(H?"production":void 0)!=="production"&&n&&!$&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),$=!0);const s=le(e.subscribe,e.getState,e.getServerState||e.getInitialState,r,n);return ce(s),s}const A=e=>{(H?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const r=typeof e=="function"?U(e):e,n=(s,o)=>fe(r,s,o);return Object.assign(n,r),n},me=e=>e?A(e):A,ve={};function he(e,r){let n;try{n=e()}catch{return}return{getItem:o=>{var t;const d=y=>y===null?null:JSON.parse(y,void 0),f=(t=n.getItem(o))!=null?t:null;return f instanceof Promise?f.then(d):d(f)},setItem:(o,t)=>n.setItem(o,JSON.stringify(t,void 0)),removeItem:o=>n.removeItem(o)}}const b=e=>r=>{try{const n=e(r);return n instanceof Promise?n:{then(s){return b(s)(n)},catch(s){return this}}}catch(n){return{then(s){return this},catch(s){return b(s)(n)}}}},ye=(e,r)=>(n,s,o)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:i=>i,version:0,merge:(i,h)=>({...h,...i}),...r},d=!1;const f=new Set,y=new Set;let c;try{c=t.getStorage()}catch{}if(!c)return e((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),n(...i)},s,o);const m=b(t.serialize),g=()=>{const i=t.partialize({...s()});let h;const a=m({state:i,version:t.version}).then(p=>c.setItem(t.name,p)).catch(p=>{h=p});if(h)throw h;return a},S=o.setState;o.setState=(i,h)=>{S(i,h),g()};const l=e((...i)=>{n(...i),g()},s,o);let v;const u=()=>{var i;if(!c)return;d=!1,f.forEach(a=>a(s()));const h=((i=t.onRehydrateStorage)==null?void 0:i.call(t,s()))||void 0;return b(c.getItem.bind(c))(t.name).then(a=>{if(a)return t.deserialize(a)}).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==t.version){if(t.migrate)return t.migrate(a.state,a.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return a.state}).then(a=>{var p;return v=t.merge(a,(p=s())!=null?p:l),n(v,!0),g()}).then(()=>{h==null||h(v,void 0),d=!0,y.forEach(a=>a(v))}).catch(a=>{h==null||h(void 0,a)})};return o.persist={setOptions:i=>{t={...t,...i},i.getStorage&&(c=i.getStorage())},clearStorage:()=>{c==null||c.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>u(),hasHydrated:()=>d,onHydrate:i=>(f.add(i),()=>{f.delete(i)}),onFinishHydration:i=>(y.add(i),()=>{y.delete(i)})},u(),v||l},Se=(e,r)=>(n,s,o)=>{let t={storage:he(()=>localStorage),partialize:u=>u,version:0,merge:(u,i)=>({...i,...u}),...r},d=!1;const f=new Set,y=new Set;let c=t.storage;if(!c)return e((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),n(...u)},s,o);const m=()=>{const u=t.partialize({...s()});return c.setItem(t.name,{state:u,version:t.version})},g=o.setState;o.setState=(u,i)=>{g(u,i),m()};const S=e((...u)=>{n(...u),m()},s,o);o.getInitialState=()=>S;let l;const v=()=>{var u,i;if(!c)return;d=!1,f.forEach(a=>{var p;return a((p=s())!=null?p:S)});const h=((i=t.onRehydrateStorage)==null?void 0:i.call(t,(u=s())!=null?u:S))||void 0;return b(c.getItem.bind(c))(t.name).then(a=>{if(a)if(typeof a.version=="number"&&a.version!==t.version){if(t.migrate)return[!0,t.migrate(a.state,a.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,a.state];return[!1,void 0]}).then(a=>{var p;const[O,P]=a;if(l=t.merge(P,(p=s())!=null?p:S),n(l,!0),O)return m()}).then(()=>{h==null||h(l,void 0),l=s(),d=!0,y.forEach(a=>a(l))}).catch(a=>{h==null||h(void 0,a)})};return o.persist={setOptions:u=>{t={...t,...u},u.storage&&(c=u.storage)},clearStorage:()=>{c==null||c.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>v(),hasHydrated:()=>d,onHydrate:u=>(f.add(u),()=>{f.delete(u)}),onFinishHydration:u=>(y.add(u),()=>{y.delete(u)})},t.skipHydration||v(),l||S},ge=(e,r)=>"getStorage"in r||"serialize"in r||"deserialize"in r?((ve?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),ye(e,r)):Se(e,r),pe=ge,_e=me()(pe((e,r)=>({user:null,tokens:null,isAuthReady:!1,async login(n,s){const o=await E("/auth/login",{method:"POST",body:JSON.stringify({login:n,password:s})}),t={access_token:o.access_token,token_type:o.token_type,refresh_token:o.refresh_token,expires_in:o.expires_in};L(t),e({tokens:t}),e({user:o.user})},async logout(){try{await E("/auth/logout",{method:"POST"})}catch{}R(),e({tokens:null,user:null})},async hydrate(){try{const n=await E("/auth/me",{method:"GET"});e({user:n,isAuthReady:!0})}catch{try{await J();const n=await E("/auth/me",{method:"GET"});e({user:n,isAuthReady:!0})}catch{R(),e({user:null,tokens:null,isAuthReady:!0})}}}}),{name:"auth-store",partialize:e=>({tokens:e.tokens})})),we=()=>{const e=_e();return{user:e.user,loading:!1,error:null,login:e.login,fetchMe:async()=>{try{return await e.hydrate(),e.user}catch{return null}},logout:e.logout}};export{we as u};
