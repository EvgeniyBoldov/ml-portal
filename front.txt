
// ===== vite-env.d.ts =====
/// <reference types="vite/client" />

declare module '*.module.css' {
  const classes: { readonly [key: string]: string }
  export default classes
}

// ===== mocks/mockFetch.ts =====
// Simple in-app fetch mock. Works when VITE_USE_MOCKS=true
// Emulates a subset of backend endpoints used by the app, including SSE for chat and simple queues.
type Opts = RequestInit & { idempotencyKey?: string }
const encoder = new TextEncoder()

type User = { id: string; login: string; fio?: string; role?: string; password?: string }
type Message = { role: 'user'|'assistant'; content: string }
type Chat = { id: string; name: string; messages: Message[] }
type RagDoc = { id: string; name: string; status: 'uploaded'|'processing'|'ready'|'error'; tags: string[]; created_at: string }
type AnalyzeTask = { id: string; source?: string; status: 'queued'|'processing'|'done'|'error'; result?: string; created_at: string }

const db = {
  users: [{ id: 'u1', login: 'admin', password: 'admin', fio: 'Администратор', role: 'admin' } as User],
  chats: new Map<string, Chat>(),
  tokens: new Map<string, string>(), // access_token -> userId
  rag: [] as RagDoc[],
  analyze: [] as AnalyzeTask[]
}

function jsonResponse(body: any, init: ResponseInit = {}) {
  return new Response(JSON.stringify(body), { status: 200, headers: { 'Content-Type': 'application/json' }, ...init })
}
function noContent() { return new Response(null, { status: 204 }) }
function unauthorized() { return new Response('unauthorized', { status: 401 }) }
function notFound() { return new Response('not found', { status: 404 }) }
function badRequest(msg='bad request') { return new Response(msg, { status: 400 }) }

function parseUrl(url: string) {
  // Works with relative like "/api/..." and absolute like "http://x/api/..."
  try {
    const u = new URL(url, window.location.origin)
    return u
  } catch {
    return new URL(window.location.origin + url.replace(/^\//, ''))
  }
}

async function readJson(body?: BodyInit | null) {
  if (!body) return null
  if (typeof body === 'string') { try { return JSON.parse(body) } catch { return null } }
  if (body instanceof FormData) { return body }
  // Other types: ignore for simplicity
  return null
}

function requireAuth(headers: Headers): User | null {
  const auth = headers.get('Authorization') || ''
  const token = auth.startsWith('Bearer ') ? auth.slice(7) : null
  if (!token) return null
  const uid = db.tokens.get(token || '')
  const user = db.users.find(u => u.id === uid)
  return user || null
}

function sseStream(lines: string[], delayMs = 40) {
  return new ReadableStream<Uint8Array>({
    async start(controller) {
      for (const part of lines) {
        const chunk = `data: ${part}\n\n`
        controller.enqueue(encoder.encode(chunk))
        await new Promise(r => setTimeout(r, delayMs))
      }
      controller.close()
    }
  })
}

function paginate<T extends { id?: string }>(arr: T[], cursor?: string | null, limit = 20) {
  let start = 0
  if (cursor) {
    const idx = (arr as any[]).findIndex((it:any) => (it.id || it.chat_id) === cursor)
    start = idx >= 0 ? idx + 1 : 0
  }
  const items = (arr as any[]).slice(start, start + limit)
  const next_cursor = (start + limit) < (arr as any[]).length ? ((arr as any[])[start + limit - 1] as any).id : null
  return { items, next_cursor }
}

// Seed some RAG docs on first GET
function seedRag() {
  if (db.rag.length > 0) return
  const now = new Date().toISOString()
  db.rag.push(
    { id: 'doc1', name: 'Guide.pdf', status: 'ready', tags: ['guide'], created_at: now },
    { id: 'doc2', name: 'Spec.md', status: 'processing', tags: ['spec'], created_at: now },
    { id: 'doc3', name: 'Manual.txt', status: 'uploaded', tags: ['manual'], created_at: now }
  )
}

// Simple background progression helper (uploaded -> processing -> ready)
function progressRag(doc: RagDoc) {
  setTimeout(() => { doc.status = 'processing' }, 600)
  setTimeout(() => { doc.status = 'ready' }, 1400)
}

// Analyze progression (queued -> processing -> done with text result)
function progressAnalyze(task: AnalyzeTask) {
  setTimeout(() => { task.status = 'processing' }, 500)
  setTimeout(() => { task.status = 'done'; task.result = `Результат анализа: «${task.source || 'file'}» обработан.` }, 1500)
}

export async function mockFetch(url: string, opts: Opts = {}) {
  const u = parseUrl(url)
  const path = u.pathname
  const method = (opts.method || 'GET').toUpperCase()
  const body = await readJson(opts.body || null)

  // AUTH
  if (path === '/api/auth/login' && method === 'POST') {
    const { login, password } = (body as any) || {}
    const user = db.users.find(u => u.login === login && u.password === password)
    if (!user) return badRequest('invalid credentials')
    const access = crypto.randomUUID()
    db.tokens.set(access, user.id)
    return jsonResponse({ access_token: access, refresh_token: 'refresh_' + user.id, expires_in: 3600 })
  }
  if (path === '/api/auth/refresh' && method === 'POST') {
    // accept any refresh token that starts with "refresh_"
    const { refresh_token } = (body as any) || {}
    if (!refresh_token || !String(refresh_token).startsWith('refresh_')) return unauthorized()
    const uid = String(refresh_token).slice('refresh_'.length)
    const user = db.users.find(u => u.id === uid)
    if (!user) return unauthorized()
    const access = crypto.randomUUID()
    db.tokens.set(access, user.id)
    return jsonResponse({ access_token: access, expires_in: 3600 })
  }
  if (path === '/api/auth/me' && method === 'GET') {
    const user = requireAuth(new Headers(opts.headers || {}))
    if (!user) return unauthorized()
    const { password, ...safe } = user as any
    return jsonResponse(safe)
  }
  if (path === '/api/auth/logout' && method === 'POST') {
    const auth = new Headers(opts.headers || {}).get('Authorization') || ''
    const token = auth.startsWith('Bearer ') ? auth.slice(7) : ''
    db.tokens.delete(token)
    return noContent()
  }

  // CHATS
  if (path === '/api/chats' && method === 'POST') {
    const id = crypto.randomUUID()
    const name = (body && (body as any).name) || 'New chat'
    db.chats.set(id, { id, name, messages: [] })
    return jsonResponse({ chat_id: id })
  }
  if (path === '/api/chats' && method === 'GET') {
    const list = Array.from(db.chats.values()).map(c => ({ id: c.id, name: c.name }))
    return jsonResponse({ items: list, next_cursor: null })
  }
  const chatIdMatch = path.match(/^\/api\/chats\/([^\/]+)(?:\/(messages))?$/)
  if (chatIdMatch) {
    const chatId = chatIdMatch[1]
    const sub = chatIdMatch[2] // 'messages' or undefined
    const chat = db.chats.get(chatId)
    if (!chat && method !== 'PATCH' && method !== 'DELETE') return notFound()

    if (!sub && method === 'PATCH') {
      const name = (body as any)?.name || 'Untitled'
      const c = db.chats.get(chatId)
      if (!c) return notFound()
      c.name = name
      return jsonResponse({ ok: true })
    }
    if (!sub && method === 'DELETE') {
      db.chats.delete(chatId)
      return noContent()
    }

    if (sub === 'messages' && method === 'GET') {
      const msgs = chat ? chat.messages : []
      return jsonResponse({ items: msgs, next_cursor: null })
    }

    if (sub === 'messages' && method === 'POST') {
      const payload = (body as any) || {}
      const userMsg = (payload.messages?.[0]?.content) || ''
      if (chat) chat.messages.push({ role: 'user', content: userMsg })

      const canned = `Привет! Это моковый ответ на: "${userMsg}".\nМоки включены, бэкенд не требуется.`

      if (payload.response_stream) {
        const tokens = Array.from(canned)
        const stream = sseStream(tokens, 18)
        // also push the final assistant message into history (joined)
        const full = tokens.join('')
        if (chat) chat.messages.push({ role: 'assistant', content: full })
        const headers = new Headers({
          'Content-Type': 'text/event-stream; charset=utf-8',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive'
        })
        return new Response(stream, { status: 200, headers })
      } else {
        if (chat) chat.messages.push({ role: 'assistant', content: canned })
        return jsonResponse({ message: { role: 'assistant', content: canned } })
      }
    }
  }

  // RAG
  if (path === '/api/rag' && method === 'GET') {
    seedRag()
    const q = u.searchParams.get('q')?.toLowerCase() || ''
    const status = u.searchParams.get('status') || ''
    const cursor = u.searchParams.get('cursor') || undefined
    let data = db.rag.slice()
    if (q) data = data.filter(d => d.name.toLowerCase().includes(q))
    if (status) data = data.filter(d => d.status === status)
    const { items, next_cursor } = paginate(data, cursor, 20)
    return jsonResponse({ items, next_cursor })
  }
  if (path === '/api/rag/upload' && method === 'POST') {
    const name = (body instanceof FormData) ? (body.get('name') as string || (body.get('file') as File)?.name || 'document') : 'document'
    const doc: RagDoc = { id: crypto.randomUUID(), name, status: 'uploaded', tags: [], created_at: new Date().toISOString() }
    db.rag.unshift(doc)
    progressRag(doc)
    return jsonResponse({ id: doc.id, status: doc.status })
  }
  if (path === '/api/rag/search' && method === 'POST') {
    const q = (body as any)?.text || ''
    return jsonResponse({ items: [
      { document_id: db.rag[0]?.id || 'doc1', chunk_id: '1', score: 0.92, snippet: `Найдено по запросу "${q}" — фрагмент №1` },
      { document_id: db.rag[0]?.id || 'doc1', chunk_id: '2', score: 0.87, snippet: `Найдено по запросу "${q}" — фрагмент №2` }
    ]})
  }

  // ANALYZE
  if (path === '/api/analyze' && method === 'GET') {
    const items = db.analyze.slice().sort((a,b) => (b.created_at > a.created_at ? 1 : -1))
    return jsonResponse({ items })
  }
  if (path === '/api/analyze' && method === 'POST') {
    let source = ''
    if (body instanceof FormData) {
      source = (body.get('file') as File)?.name || 'file'
    } else {
      source = (body as any)?.url || ''
    }
    if (!source) return badRequest('source required')
    const task: AnalyzeTask = { id: crypto.randomUUID(), source, status: 'queued', created_at: new Date().toISOString() }
    db.analyze.unshift(task)
    progressAnalyze(task)
    return jsonResponse({ id: task.id, status: task.status })
  }
  const analyzeMatch = path.match(/^\/api\/analyze\/([^\/]+)$/)
  if (analyzeMatch && method === 'GET') {
    const id = analyzeMatch[1]
    const t = db.analyze.find(x => x.id === id)
    if (!t) return notFound()
    return jsonResponse(t)
  }

  // Unknown: pass-through to real fetch (allows gradual mocking)
  return fetch(url, opts)
}

// ===== mocks/enableMocks.ts =====
import { mockFetch } from './mockFetch'

function toUrl(input: RequestInfo | URL): string {
  if (typeof input === 'string') return input
  if (input instanceof URL) return input.toString()
  // Request
  try {
    // @ts-ignore
    return input.url || String(input)
  } catch {
    // @ts-ignore
    return String(input)
  }
}

// Replace global fetch to ensure ALL calls go through mocks in dev.
if (typeof window !== 'undefined') {
  const original = window.fetch.bind(window)
  // @ts-ignore
  window.fetch = (input: RequestInfo | URL, init?: RequestInit) => {
    const url = toUrl(input)
    // Allow opting-out: if request has header 'X-Bypass-Mock', go to real fetch
    if (init && (init as any).headers && (init as any).headers['X-Bypass-Mock']) {
      return original(input, init)
    }
    return mockFetch(url, init as any)
  }
}

// ===== mocks/index.ts =====
// Auto-enable mocks when VITE_USE_MOCKS === 'true'
// No top-level await to keep TS/Vite happy in all setups.
if (import.meta.env.VITE_USE_MOCKS === 'true') {
  import('./mockFetch');
}
export {};

// ===== test/setup.ts =====
import '@testing-library/jest-dom'
import { vi } from 'vitest'

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock crypto.randomUUID
Object.defineProperty(global, 'crypto', {
  value: {
    randomUUID: vi.fn(() => 'test-uuid-123')
  }
})

// ===== entities/auth/model/auth.store.ts =====
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { apiRequest, setAuthTokens, clearAuthTokens, refreshAccessToken } from "@/shared/api/http";
import type { User, LoginResponse, AuthTokens } from "@/shared/api/types";

type AuthState = {
  user: User | null;
  tokens: AuthTokens | null;
  isAuthReady: boolean;
  login: (login: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  hydrate: () => Promise<void>;
};

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      tokens: null,
      isAuthReady: false,
      async login(login, password) {
        const data = await apiRequest<LoginResponse>("/auth/login", { method: "POST", body: JSON.stringify({ login, password }) });
        const tokens = { 
          access_token: data.access_token, 
          token_type: data.token_type,
          refresh_token: data.refresh_token, 
          expires_in: data.expires_in 
        };
        setAuthTokens(tokens);
        set({ tokens });
        set({ user: data.user });
      },
      async logout() {
        try { await apiRequest<void>("/auth/logout", { method: "POST" }); } catch {}
        clearAuthTokens();
        set({ tokens: null, user: null });
      },
      async hydrate() {
        try {
          const me = await apiRequest<User>("/auth/me", { method: "GET" });
          set({ user: me, isAuthReady: true });
        } catch {
          try {
            await refreshAccessToken();
            const me = await apiRequest<User>("/auth/me", { method: "GET" });
            set({ user: me, isAuthReady: true });
          } catch {
            clearAuthTokens();
            set({ user: null, tokens: null, isAuthReady: true });
          }
        }
      },
    }),
    { name: "auth-store", partialize: (s) => ({ tokens: s.tokens }) }
  )
);

// ===== shared/config/env.ts =====
export const USE_MOCKS = (import.meta as any).env?.VITE_USE_MOCKS === 'true'
export const API_BASE: string = ((import.meta as any).env?.VITE_API_BASE as string) || '/api'

// ===== shared/lib/storage.ts =====
export type Tokens = { access_token: string; refresh_token?: string; expires_at?: number }
const KEY = 'auth.tokens.v1'

export function set(key: string, value: any) {
  if (value === undefined || value === null) { localStorage.removeItem(key); return }
  if (typeof value === 'string') localStorage.setItem(key, value)
  else localStorage.setItem(key, JSON.stringify(value))
}
export function get<T = string>(key: string): T | null {
  const raw = localStorage.getItem(key)
  if (raw === null) return null
  try { return JSON.parse(raw) as T } catch { return raw as unknown as T }
}
export function del(key: string) { localStorage.removeItem(key) }

export function saveTokens(t: Tokens | null) {
  if (!t) {
    localStorage.removeItem(KEY)
    del('token'); del('refresh_token')
    return
  }
  localStorage.setItem(KEY, JSON.stringify(t))
  set('token', t.access_token)
  if (t.refresh_token) set('refresh_token', t.refresh_token); else del('refresh_token')
}
export function loadTokens(): Tokens | null {
  try { return JSON.parse(localStorage.getItem(KEY) || 'null') } catch { return null }
}

// ===== shared/lib/sse.ts =====
export type SSEEvent = { event?: string; data?: string; id?: string }
export async function* parseSSE(stream: ReadableStream<Uint8Array>) {
  const reader = stream.getReader()
  const decoder = new TextDecoder()
  let buf = ''
  try {
    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      buf += decoder.decode(value, { stream: true })
      let idx
      while ((idx = buf.indexOf('\n\n')) !== -1) {
        const chunk = buf.slice(0, idx).trim()
        buf = buf.slice(idx + 2)
        if (!chunk) continue
        const ev: SSEEvent = {}
        for (const line of chunk.split('\n')) {
          const [k, ...rest] = line.split(':')
          const v = rest.join(':').trimStart()
          if (k === 'event') ev.event = v
          else if (k === 'data') ev.data = (ev.data ? ev.data + '\n' : '') + v
          else if (k === 'id') ev.id = v
        }
        yield ev
      }
    }
  } finally { reader.releaseLock() }
}

// ===== shared/lib/idempotency.ts =====
export function idempotencyKey(): string {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) return (crypto as any).randomUUID();
  return "idem_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
}

// ===== shared/lib/apiFetch.ts =====
import { API_BASE } from '@shared/api'
import { get, set, del } from './storage'
import { idempotencyKey } from './idempotency'

type Opts = RequestInit & { auth?: boolean, idempotent?: boolean }

function token() { return get<string>('token') }
function refreshToken() { return get<string>('refresh_token') }

async function refresh() {
  const res = await fetch(API_BASE + '/auth/refresh', { method:'POST', headers:{ 'Content-Type': 'application/json' }, body: JSON.stringify({ refresh_token: refreshToken() }) })
  if (!res.ok) throw new Error('refresh failed')
  const data = await res.json()
  set('token', data.access_token); if (data.refresh_token) set('refresh_token', data.refresh_token)
  return data.access_token
}

export async function apiFetch(path: string, opts: Opts = {}) {
  const url = path.startsWith('http') ? path : API_BASE + path
  const headers: Record<string,string> = { ...(opts.headers||{}) as any }
  if (opts.auth !== false && token()) headers['Authorization'] = 'Bearer ' + token()
  if (opts.idempotent) headers['Idempotency-Key'] = idempotencyKey()
  const doFetch = () => fetch(url, { ...opts, headers })
  let res = await doFetch()
  if (res.status === 401 && token()) {
    try { const t = await refresh(); headers['Authorization'] = 'Bearer ' + t; res = await doFetch() }
    catch { del('token'); del('refresh_token'); throw new Error('Не авторизован') }
  }
  if (!res.ok) {
    let msg = 'Request failed'
    try { const j = await res.json(); msg = j.message || j.detail || JSON.stringify(j) } catch {}
    throw new Error(msg)
  }
  return res
}

// ===== shared/api/analyze.ts =====
import { apiRequest } from './http'

export async function listAnalyze() {
  return apiRequest<{ items: any[] }>('/analyze')
}

export async function uploadAnalysisFile(file: File) {
  const fd = new FormData()
  fd.set('file', file)
  return apiRequest<{ id: string; status: string }>('/analyze/upload', { method: 'POST', body: fd })
}

export async function getAnalyze(id: string) {
  return apiRequest<any>(`/analyze/${id}`)
}

export async function downloadAnalysisFile(doc_id: string, kind: 'original' | 'canonical' = 'original') {
  return apiRequest<{ url: string }>(`/analyze/${doc_id}/download?kind=${kind}`)
}

export async function deleteAnalysisFile(doc_id: string) {
  return apiRequest<{ id: string; deleted: boolean }>(`/analyze/${doc_id}`, { method: 'DELETE' })
}

export async function reanalyzeFile(doc_id: string) {
  return apiRequest<{ id: string; status: string }>(`/analyze/${doc_id}/reanalyze`, { method: 'POST' })
}

// ===== shared/api/errors.ts =====
export type ErrorEnvelope = {
  error: { code: string; message: string; details?: unknown };
  request_id?: string;
};

export class ApiError extends Error {
  code: string;
  requestId?: string;
  details?: unknown;
  constructor(message: string, code = "unknown_error", requestId?: string, details?: unknown) {
    super(message);
    this.name = "ApiError";
    this.code = code;
    this.requestId = requestId;
    this.details = details;
  }
}

export async function toApiError(resp: Response): Promise<ApiError> {
  let msg = `${resp.status} ${resp.statusText}`;
  let code = "http_error";
  let requestId: string | undefined;
  let details: unknown;
  try {
    const data = await resp.json();
    if (data && typeof data === "object" && "error" in data) {
      const err = (data as any).error;
      msg = err?.message || msg;
      code = err?.code || code;
      requestId = (data as any).request_id;
      details = err?.details;
    }
  } catch {}
  return new ApiError(msg, code, requestId, details);
}

// ===== shared/api/chats.ts =====
import { apiRequest } from './http'
import { parseSSE } from '@shared/lib/sse'
import type { 
  PaginatedResponse, 
  Chat, 
  ChatCreateRequest, 
  ChatUpdateRequest, 
  ChatTagsUpdateRequest,
  ChatMessageRequest,
  ChatMessageResponse,
  ChatMessage
} from './types'

export async function listChats(params: { cursor?: string; limit?: number; q?: string } = {}) {
  const qs = new URLSearchParams()
  if (params.limit) qs.set('limit', String(params.limit))
  if (params.cursor) qs.set('cursor', params.cursor)
  if (params.q) qs.set('q', params.q)
  return apiRequest<PaginatedResponse<Chat>>(`/chats?${qs.toString()}`)
}

export async function createChat(name?: string | null, tags?: string[] | null) {
  const body: ChatCreateRequest = { name: name ?? null, tags: tags ?? null }
  return apiRequest<{ chat_id: string }>('/chats', { method: 'POST', body: JSON.stringify(body) })
}

export async function listMessages(chat_id: string, params: { cursor?: string; limit?: number } = {}) {
  const qs = new URLSearchParams()
  if (params.limit) qs.set('limit', String(params.limit))
  if (params.cursor) qs.set('cursor', params.cursor)
  return apiRequest<PaginatedResponse<ChatMessage>>(`/chats/${chat_id}/messages?${qs.toString()}`)
}

export async function sendMessage(chat_id: string, body: ChatMessageRequest) {
  return apiRequest<ChatMessageResponse>(`/chats/${chat_id}/messages`, { 
    method: 'POST', 
    body: JSON.stringify(body),
    idempotent: true 
  })
}

export async function* sendMessageStream(chat_id: string, body: { content: string; use_rag?: boolean }) {
  const headers: Record<string, string> = { 'Content-Type': 'application/json' }
  // Add auth token if available
  const token = (window as any).__auth_tokens?.access_token || localStorage.getItem('access_token')
  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }
  
  const API_BASE = import.meta.env.VITE_API_BASE || '/api'
  const res = await fetch(`${API_BASE}/chats/${chat_id}/messages`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ ...body, response_stream: true })
  })
  if (!res.ok) throw new Error(`HTTP ${res.status}`)

  const contentType = res.headers.get('content-type') || ''
  if (contentType.includes('text/event-stream')) {
    for await (const ev of parseSSE(res.body!)) {
      if (ev.data) yield ev.data
    }
  } else {
    const reader = res.body!.getReader()
    const decoder = new TextDecoder()
    let pending = ''
    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      pending += decoder.decode(value, { stream: true })
      let idx
      while ((idx = pending.indexOf('\n')) !== -1) {
        const line = pending.slice(0, idx).trim()
        pending = pending.slice(idx + 1)
        if (line) yield line
      }
    }
    if (pending.trim()) yield pending.trim()
  }
}

export async function renameChat(chat_id: string, name: string) {
  const body: ChatUpdateRequest = { name }
  return apiRequest<Chat>(`/chats/${chat_id}`, { 
    method: 'PATCH', 
    body: JSON.stringify(body) 
  })
}

export async function updateChatTags(chat_id: string, tags: string[]) {
  const body: ChatTagsUpdateRequest = { tags }
  return apiRequest<{ id: string; tags: string[] }>(`/chats/${chat_id}/tags`, { 
    method: 'PUT', 
    body: JSON.stringify(body) 
  })
}

export async function deleteChat(chat_id: string) {
  return apiRequest<{ id: string; deleted: boolean }>(`/chats/${chat_id}`, { method: 'DELETE' })
}

// ===== shared/api/http.ts =====
import { API_BASE } from "@/shared/config/env";
import { ApiError, toApiError } from "@/shared/api/errors";
import { idempotencyKey } from "@/shared/lib/idempotency";

export type RequestOptions = RequestInit & { idempotent?: boolean };

export type AuthTokens = { access_token: string; refresh_token?: string; expires_in?: number };
let _tokens: AuthTokens | null = null;
let _refreshPromise: Promise<void> | null = null;

export function setAuthTokens(tokens: AuthTokens | null) { 
  _tokens = tokens; 
  // Also save to global state for client.ts
  (window as any).__auth_tokens = tokens;
  if (tokens?.access_token) {
    localStorage.setItem('access_token', tokens.access_token);
  } else {
    localStorage.removeItem('access_token');
  }
}
export function clearAuthTokens() { 
  _tokens = null; 
  (window as any).__auth_tokens = null;
  localStorage.removeItem('access_token');
}
export function getAccessToken(): string | null { return _tokens?.access_token || null; }

export async function apiRequest<T>(path: string, opts: RequestOptions = {}): Promise<T> {
  const url = path.startsWith("http") ? path : API_BASE.replace(/\/$/, "") + path;
  const headers = new Headers(opts.headers || {});
  if (!headers.has("Content-Type") && !(opts.body instanceof FormData)) headers.set("Content-Type", "application/json");
  if (!headers.has("Accept")) headers.set("Accept", "application/json");
  if (_tokens?.access_token && !headers.has("Authorization")) headers.set("Authorization", `Bearer ${_tokens.access_token}`);
  const method = (opts.method || "GET").toUpperCase();
  if ((method !== "GET" && method !== "HEAD") || opts.idempotent) {
    if (!headers.has("Idempotency-Key")) headers.set("Idempotency-Key", idempotencyKey());
  }
  const attempt = () => fetch(url, { ...opts, headers });
  let resp = await attempt();
  if (resp.status === 401 && _tokens?.refresh_token) {
    try {
      await refreshAccessToken();
      const retryHeaders = new Headers(headers);
      if (_tokens?.access_token) retryHeaders.set("Authorization", `Bearer ${_tokens.access_token}`);
      resp = await fetch(url, { ...opts, headers: retryHeaders });
    } catch {}
  }
  if (!resp.ok) throw await toApiError(resp);
  if (resp.status === 204) return undefined as unknown as T;
  const ct = resp.headers.get("Content-Type") || "";
  if (ct.includes("application/json")) return await resp.json() as T;
  return await resp.text() as unknown as T;
}

export async function refreshAccessToken(): Promise<void> {
  if (_refreshPromise) return _refreshPromise;
  if (!_tokens?.refresh_token) throw new ApiError("No refresh token", "no_refresh_token");
  _refreshPromise = (async () => {
    const url = API_BASE.replace(/\/$/, "") + "/auth/refresh";
    const resp = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json" },
      body: JSON.stringify({ refresh_token: _tokens!.refresh_token })
    });
    if (!resp.ok) {
      _refreshPromise = null; _tokens = null; throw await toApiError(resp);
    }
    const data = await resp.json();
    _tokens = {
      access_token: data.access_token,
      refresh_token: data.refresh_token ?? _tokens!.refresh_token,
      expires_in: data.expires_in
    };
    // Update global state and localStorage
    (window as any).__auth_tokens = _tokens;
    localStorage.setItem('access_token', _tokens.access_token);
    _refreshPromise = null;
  })();
  return _refreshPromise;
}

// ===== shared/api/rag.ts =====
import { apiRequest } from './http'

export async function listDocs(params: { 
  page?: number; 
  size?: number; 
  status?: string; 
  search?: string; 
} = {}) {
  const qs = new URLSearchParams()
  if (params.page) qs.set('page', String(params.page))
  if (params.size) qs.set('size', String(params.size))
  if (params.status) qs.set('status', params.status)
  if (params.search) qs.set('search', params.search)
  return apiRequest<{ 
    items: any[]; 
    pagination: {
      page: number;
      size: number;
      total: number;
      total_pages: number;
      has_next: boolean;
      has_prev: boolean;
    }
  }>(`/rag/?${qs.toString()}`)
}

export async function uploadFile(file: File, name?: string, tags?: string[]) {
  const fd = new FormData()
  fd.set('file', file)
  if (name) fd.set('name', name)
  if (tags?.length) fd.set('tags', JSON.stringify(tags))
  return apiRequest<{ id: string; status: string }>('/rag/upload', { method: 'POST', body: fd })
}

export async function updateRagDocumentTags(docId: string, tags: string[]) {
  return apiRequest<{ id: string; tags: string[] }>(`/rag/${docId}/tags`, { 
    method: 'PUT', 
    body: JSON.stringify(tags) 
  })
}

export async function getRagProgress(doc_id: string) {
  return apiRequest<any>(`/rag/${doc_id}/progress`)
}

export async function getRagStats() {
  return apiRequest<any>('/rag/stats')
}

export async function getRagMetrics() {
  return apiRequest<any>('/rag/metrics')
}

export async function downloadRagFile(doc_id: string, kind: 'original' | 'canonical' = 'original') {
  return apiRequest<{ url: string }>(`/rag/${doc_id}/download?kind=${kind}`)
}

export async function archiveRagDocument(doc_id: string) {
  return apiRequest<{ id: string; archived: boolean }>(`/rag/${doc_id}/archive`, { method: 'POST' })
}

export async function deleteRagDocument(doc_id: string) {
  return apiRequest<{ id: string; deleted: boolean }>(`/rag/${doc_id}`, { method: 'DELETE' })
}

export async function ragSearch(payload: { text?: string; top_k?: number; min_score?: number }) {
  return apiRequest<{ items: Array<{ document_id: string; chunk_id: string; score: number; snippet: string }> }>('/rag/search', { 
    method: 'POST', 
    body: JSON.stringify(payload) 
  })
}

export async function reindexRagDocument(doc_id: string) {
  return apiRequest<{ id: string; status: string }>(`/rag/${doc_id}/reindex`, { method: 'POST' })
}

export async function reindexAllRagDocuments() {
  return apiRequest<{ reindexed_count: number; total_documents: number }>('/rag/reindex', { method: 'POST' })
}

// ===== shared/api/admin.ts =====
/**
 * Admin API client
 */
import { apiFetch } from '../lib/apiFetch';
import type { ApiResponse, PaginatedResponse } from './types';

// Types
export interface User {
  id: string;
  login: string;
  role: 'admin' | 'editor' | 'reader';
  email?: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface UserCreate {
  login: string;
  email?: string;
  role: 'admin' | 'editor' | 'reader';
  is_active?: boolean;
  password?: string;
  send_email?: boolean;
}

export interface UserUpdate {
  role?: 'admin' | 'editor' | 'reader';
  email?: string;
  is_active?: boolean;
  require_password_change?: boolean;
}

export interface UserListResponse extends PaginatedResponse {
  users: User[];
  has_more: boolean;
  next_cursor?: string;
}

export interface PasswordChange {
  new_password?: string;
  require_change?: boolean;
}

export interface TokenScope {
  scope: string;
  description: string;
}

export interface UserToken {
  id: string;
  name: string;
  scopes: TokenScope[];
  expires_at?: string;
  created_at: string;
  last_used_at?: string;
  revoked_at?: string;
}

export interface TokenCreate {
  name: string;
  scopes: string[];
  expires_at?: string;
}

export interface TokenResponse extends UserToken {
  token_plain_once?: string; // Only returned on creation
}

export interface TokenListResponse {
  tokens: UserToken[];
  total: number;
}

export interface AuditLog {
  id: string;
  ts: string;
  actor_user_id?: string;
  action: string;
  object_type?: string;
  object_id?: string;
  meta?: Record<string, any>;
  ip?: string;
  user_agent?: string;
  request_id?: string;
}

export interface AuditLogListResponse extends PaginatedResponse {
  logs: AuditLog[];
  has_more: boolean;
  next_cursor?: string;
}

export interface AuditFilters {
  actor_user_id?: string;
  action?: string;
  object_type?: string;
  start_date?: string;
  end_date?: string;
}

export interface SystemStatus {
  email_enabled: boolean;
  email_status: 'ok' | 'error' | 'disabled';
  total_users: number;
  active_users: number;
  total_tokens: number;
  active_tokens: number;
}

// API functions
export const adminApi = {
  // Users
  async getUsers(params: {
    query?: string;
    role?: string;
    is_active?: boolean;
    limit?: number;
    cursor?: string;
  } = {}): Promise<UserListResponse> {
    const searchParams = new URLSearchParams();
    if (params.query) searchParams.set('query', params.query);
    if (params.role) searchParams.set('role', params.role);
    if (params.is_active !== undefined) searchParams.set('is_active', String(params.is_active));
    if (params.limit) searchParams.set('limit', String(params.limit));
    if (params.cursor) searchParams.set('cursor', params.cursor);

    return apiFetch(`/api/admin/users?${searchParams.toString()}`);
  },

  async getUser(id: string): Promise<User> {
    return apiFetch(`/api/admin/users/${id}`);
  },

  async createUser(user: UserCreate): Promise<{ user: User; password?: string }> {
    return apiFetch('/api/admin/users', {
      method: 'POST',
      body: JSON.stringify(user),
    });
  },

  async updateUser(id: string, user: UserUpdate): Promise<User> {
    return apiFetch(`/api/admin/users/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(user),
    });
  },

  async deleteUser(id: string): Promise<void> {
    return apiFetch(`/api/admin/users/${id}`, {
      method: 'DELETE',
    });
  },

  async resetUserPassword(id: string, passwordData: PasswordChange): Promise<{ password?: string }> {
    return apiFetch(`/api/admin/users/${id}/password`, {
      method: 'POST',
      body: JSON.stringify(passwordData),
    });
  },

  // Tokens
  async getUserTokens(userId: string): Promise<TokenListResponse> {
    return apiFetch(`/api/admin/users/${userId}/tokens`);
  },

  async createUserToken(userId: string, token: TokenCreate): Promise<TokenResponse> {
    return apiFetch(`/api/admin/users/${userId}/tokens`, {
      method: 'POST',
      body: JSON.stringify(token),
    });
  },

  async revokeToken(tokenId: string): Promise<void> {
    return apiFetch(`/api/admin/tokens/${tokenId}`, {
      method: 'DELETE',
    });
  },

  // Audit
  async getAuditLogs(params: {
    actor_user_id?: string;
    action?: string;
    object_type?: string;
    start_date?: string;
    end_date?: string;
    limit?: number;
    cursor?: string;
  } = {}): Promise<AuditLogListResponse> {
    const searchParams = new URLSearchParams();
    if (params.actor_user_id) searchParams.set('actor_user_id', params.actor_user_id);
    if (params.action) searchParams.set('action', params.action);
    if (params.object_type) searchParams.set('object_type', params.object_type);
    if (params.start_date) searchParams.set('start_date', params.start_date);
    if (params.end_date) searchParams.set('end_date', params.end_date);
    if (params.limit) searchParams.set('limit', String(params.limit));
    if (params.cursor) searchParams.set('cursor', params.cursor);

    return apiFetch(`/api/admin/audit-logs?${searchParams.toString()}`);
  },

  // System status
  async getSystemStatus(): Promise<SystemStatus> {
    return apiFetch('/api/admin/system/status');
  },

  // Password reset
  async requestPasswordReset(loginOrEmail: string): Promise<{ message: string }> {
    return apiFetch('/auth/password/forgot', {
      method: 'POST',
      body: JSON.stringify({ login_or_email: loginOrEmail }),
    });
  },

  async resetPassword(token: string, newPassword: string): Promise<{ message: string }> {
    return apiFetch('/auth/password/reset', {
      method: 'POST',
      body: JSON.stringify({ token, new_password: newPassword }),
    });
  },
};

// Token scopes configuration
export const TOKEN_SCOPES: TokenScope[] = [
  { scope: 'api:read', description: 'Read API access' },
  { scope: 'api:write', description: 'Write API access' },
  { scope: 'api:admin', description: 'Admin API access' },
  { scope: 'rag:read', description: 'Read RAG documents' },
  { scope: 'rag:write', description: 'Write RAG documents' },
  { scope: 'rag:admin', description: 'Admin RAG operations' },
  { scope: 'chat:read', description: 'Read chat history' },
  { scope: 'chat:write', description: 'Send messages' },
  { scope: 'chat:admin', description: 'Admin chat operations' },
  { scope: 'users:read', description: 'Read user data' },
  { scope: 'users:write', description: 'Write user data' },
  { scope: 'users:admin', description: 'Admin user operations' },
];

// Role hierarchy for scope expansion
export const SCOPE_HIERARCHY: Record<string, string[]> = {
  'api:admin': ['api:read', 'api:write'],
  'api:write': ['api:read'],
  'rag:admin': ['rag:read', 'rag:write'],
  'rag:write': ['rag:read'],
  'chat:admin': ['chat:read', 'chat:write'],
  'chat:write': ['chat:read'],
  'users:admin': ['users:read', 'users:write'],
  'users:write': ['users:read'],
};

export function expandScopes(scopes: string[]): string[] {
  const expanded = new Set(scopes);
  for (const scope of scopes) {
    if (SCOPE_HIERARCHY[scope]) {
      SCOPE_HIERARCHY[scope].forEach(s => expanded.add(s));
    }
  }
  return Array.from(expanded).sort();
}

// ===== shared/api/types.ts =====
/** Shared API types */
export interface Pagination {
  page?: number
  size?: number
  total?: number
  total_pages?: number
  has_next?: boolean
  has_prev?: boolean
}

export interface PaginatedResponse<T> {
  items: T[]
  next_cursor?: string | null
  pagination?: Pagination
}

export interface ApiResponse<T = any> {
  data?: T
  error?: {
    code: string
    message: string
  }
  request_id?: string
}

export interface Chat {
  id: string
  name?: string | null
  tags?: string[] | null
  created_at?: string | null
  updated_at?: string | null
  last_message_at?: string | null
}

export interface ChatMessage {
  id: string
  chat_id: string
  role: 'system' | 'user' | 'assistant' | 'tool'
  content: string
  created_at?: string | null
}

export interface ChatCreateRequest {
  name?: string | null
  tags?: string[] | null
}

export interface ChatUpdateRequest {
  name?: string | null
}

export interface ChatTagsUpdateRequest {
  tags: string[]
}

export interface ChatMessageRequest {
  content: string
  use_rag?: boolean
  response_stream?: boolean
}

export interface ChatMessageResponse {
  message_id: string
  content: string
  answer: string
  message?: string
}

export interface User {
  id: string
  email: string
  name?: string
  role?: string
  created_at?: string
  updated_at?: string
}

export interface LoginResponse {
  access_token: string
  token_type: string
  user: User
  refresh_token?: string
  expires_in?: number
}

export interface AuthTokens {
  access_token: string
  token_type: string
  refresh_token?: string
  expires_in?: number
}

export interface AnalyzeDocument {
  id: string
  name: string
  status: string
  created_at: string
  updated_at: string
  error?: string
  date_upload?: string
  result?: any
  url_canonical_file?: string
}

export interface RagDocument {
  id: string
  title: string
  content: string
  created_at: string
  updated_at: string
  name?: string
  status?: string
  progress?: number
  date_upload?: string
  tags?: string[]
  url_canonical_file?: string
}

// ===== shared/api/index.ts =====
export const API_BASE = (import.meta.env.VITE_API_BASE || '/api') as string

// Re-export admin API
export * from './admin'

// ===== shared/api/auth.ts =====
import { apiRequest } from './http'
import type { LoginResponse, User } from './types'

export async function login(login: string, password: string): Promise<LoginResponse> {
  return apiRequest<LoginResponse>('/auth/login', { method: 'POST', body: JSON.stringify({ login, password }) })
}

export async function me(): Promise<User> {
  return apiRequest<User>('/auth/me', { method: 'GET' })
}

export async function logout(): Promise<void> {
  return apiRequest<void>('/auth/logout', { method: 'POST' })
}

// ===== app/store/useChatStore.ts =====
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

export interface ChatMessage {
  id?: string
  role: 'user' | 'assistant' | 'system'
  content: string
  created_at?: string
  chat_id?: string
}

export interface Chat {
  id: string
  name?: string
  tags?: string[]
  created_at?: string
  updated_at?: string
  last_message_at?: string
  messages: ChatMessage[]
  isLoading?: boolean
  hasMore?: boolean
  nextCursor?: string | null
}

interface ChatState {
  chats: Record<string, Chat>
  currentChatId: string | null
  isLoading: boolean
  error: string | null
  searchQuery: string
  selectedTags: string[]
}

interface ChatActions {
  // Chat management
  addChat: (chat: Chat) => void
  updateChat: (chatId: string, updates: Partial<Chat>) => void
  deleteChat: (chatId: string) => void
  setCurrentChat: (chatId: string | null) => void
  
  // Messages
  addMessage: (chatId: string, message: ChatMessage) => void
  updateMessage: (chatId: string, messageId: string, updates: Partial<ChatMessage>) => void
  setMessages: (chatId: string, messages: ChatMessage[], hasMore: boolean, nextCursor: string | null) => void
  appendMessages: (chatId: string, messages: ChatMessage[], hasMore: boolean, nextCursor: string | null) => void
  
  // UI state
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  setSearchQuery: (query: string) => void
  setSelectedTags: (tags: string[]) => void
  
  // Bulk operations
  loadChats: (chats: Chat[]) => void
  clearError: () => void
  reset: () => void
}

type ChatStore = ChatState & ChatActions

const initialState: ChatState = {
  chats: {},
  currentChatId: null,
  isLoading: false,
  error: null,
  searchQuery: '',
  selectedTags: []
}

export const useChatStore = create<ChatStore>()(
  devtools(
    persist(
      immer((set, get) => ({
        ...initialState,
        
        // Chat management
        addChat: (chat) => set((state) => {
          state.chats[chat.id] = chat
        }),
        
        updateChat: (chatId, updates) => set((state) => {
          if (state.chats[chatId]) {
            Object.assign(state.chats[chatId], updates)
          }
        }),
        
        deleteChat: (chatId) => set((state) => {
          delete state.chats[chatId]
          if (state.currentChatId === chatId) {
            state.currentChatId = null
          }
        }),
        
        setCurrentChat: (chatId) => set((state) => {
          state.currentChatId = chatId
        }),
        
        // Messages
        addMessage: (chatId, message) => set((state) => {
          if (state.chats[chatId]) {
            state.chats[chatId].messages.push(message)
            state.chats[chatId].last_message_at = message.created_at || new Date().toISOString()
          }
        }),
        
        updateMessage: (chatId, messageId, updates) => set((state) => {
          if (state.chats[chatId]) {
            const messageIndex = state.chats[chatId].messages.findIndex(m => m.id === messageId)
            if (messageIndex !== -1) {
              Object.assign(state.chats[chatId].messages[messageIndex], updates)
            }
          }
        }),
        
        setMessages: (chatId, messages, hasMore, nextCursor) => set((state) => {
          if (state.chats[chatId]) {
            state.chats[chatId].messages = messages
            state.chats[chatId].hasMore = hasMore
            state.chats[chatId].nextCursor = nextCursor
            state.chats[chatId].isLoading = false
          }
        }),
        
        appendMessages: (chatId, messages, hasMore, nextCursor) => set((state) => {
          if (state.chats[chatId]) {
            state.chats[chatId].messages = [...messages, ...state.chats[chatId].messages]
            state.chats[chatId].hasMore = hasMore
            state.chats[chatId].nextCursor = nextCursor
            state.chats[chatId].isLoading = false
          }
        }),
        
        // UI state
        setLoading: (loading) => set((state) => {
          state.isLoading = loading
        }),
        
        setError: (error) => set((state) => {
          state.error = error
        }),
        
        setSearchQuery: (query) => set((state) => {
          state.searchQuery = query
        }),
        
        setSelectedTags: (tags) => set((state) => {
          state.selectedTags = tags
        }),
        
        // Bulk operations
        loadChats: (chats) => set((state) => {
          chats.forEach(chat => {
            state.chats[chat.id] = chat
          })
        }),
        
        clearError: () => set((state) => {
          state.error = null
        }),
        
        reset: () => set(() => initialState)
      })),
      {
        name: 'chat-store',
        partialize: (state) => ({
          chats: state.chats,
          currentChatId: state.currentChatId,
          searchQuery: state.searchQuery,
          selectedTags: state.selectedTags
        })
      }
    ),
    {
      name: 'chat-store'
    }
  )
)

// Selectors
export const useCurrentChat = () => useChatStore((state) => 
  state.currentChatId ? state.chats[state.currentChatId] : null
)

export const useChatMessages = (chatId: string) => useChatStore((state) => 
  state.chats[chatId]?.messages || []
)

export const useFilteredChats = () => useChatStore((state) => {
  const { chats, searchQuery, selectedTags } = state
  
  return Object.values(chats).filter(chat => {
    const matchesSearch = !searchQuery || 
      chat.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      chat.messages.some(msg => 
        msg.content.toLowerCase().includes(searchQuery.toLowerCase())
      )
    
    const matchesTags = selectedTags.length === 0 ||
      selectedTags.every(tag => chat.tags?.includes(tag))
    
    return matchesSearch && matchesTags
  }).sort((a, b) => 
    new Date(b.last_message_at || b.created_at || 0).getTime() - 
    new Date(a.last_message_at || a.created_at || 0).getTime()
  )
})

export const useChatStats = () => useChatStore((state) => {
  const chats = Object.values(state.chats)
  const totalMessages = chats.reduce((sum, chat) => sum + chat.messages.length, 0)
  const userMessages = chats.reduce((sum, chat) => 
    sum + chat.messages.filter(msg => msg.role === 'user').length, 0
  )
  const assistantMessages = chats.reduce((sum, chat) => 
    sum + chat.messages.filter(msg => msg.role === 'assistant').length, 0
  )
  
  return {
    totalChats: chats.length,
    totalMessages,
    userMessages,
    assistantMessages,
    averageMessagesPerChat: chats.length > 0 ? Math.round(totalMessages / chats.length) : 0
  }
})

// ===== app/store/auth.ts =====
import { useAuthStore } from '@/entities/auth/model/auth.store'

export type User = { id: string; login?: string; fio?: string; role?: string }

export const useAuth = () => {
  const authStore = useAuthStore()
  
  return {
    user: authStore.user,
    loading: false, // authStore doesn't have loading state
    error: null, // authStore doesn't have error state
    login: authStore.login,
    fetchMe: async () => {
      try {
        await authStore.hydrate()
        return authStore.user
      } catch {
        return null
      }
    },
    logout: authStore.logout
  }
}

// ===== main.tsx =====
import React from 'react'
import ReactDOM from 'react-dom/client'
import AppRouter from './app/router'
import { ToastProvider } from './shared/ui/Toast'
import './theme.css'

// Initialize auth tokens from localStorage
const initAuthTokens = () => {
  const token = localStorage.getItem('access_token');
  if (token) {
    (window as any).__auth_tokens = { access_token: token };
  }
};

initAuthTokens();

if ((import.meta as any).env?.VITE_USE_MOCKS === 'true') {
  import('./mocks/enableMocks')
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ToastProvider>
      <AppRouter />
    </ToastProvider>
  </React.StrictMode>
)

// ===== app/router.tsx =====
import React, { Suspense, lazy } from 'react'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'

const GPTGate = lazy(() => import('./routes/GPTGate'))
const Login = lazy(() => import('./routes/Login'))
const GPTLayout = lazy(() => import('./routes/gpt/GPTLayout'))
const ChatPage = lazy(() => import('./routes/gpt/ChatPage'))
const AnalyzePage = lazy(() => import('./routes/gpt/AnalyzePage'))
const RagPage = lazy(() => import('./routes/gpt/Rag'))
const NotFound = lazy(() => import('./routes/NotFound'))

// Admin routes
const AdminLayout = lazy(() => import('./routes/admin/AdminLayout'))
const UsersPage = lazy(() => import('./routes/admin/UsersPage'))
const CreateUserPage = lazy(() => import('./routes/admin/CreateUserPage'))
const UserDetailPage = lazy(() => import('./routes/admin/UserDetailPage'))
const AuditPage = lazy(() => import('./routes/admin/AuditPage'))
const EmailSettingsPage = lazy(() => import('./routes/admin/EmailSettingsPage'))

const withSuspense = (el: React.ReactNode) => <Suspense fallback={<div />}>{el}</Suspense>

const router = createBrowserRouter([
  { path: '/login', element: withSuspense(<Login />) },
  {
    path: '/gpt',
    element: withSuspense(<GPTGate>{withSuspense(<GPTLayout />)}</GPTGate>),
    children: [
      { path: 'chat', element: withSuspense(<ChatPage />) },
      { path: 'chat/:chatId', element: withSuspense(<ChatPage />) },
      { path: 'analyze', element: withSuspense(<AnalyzePage />) },
      { path: 'rag', element: withSuspense(<RagPage />) }
    ]
  },
  {
    path: '/admin',
    element: withSuspense(<GPTGate>{withSuspense(<AdminLayout />)}</GPTGate>),
    children: [
      { path: 'users', element: withSuspense(<UsersPage />) },
      { path: 'users/new', element: withSuspense(<CreateUserPage />) },
      { path: 'users/:id', element: withSuspense(<UserDetailPage />) },
      { path: 'audit', element: withSuspense(<AuditPage />) },
      { path: 'settings/email', element: withSuspense(<EmailSettingsPage />) }
    ]
  },
  { path: '*', element: withSuspense(<NotFound />) }
])

export default function AppRouter() {
  return <RouterProvider router={router} />
}

// ===== app/MockBadge.tsx =====
import React from 'react'
const USE_MOCKS = import.meta.env.VITE_USE_MOCKS === 'true'
export default function MockBadge() {
  if (!USE_MOCKS) return null
  const style: React.CSSProperties = {
    position: 'fixed', bottom: 12, right: 12, padding: '6px 10px',
    background: 'rgba(79,124,255,0.15)', border: '1px solid rgba(79,124,255,0.35)',
    borderRadius: 10, fontSize: 12, color: 'var(--text)', zIndex: 9999
  }
  return <div style={style}>Mocks ON</div>
}

// ===== shared/ui/Card.tsx =====
import React from 'react'
import styles from './Card.module.css'

export default function Card({ className='', ...rest }: React.HTMLAttributes<HTMLDivElement>) {
  return <div {...rest} className={[styles.card, className].join(' ')} />
}

// ===== shared/ui/Popover.tsx =====
import React, { useEffect, useRef, useState } from 'react'

export default function Popover({ trigger, content, align = 'start' }: { trigger: React.ReactNode, content: React.ReactNode, align?: 'start' | 'end' }) {
  const [open, setOpen] = useState(false)
  const ref = useRef<HTMLDivElement>(null)
  useEffect(() => {
    function onDoc(e: MouseEvent) { if (!ref.current?.contains(e.target as any)) setOpen(false) }
    document.addEventListener('mousedown', onDoc)
    return () => document.removeEventListener('mousedown', onDoc)
  }, [])
  return (
    <div ref={ref} style={{ position: 'relative' }}>
      <div onClick={() => setOpen(v => !v)}>{trigger}</div>
      {open && (
        <div style={{ position: 'absolute', top: '100%', [align === 'end' ? 'right' : 'left']: 0, zIndex: 10, background: 'var(--panel)', border: '1px solid rgba(255,255,255,.12)', borderRadius: 8, padding: 4, boxShadow: '0 6px 24px rgba(0,0,0,.35)' } as any}>
          {content}
        </div>
      )}
    </div>
  )
}

// ===== shared/ui/Icon.tsx =====
import React from 'react'

export function FilterIcon({ active=false, size=14 }: { active?: boolean, size?: number }) {
  const stroke = active ? 'var(--primary)' : 'currentColor'
  const fill = active ? 'var(--primary)' : 'none'
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M3 5h18l-7 8v5l-4 2v-7L3 5z" fill={fill} stroke={stroke} strokeWidth="1.5"/>
    </svg>
  )
}

export function MoreVerticalIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <circle cx="12" cy="6" r="2" fill="currentColor"/>
      <circle cx="12" cy="12" r="2" fill="currentColor"/>
      <circle cx="12" cy="18" r="2" fill="currentColor"/>
    </svg>
  )
}

export function DownloadIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" strokeWidth="2" fill="none"/>
      <polyline points="7,10 12,15 17,10" stroke="currentColor" strokeWidth="2" fill="none"/>
      <line x1="12" y1="15" x2="12" y2="3" stroke="currentColor" strokeWidth="2"/>
    </svg>
  )
}

export function RefreshIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" stroke="currentColor" strokeWidth="2" fill="none"/>
    </svg>
  )
}

export function ArchiveIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <rect x="2" y="3" width="20" height="4" rx="2" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M4 7v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M10 13h4" stroke="currentColor" strokeWidth="2"/>
    </svg>
  )
}

export function TrashIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M3 6h18" stroke="currentColor" strokeWidth="2"/>
      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" stroke="currentColor" strokeWidth="2" fill="none"/>
    </svg>
  )
}

// ===== shared/ui/RoleBadge.tsx =====
import React from 'react';
import styles from './RoleBadge.module.css';

export interface RoleBadgeProps {
  role: 'admin' | 'editor' | 'reader';
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

export function RoleBadge({ role, size = 'medium', className = '' }: RoleBadgeProps) {
  const getRoleLabel = (role: string) => {
    switch (role) {
      case 'admin':
        return 'Admin';
      case 'editor':
        return 'Editor';
      case 'reader':
        return 'Reader';
      default:
        return role;
    }
  };

  return (
    <span className={`${styles.badge} ${styles[role]} ${styles[size]} ${className}`}>
      {getRoleLabel(role)}
    </span>
  );
}

export interface StatusBadgeProps {
  active: boolean;
  size?: 'small' | 'medium' | 'large';
  className?: string;
}

export function StatusBadge({ active, size = 'medium', className = '' }: StatusBadgeProps) {
  return (
    <span className={`${styles.badge} ${active ? styles.active : styles.inactive} ${styles[size]} ${className}`}>
      {active ? 'Active' : 'Inactive'}
    </span>
  );
}

export default RoleBadge;

// ===== shared/ui/FilePicker.tsx =====
import React, { useRef } from 'react'
import Button from './Button'
import styles from './FilePicker.module.css'

type Props = {
  onFileSelected: (file: File | null) => void
  accept?: string
  disabled?: boolean
  label?: string
}

export default function FilePicker({ onFileSelected, accept, disabled, label='Choose file' }: Props) {
  const ref = useRef<HTMLInputElement>(null)
  return (
    <div className={styles.wrap}>
      <input
        ref={ref}
        type="file"
        className={styles.inputHidden}
        accept={accept}
        onChange={e => onFileSelected(e.target.files?.[0] || null)}
        disabled={disabled}
      />
      <Button onClick={() => ref.current?.click()} disabled={disabled}>{label}</Button>
    </div>
  )
}

// ===== shared/ui/Badge.tsx =====
import React from 'react'
import styles from './Badge.module.css'

type Props = React.HTMLAttributes<HTMLSpanElement> & {
  tone?: 'neutral' | 'success' | 'warn' | 'danger' | 'info'
  children: React.ReactNode
  className?: string
}

export default function Badge({ tone='neutral', className='', children, ...rest }: Props) {
  return <span {...rest} className={[styles.badge, styles[tone], className].join(' ')}>{children}</span>
}

// ===== shared/ui/Table.tsx =====
import React from 'react';
import styles from './Table.module.css';

export interface TableColumn<T = any> {
  key: string;
  title: string;
  dataIndex?: keyof T;
  render?: (value: any, record: T, index: number) => React.ReactNode;
  width?: string | number;
  align?: 'left' | 'center' | 'right';
  sortable?: boolean;
  className?: string;
}

export interface TableProps<T = any> {
  columns: TableColumn<T>[];
  data: T[];
  loading?: boolean;
  emptyText?: string;
  emptyIcon?: React.ReactNode;
  onRowClick?: (record: T, index: number) => void;
  onRowDoubleClick?: (record: T, index: number) => void;
  rowKey?: keyof T | ((record: T) => string);
  selectedRowKeys?: string[];
  onSelectionChange?: (selectedKeys: string[]) => void;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  onSort?: (column: string, order: 'asc' | 'desc') => void;
  className?: string;
  size?: 'small' | 'medium' | 'large';
  stickyHeader?: boolean;
}

export function Table<T = any>({
  columns,
  data,
  loading = false,
  emptyText = 'No data',
  emptyIcon,
  onRowClick,
  onRowDoubleClick,
  rowKey = 'id',
  selectedRowKeys = [],
  onSelectionChange,
  sortBy,
  sortOrder,
  onSort,
  className = '',
  size = 'medium',
  stickyHeader = true,
}: TableProps<T>) {
  const getRowKey = (record: T, index: number): string => {
    if (typeof rowKey === 'function') {
      return rowKey(record);
    }
    return String(record[rowKey as keyof T] || index);
  };

  const handleSort = (column: string) => {
    if (!onSort) return;
    
    const newOrder = sortBy === column && sortOrder === 'asc' ? 'desc' : 'asc';
    onSort(column, newOrder);
  };

  const renderEmptyState = () => (
    <tr>
      <td colSpan={columns.length} className={styles.emptyState}>
        {emptyIcon && <div className={styles.emptyStateIcon}>{emptyIcon}</div>}
        <div className={styles.emptyStateTitle}>No data</div>
        <div className={styles.emptyStateDescription}>{emptyText}</div>
      </td>
    </tr>
  );

  const renderLoadingRow = () => (
    <tr>
      <td colSpan={columns.length} className={styles.loadingRow}>
        <div className={styles.skeleton} style={{ width: '200px', margin: '0 auto' }} />
      </td>
    </tr>
  );

  const renderSkeletonRows = () => {
    return Array.from({ length: 5 }).map((_, index) => (
      <tr key={index}>
        {columns.map((column) => (
          <td key={column.key} className={`${styles.tableCell} ${styles.loadingCell}`}>
            <div className={`${styles.skeleton} ${index % 3 === 0 ? styles.short : index % 3 === 1 ? styles.medium : styles.long}`} />
          </td>
        ))}
      </tr>
    ));
  };

  const renderHeader = () => (
    <thead className={styles.tableHeader}>
      <tr>
        {columns.map((column) => (
          <th
            key={column.key}
            className={`
              ${styles.tableHeaderCell}
              ${column.sortable ? styles.sortable : ''}
              ${sortBy === column.key ? styles.active : ''}
              ${column.className || ''}
            `}
            style={{
              width: column.width,
              textAlign: column.align || 'left',
            }}
            onClick={column.sortable ? () => handleSort(column.key) : undefined}
          >
            {column.title}
            {column.sortable && sortBy === column.key && (
              <span style={{ marginLeft: '4px' }}>
                {sortOrder === 'asc' ? '↑' : '↓'}
              </span>
            )}
          </th>
        ))}
      </tr>
    </thead>
  );

  const renderBody = () => (
    <tbody className={styles.tableBody}>
      {loading ? (
        renderSkeletonRows()
      ) : data.length === 0 ? (
        renderEmptyState()
      ) : (
        data.map((record, index) => {
          const key = getRowKey(record, index);
          const isSelected = selectedRowKeys.includes(key);
          
          return (
            <tr
              key={key}
              className={`${styles.tableRow} ${isSelected ? styles.selected : ''}`}
              onClick={() => onRowClick?.(record, index)}
              onDoubleClick={() => onRowDoubleClick?.(record, index)}
            >
              {columns.map((column) => {
                const value = column.dataIndex ? record[column.dataIndex] : undefined;
                const cellContent = column.render ? column.render(value, record, index) : value;
                
                return (
                  <td
                    key={column.key}
                    className={`
                      ${styles.tableCell}
                      ${size === 'small' ? styles.compact : ''}
                      ${column.align === 'right' ? styles.numeric : ''}
                      ${column.key === 'actions' ? styles.actions : ''}
                      ${column.className || ''}
                    `}
                    style={{
                      textAlign: column.align || 'left',
                    }}
                  >
                    {cellContent}
                  </td>
                );
              })}
            </tr>
          );
        })
      )}
    </tbody>
  );

  return (
    <div className={`${styles.tableContainer} ${className}`}>
      <table className={styles.table}>
        {stickyHeader && renderHeader()}
        {renderBody()}
      </table>
    </div>
  );
}

export default Table;

// ===== shared/ui/Button.tsx =====
import React from 'react'
import styles from './Button.module.css'

type Props = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: 'primary' | 'ghost' | 'danger'
  size?: 'md' | 'sm' | 'small'
}

export default function Button({ variant='primary', size='md', className='', ...rest }: Props) {
  const sizeClass = size === 'small' ? 'sm' : size
  const cls = [styles.btn, styles[variant], styles[sizeClass], className].join(' ')
  return <button {...rest} className={cls} />
}

// ===== shared/ui/Modal.tsx =====
import React from 'react'
import styles from './Modal.module.css'
import Button from './Button'

type Size = 'md' | 'half'

type Props = {
  open: boolean
  title?: string
  onClose: () => void
  footer?: React.ReactNode
  children?: React.ReactNode
  size?: Size
}

export default function Modal({ open, title, onClose, children, footer, size='md' }: Props) {
  if (!open) return null
  return (
    <div className={styles.backdrop} onClick={onClose}>
      <div className={[styles.modal, size==='half' ? styles.half : ''].join(' ')} onClick={e=>e.stopPropagation()}>
        <div className={styles.head}>
          <div className={styles.title}>{title}</div>
          <Button size="sm" variant="ghost" onClick={onClose}>✕</Button>
        </div>
        <div className={styles.body}>{children}</div>
        {footer && <div className={styles.foot}>{footer}</div>}
      </div>
    </div>
  )
}

// ===== shared/ui/Toast.tsx =====
import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
import styles from './Toast.module.css';

export interface Toast {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  title?: string;
  message: string;
  duration?: number;
  actions?: Array<{
    label: string;
    onClick: () => void;
  }>;
}

interface ToastContextType {
  showToast: (toast: Omit<Toast, 'id'>) => string;
  hideToast: (id: string) => void;
  hideAllToasts: () => void;
}

const ToastContext = createContext<ToastContextType | null>(null);

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}

interface ToastProviderProps {
  children: React.ReactNode;
}

export function ToastProvider({ children }: ToastProviderProps) {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const showToast = useCallback((toast: Omit<Toast, 'id'>) => {
    const id = Math.random().toString(36).substr(2, 9);
    const newToast: Toast = {
      id,
      duration: 5000,
      ...toast,
    };
    
    setToasts(prev => [...prev, newToast]);
    
    // Auto-hide after duration
    if (newToast.duration && newToast.duration > 0) {
      setTimeout(() => {
        hideToast(id);
      }, newToast.duration);
    }
    
    return id;
  }, []);

  const hideToast = useCallback((id: string) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  }, []);

  const hideAllToasts = useCallback(() => {
    setToasts([]);
  }, []);

  return (
    <ToastContext.Provider value={{ showToast, hideToast, hideAllToasts }}>
      {children}
      <ToastContainer toasts={toasts} onHide={hideToast} />
    </ToastContext.Provider>
  );
}

interface ToastContainerProps {
  toasts: Toast[];
  onHide: (id: string) => void;
}

function ToastContainer({ toasts, onHide }: ToastContainerProps) {
  if (toasts.length === 0) return null;

  return (
    <div className={styles.toastContainer}>
      {toasts.map(toast => (
        <ToastItem key={toast.id} toast={toast} onHide={onHide} />
      ))}
    </div>
  );
}

interface ToastItemProps {
  toast: Toast;
  onHide: (id: string) => void;
}

function ToastItem({ toast, onHide }: ToastItemProps) {
  const getIcon = (type: Toast['type']) => {
    switch (type) {
      case 'success':
        return '✓';
      case 'error':
        return '✕';
      case 'warning':
        return '⚠';
      case 'info':
        return 'ℹ';
      default:
        return 'ℹ';
    }
  };

  return (
    <div className={`${styles.toast} ${styles[toast.type]}`}>
      <div className={styles.toastIcon}>
        {getIcon(toast.type)}
      </div>
      
      <div className={styles.toastContent}>
        {toast.title && (
          <div className={styles.toastTitle}>
            {toast.title}
          </div>
        )}
        <div className={styles.toastMessage}>
          {toast.message}
        </div>
        
        {toast.actions && toast.actions.length > 0 && (
          <div className={styles.toastActions}>
            {toast.actions.map((action, index) => (
              <button
                key={index}
                onClick={action.onClick}
                className="text-sm text-primary hover:text-primary-dark underline"
              >
                {action.label}
              </button>
            ))}
          </div>
        )}
      </div>
      
      <button
        className={styles.toastClose}
        onClick={() => onHide(toast.id)}
        aria-label="Close notification"
      >
        ×
      </button>
      
      {toast.duration && toast.duration > 0 && (
        <div
          className={styles.toastProgress}
          style={{ animationDuration: `${toast.duration}ms` }}
        />
      )}
    </div>
  );
}

// Convenience hooks
export function useSuccessToast() {
  const { showToast } = useToast();
  return useCallback((message: string, title?: string) => {
    return showToast({ type: 'success', message, title });
  }, [showToast]);
}

export function useErrorToast() {
  const { showToast } = useToast();
  return useCallback((message: string, title?: string) => {
    return showToast({ type: 'error', message, title });
  }, [showToast]);
}

export function useWarningToast() {
  const { showToast } = useToast();
  return useCallback((message: string, title?: string) => {
    return showToast({ type: 'warning', message, title });
  }, [showToast]);
}

export function useInfoToast() {
  const { showToast } = useToast();
  return useCallback((message: string, title?: string) => {
    return showToast({ type: 'info', message, title });
  }, [showToast]);
}

export default Toast;

// ===== shared/ui/Select.tsx =====
import React from 'react'
import styles from './Select.module.css'

type Props = React.SelectHTMLAttributes<HTMLSelectElement> & { containerClassName?: string }

const Select = React.forwardRef<HTMLSelectElement, Props>(({ containerClassName, className, children, ...rest }, ref) => {
  return (
    <span className={[styles.root, containerClassName||''].join(' ')}>
      <select ref={ref} className={[styles.select, className||''].join(' ')} {...rest}>
        {children}
      </select>
      <svg className={styles.arrow} width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
      </svg>
    </span>
  )
})
Select.displayName = 'Select'
export default Select

// ===== shared/ui/Textarea.tsx =====
import React from 'react'
import styles from './Textarea.module.css'

type Props = React.TextareaHTMLAttributes<HTMLTextAreaElement>

const Textarea = React.forwardRef<HTMLTextAreaElement, Props>((props, ref) => {
  return <textarea {...props} ref={ref} className={[styles.textarea, props.className||''].join(' ')} />
})
Textarea.displayName = 'Textarea'

export default Textarea

// ===== shared/ui/Input.tsx =====
import React from 'react'
import styles from './Input.module.css'

type Props = React.InputHTMLAttributes<HTMLInputElement>

export default function Input(props: Props) {
  return <input {...props} className={[styles.input, props.className||''].join(' ')} />
}

// ===== shared/ui/Skeleton.tsx =====
import React from 'react';
import styles from './Skeleton.module.css';

export interface SkeletonProps {
  variant?: 'text' | 'circle' | 'rectangle' | 'avatar' | 'button' | 'badge' | 'card' | 'table';
  size?: 'short' | 'medium' | 'long';
  width?: string | number;
  height?: string | number;
  className?: string;
  style?: React.CSSProperties;
}

export function Skeleton({
  variant = 'text',
  size = 'medium',
  width,
  height,
  className = '',
  style = {},
}: SkeletonProps) {
  const skeletonStyle = {
    ...style,
    ...(width && { width: typeof width === 'number' ? `${width}px` : width }),
    ...(height && { height: typeof height === 'number' ? `${height}px` : height }),
  };

  return (
    <div
      className={`
        ${styles.skeleton}
        ${styles[variant]}
        ${variant === 'text' ? styles[size] : ''}
        ${className}
      `}
      style={skeletonStyle}
    />
  );
}

export interface SkeletonListProps {
  count?: number;
  variant?: 'vertical' | 'horizontal' | 'grid';
  children?: React.ReactNode;
  className?: string;
}

export function SkeletonList({
  count = 5,
  variant = 'vertical',
  children,
  className = '',
}: SkeletonListProps) {
  const items = children || Array.from({ length: count }, (_, index) => (
    <Skeleton key={index} />
  ));

  return (
    <div className={`${styles.skeletonList} ${styles[variant]} ${className}`}>
      {items}
    </div>
  );
}

export interface SkeletonTableProps {
  rows?: number;
  columns?: number;
  showAvatar?: boolean;
  showBadge?: boolean;
  showActions?: boolean;
  className?: string;
}

export function SkeletonTable({
  rows = 5,
  columns = 4,
  showAvatar = false,
  showBadge = false,
  showActions = true,
  className = '',
}: SkeletonTableProps) {
  const renderRow = (rowIndex: number) => (
    <div key={rowIndex} className={styles.skeletonTableRow}>
      {showAvatar && (
        <div className={styles.skeletonTableCell}>
          <Skeleton variant="avatar" />
        </div>
      )}
      
      {Array.from({ length: columns }, (_, colIndex) => (
        <div key={colIndex} className={styles.skeletonTableCell}>
          <Skeleton variant="table" size={colIndex % 3 === 0 ? 'short' : colIndex % 3 === 1 ? 'medium' : 'long'} />
        </div>
      ))}
      
      {showBadge && (
        <div className={`${styles.skeletonTableCell} ${styles.badge}`}>
          <Skeleton variant="badge" />
        </div>
      )}
      
      {showActions && (
        <div className={`${styles.skeletonTableCell} ${styles.actions}`}>
          <Skeleton variant="button" />
        </div>
      )}
    </div>
  );

  return (
    <div className={`${styles.skeletonTable} ${className}`}>
      {Array.from({ length: rows }, (_, index) => renderRow(index))}
    </div>
  );
}

export interface SkeletonCardProps {
  showAvatar?: boolean;
  showActions?: boolean;
  className?: string;
}

export function SkeletonCard({
  showAvatar = true,
  showActions = true,
  className = '',
}: SkeletonCardProps) {
  return (
    <div className={`${styles.skeleton.card} ${className}`}>
      <div style={{ padding: 'var(--spacing-md)' }}>
        {showAvatar && (
          <div style={{ display: 'flex', alignItems: 'center', marginBottom: 'var(--spacing-sm)' }}>
            <Skeleton variant="avatar" />
            <div style={{ marginLeft: 'var(--spacing-sm)', flex: 1 }}>
              <Skeleton size="medium" style={{ marginBottom: 'var(--spacing-xs)' }} />
              <Skeleton size="short" />
            </div>
          </div>
        )}
        
        <div style={{ marginBottom: 'var(--spacing-sm)' }}>
          <Skeleton size="long" style={{ marginBottom: 'var(--spacing-xs)' }} />
          <Skeleton size="medium" />
        </div>
        
        {showActions && (
          <div style={{ display: 'flex', gap: 'var(--spacing-sm)', justifyContent: 'flex-end' }}>
            <Skeleton variant="button" />
            <Skeleton variant="button" />
          </div>
        )}
      </div>
    </div>
  );
}

export default Skeleton;

// ===== shared/ui/ThemeSwitch.tsx =====
import React, { useEffect, useState } from 'react'

type Mode = 'light' | 'dark'
const KEY = 'theme'

function getInitial(): Mode {
  const saved = (localStorage.getItem(KEY) as Mode | null)
  if (saved === 'light' || saved === 'dark') return saved
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  return prefersDark ? 'dark' : 'light'
}

export default function ThemeSwitch() {
  const [mode, setMode] = useState<Mode>(getInitial())

  useEffect(() => {
    const root = document.documentElement
    if (mode === 'dark') {
      root.removeAttribute('data-theme') // было '' — убираем атрибут полностью
    } else {
      root.setAttribute('data-theme', 'light')
    }
    localStorage.setItem(KEY, mode)
  }, [mode])

  return (
    <button
      onClick={() => setMode(m => (m === 'dark' ? 'light' : 'dark'))}
      aria-label="Переключить тему"
      style={{
        background: 'transparent',
        border: '1px solid rgba(255,255,255,.15)',
        color: 'inherit',
        borderRadius: 12,
        padding: '6px 10px',
        cursor: 'pointer'
      }}
    >
      {mode === 'light' ? '☀️ Light' : '🌙 Dark'}
    </button>
  )
}

// ===== shared/ui/ErrorBoundary.tsx =====
import React from 'react'

type State = { hasError: boolean, error?: any }
export default class ErrorBoundary extends React.Component<React.PropsWithChildren, State> {
  state: State = { hasError: false }
  static getDerivedStateFromError(error: any) { return { hasError: true, error } }
  componentDidCatch(error: any, errorInfo: any) { console.error('UI error:', error, errorInfo) }
  render() {
    if (this.state.hasError) {
      return (
        <div style={{padding:24}}>
          <h2>Что-то пошло не так</h2>
          <div style={{opacity:.7, fontSize:14}}>{String(this.state.error || '')}</div>
          <button onClick={()=>this.setState({hasError:false, error: undefined})} style={{marginTop:12}}>Перезагрузить вид</button>
        </div>
      )
    }
    return this.props.children
  }
}

// ===== app/contexts/ChatContext.tsx =====
import React, { createContext, useContext, useReducer, useEffect, useRef } from 'react'
import * as chatsApi from '@shared/api/chats'
import type { Chat, ChatMessage } from '@shared/api/types'

type MessagesState = {
  items: ChatMessage[]
  nextCursor: string | null
  hasMore: boolean
  loaded: boolean
}

type ChatState = {
  isLoading: boolean
  error: string | null
  chatsOrder: string[]
  chatsById: Record<string, Chat>
  messagesByChat: Record<string, MessagesState>
  currentChatId: string | null
}

type ChatAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_CHATS'; payload: Chat[] }
  | { type: 'UPSERT_CHAT'; payload: Chat }
  | { type: 'DELETE_CHAT'; payload: string }
  | { type: 'SET_CURRENT_CHAT'; payload: string | null }
  | { type: 'SET_MESSAGES'; payload: { chatId: string; items: ChatMessage[]; nextCursor: string | null; hasMore: boolean } }
  | { type: 'APPEND_MESSAGES'; payload: { chatId: string; items: ChatMessage[]; nextCursor: string | null; hasMore: boolean } }
  | { type: 'ADD_MESSAGE'; payload: { chatId: string; item: ChatMessage } }
  | { type: 'UPDATE_CHAT_PARTIAL'; payload: { chatId: string; patch: Partial<Chat> } }

const initialState: ChatState = {
  isLoading: false,
  error: null,
  chatsOrder: [],
  chatsById: {},
  messagesByChat: {},
  currentChatId: null,
}

function reducer(state: ChatState, action: ChatAction): ChatState {
  switch (action.type) {
    case 'SET_LOADING': return { ...state, isLoading: action.payload }
    case 'SET_ERROR': return { ...state, error: action.payload }
    case 'SET_CURRENT_CHAT': return { ...state, currentChatId: action.payload }

    case 'SET_CHATS': {
      const byId: Record<string, Chat> = {}
      const order: string[] = []
      for (const c of action.payload) {
        byId[c.id] = c
        order.push(c.id)
      }
      return { ...state, chatsById: byId, chatsOrder: order }
    }

    case 'UPSERT_CHAT': {
      const id = action.payload.id
      const exists = !!state.chatsById[id]
      const chatsById = { ...state.chatsById, [id]: { ...state.chatsById[id], ...action.payload } }
      const chatsOrder = exists ? state.chatsOrder : [id, ...state.chatsOrder]
      return { ...state, chatsById, chatsOrder }
    }

    case 'DELETE_CHAT': {
      const { [action.payload]: _omit, ...rest } = state.chatsById
      return { ...state, chatsById: rest, chatsOrder: state.chatsOrder.filter(id => id !== action.payload) }
    }

    case 'SET_MESSAGES': {
      const { chatId, items, nextCursor, hasMore } = action.payload
      const messagesByChat = { ...state.messagesByChat, [chatId]: { items, nextCursor, hasMore, loaded: true } }
      return { ...state, messagesByChat }
    }

    case 'APPEND_MESSAGES': {
      const { chatId, items, nextCursor, hasMore } = action.payload
      const prev = state.messagesByChat[chatId] || { items: [], nextCursor: null, hasMore: false, loaded: false }
      const merged = [...prev.items, ...items]
      return { ...state, messagesByChat: { ...state.messagesByChat, [chatId]: { items: merged, nextCursor, hasMore, loaded: true } } }
    }

    case 'ADD_MESSAGE': {
      const { chatId, item } = action.payload
      const prev = state.messagesByChat[chatId] || { items: [], nextCursor: null, hasMore: false, loaded: false }
      return { ...state, messagesByChat: { ...state.messagesByChat, [chatId]: { ...prev, items: [...prev.items, item], loaded: true } } }
    }

    case 'UPDATE_CHAT_PARTIAL': {
      const { chatId, patch } = action.payload
      const chat = state.chatsById[chatId]
      if (!chat) return state
      return { ...state, chatsById: { ...state.chatsById, [chatId]: { ...chat, ...patch } } }
    }
  }
}

type ChatContextValue = {
  state: ChatState
  loadChats: () => Promise<void>
  loadChatsIfAuthenticated: () => Promise<void>
  createChat: (name?: string | null, tags?: string[] | null) => Promise<string>
  renameChat: (chatId: string, name: string) => Promise<void>
  deleteChat: (chatId: string) => Promise<void>
  removeChatLocal: (chatId: string) => void
  restoreChatLocal: (chat: Chat) => void
  deleteChatApiOnly: (chatId: string) => Promise<void>
  updateChatTags: (chatId: string, tags: string[]) => Promise<void>
  setCurrentChat: (chatId: string | null) => void
  loadMessages: (chatId: string, append?: boolean) => Promise<void>
  sendMessage: (chatId: string, content: string, useRag?: boolean) => Promise<string>
  sendMessageStream: (chatId: string, content: string, onDelta: (chunk: string) => void, useRag?: boolean) => Promise<void>
}

const ChatContext = createContext<ChatContextValue | undefined>(undefined)

export function ChatProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(reducer, initialState)
  const bootRef = useRef(false)

  async function loadChats() {
    dispatch({ type: 'SET_LOADING', payload: true })
    try {
      const res = await chatsApi.listChats({ limit: 100 })
      dispatch({ type: 'SET_CHATS', payload: res.items })
      dispatch({ type: 'SET_ERROR', payload: null })
    } catch (e: any) {
      dispatch({ type: 'SET_ERROR', payload: e?.message || 'failed_to_load_chats' })
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false })
    }
  }

  async function loadChatsIfAuthenticated() {
    const token = (window as any).__auth_tokens?.access_token || localStorage.getItem('access_token')
    if (token) {
      await loadChats()
    }
  }

  useEffect(() => {
    if (bootRef.current) return
    bootRef.current = true
    loadChatsIfAuthenticated()
  }, [])

  async function createChat(name?: string | null, tags?: string[] | null) {
    const res = await chatsApi.createChat(name ?? null, tags ?? null)
    const chatId = res.chat_id
    // optimistic
    dispatch({ type: 'UPSERT_CHAT', payload: { id: chatId, name: name ?? null, tags: tags ?? null } as Chat })
    return chatId
  }

  async function renameChat(chatId: string, name: string) {
    await chatsApi.renameChat(chatId, name)
    dispatch({ type: 'UPDATE_CHAT_PARTIAL', payload: { chatId, patch: { name } } })
  }

  async function deleteChat(chatId: string) {
    await chatsApi.deleteChat(chatId)
    dispatch({ type: 'DELETE_CHAT', payload: chatId })
    if (state.currentChatId === chatId) dispatch({ type: 'SET_CURRENT_CHAT', payload: null })
  }

function removeChatLocal(chatId: string) {
  dispatch({ type: 'DELETE_CHAT', payload: chatId })
  if (state.currentChatId === chatId) dispatch({ type: 'SET_CURRENT_CHAT', payload: null })
}

function restoreChatLocal(chat: Chat) {
  dispatch({ type: 'UPSERT_CHAT', payload: chat })
}

async function deleteChatApiOnly(chatId: string) {
  await chatsApi.deleteChat(chatId)
}

  async function updateChatTags(chatId: string, tags: string[]) {
    await chatsApi.updateChatTags(chatId, tags)
    dispatch({ type: 'UPDATE_CHAT_PARTIAL', payload: { chatId, patch: { tags } } })
  }

  function setCurrentChat(chatId: string | null) {
    dispatch({ type: 'SET_CURRENT_CHAT', payload: chatId })
  }

  async function loadMessages(chatId: string, append?: boolean) {
    const cur = state.messagesByChat[chatId]
    if (!append && cur?.loaded) return // avoid duplicate initial load
    const res = await chatsApi.listMessages(chatId, append ? { cursor: cur?.nextCursor || undefined } : {})
    const items = res.items
    const next = res.next_cursor ?? null
    const hasMore = !!next && items.length > 0
    dispatch({ type: append ? 'APPEND_MESSAGES' : 'SET_MESSAGES', payload: { chatId, items, nextCursor: next, hasMore } })
  }

  async function sendMessage(chatId: string, content: string, useRag?: boolean) {
    const res = await chatsApi.sendMessage(chatId, { content, use_rag: !!useRag })
    const userMsg: ChatMessage = { id: res.message_id, chat_id: chatId, role: 'user', content }
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: userMsg } })
    const assistantMsg: ChatMessage = { id: crypto.randomUUID(), chat_id: chatId, role: 'assistant', content: res.answer }
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: assistantMsg } })
    return res.message_id
  }

  async function sendMessageStream(chatId: string, content: string, onDelta: (chunk: string) => void, useRag?: boolean) {
    // add user message immediately
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: { id: crypto.randomUUID(), chat_id: chatId, role: 'user', content } } })
    let acc = ''
    for await (const chunk of chatsApi.sendMessageStream(chatId, { content, use_rag: !!useRag })) {
      acc += chunk
      onDelta(acc)
    }
    // push final assistant message
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: { id: crypto.randomUUID(), chat_id: chatId, role: 'assistant', content: acc } } })
  }

  const value: ChatContextValue = {
    state,
    loadChats,
    loadChatsIfAuthenticated,
    createChat,
    renameChat,
    deleteChat,
    removeChatLocal,
    restoreChatLocal,
    deleteChatApiOnly,
    updateChatTags,
    setCurrentChat,
    loadMessages,
    sendMessage,
    sendMessageStream,
  }

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>
}

export function useChat() {
  const ctx = useContext(ChatContext)
  if (!ctx) throw new Error('useChat must be used within ChatProvider')
  return ctx
}

// ===== app/components/AccessibleButton.tsx =====
import React from 'react'
import Button from '@shared/ui/Button'
import styles from './AccessibleButton.module.css'

interface AccessibleButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'ghost' | 'danger'
  size?: 'md' | 'sm' | 'small'
  loading?: boolean
  icon?: React.ReactNode
  children: React.ReactNode
  ariaLabel?: string
  ariaDescribedBy?: string
  ariaExpanded?: boolean
  ariaControls?: string
  ariaPressed?: boolean
}

const AccessibleButton = React.forwardRef<HTMLButtonElement, AccessibleButtonProps>(
  ({
    variant = 'primary',
    size = 'md',
    loading = false,
    icon,
    children,
    ariaLabel,
    ariaDescribedBy,
    ariaExpanded,
    ariaControls,
    ariaPressed,
    disabled,
    className = '',
    ...rest
  }, ref) => {
    const sizeClass = size === 'small' ? 'sm' : size
    const cls = [styles.btn, styles[variant], styles[sizeClass], className].join(' ')
    
    return (
      <button
        ref={ref}
        className={cls}
        disabled={disabled || loading}
        aria-label={ariaLabel}
        aria-describedby={ariaDescribedBy}
        aria-expanded={ariaExpanded}
        aria-controls={ariaControls}
        aria-pressed={ariaPressed}
        aria-busy={loading}
        {...rest}
      >
        {loading && (
          <span 
            className={styles.spinner} 
            aria-hidden="true"
            role="status"
          />
        )}
        {icon && !loading && (
          <span className={styles.icon} aria-hidden="true">
            {icon}
          </span>
        )}
        <span className={loading ? styles.hidden : ''}>
          {children}
        </span>
      </button>
    )
  }
)

AccessibleButton.displayName = 'AccessibleButton'

export default AccessibleButton

// ===== app/components/ChatStatus.tsx =====
import React from 'react'
import { useChat } from '../contexts/ChatContext'
import styles from './ChatStatus.module.css'

export default function ChatStatus() {
  const { state } = useChat()
  const { error, isLoading } = state

  if (!error && !isLoading) return null

  return (
    <div className={styles.statusBar}>
      {isLoading && (
        <div className={styles.loading}>
          <div className={styles.spinner} />
          Загрузка...
        </div>
      )}
      {error && (
        <div className={styles.error}>
          ⚠️ {error}
        </div>
      )}
    </div>
  )
}

// ===== app/components/ChatTags.tsx =====
import React, { useState } from 'react'
import Modal from '@shared/ui/Modal'
import Input from '@shared/ui/Input'
import Button from '@shared/ui/Button'

export default function ChatTags({ chatId, tags, onTagsChange }: { chatId: string, tags: string[], onTagsChange: (tags: string[]) => void }) {
  const [local, setLocal] = useState<string[]>(tags || [])
  const [open, setOpen] = useState(true)
  const [draft, setDraft] = useState('')

  function add() {
    const t = draft.trim()
    if (!t) return
    if (local.includes(t)) return
    setLocal([...local, t])
    setDraft('')
  }
  function remove(t: string) {
    setLocal(local.filter(x => x !== t))
  }

  return (
    <Modal open={open} onClose={() => setOpen(false)} title="Теги"
      footer={<>
        <Button variant="ghost" onClick={() => setOpen(false)}>Закрыть</Button>
        <Button onClick={() => { onTagsChange(local); setOpen(false) }}>Сохранить</Button>
      </>}
    >
      <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8 }}>
        <Input value={draft} onChange={e => setDraft(e.target.value)} placeholder="Новый тег" onKeyDown={e => { if (e.key === 'Enter') add() }} />
        <Button onClick={add}>Добавить</Button>
      </div>
      <div style={{ display: 'flex', gap: 6, flexWrap: 'wrap' }}>
        {local.map(t => (
          <span key={t} style={{ border: '1px solid rgba(255,255,255,.2)', padding: '2px 8px', borderRadius: 999 }}>
            {t} <button onClick={() => remove(t)} style={{ marginLeft: 6, opacity: .7 }}>×</button>
          </span>
        ))}
        {local.length === 0 && <div style={{ opacity: .7 }}>Пока пусто</div>}
      </div>
    </Modal>
  )
}

// ===== app/components/ChatSearch.tsx =====
import React, { useState, useMemo } from 'react'
import { useChat } from '../contexts/ChatContext'
import Input from '@shared/ui/Input'
import styles from './ChatSearch.module.css'

export default function ChatSearch() {
  const { state } = useChat()
  const [searchQuery, setSearchQuery] = useState('')
  
  const filteredChats = useMemo(() => {
    if (!searchQuery.trim()) return state.chatsOrder.map(id => state.chatsById[id])
    
    const query = searchQuery.toLowerCase()
    return state.chatsOrder.map(id => state.chatsById[id]).filter(chat => 
      chat.name?.toLowerCase().includes(query) ||
      (state.messagesByChat[chat.id]?.items || []).some(msg => 
        msg.content.toLowerCase().includes(query)
      )
    )
  }, [state.chatsOrder, state.chatsById, state.messagesByChat, searchQuery])

  return (
    <div className={styles.searchContainer}>
      <Input
        value={searchQuery}
        onChange={e => setSearchQuery(e.target.value)}
        placeholder="Поиск по чатам и сообщениям..."
        className={styles.searchInput}
      />
      {searchQuery && (
        <div className={styles.searchResults}>
          <div className={styles.resultsHeader}>
            Найдено чатов: {filteredChats.length}
          </div>
          {filteredChats.map(chat => {
            const messages = state.messagesByChat[chat.id]?.items || []
            return (
              <div key={chat.id} className={styles.chatResult}>
                <div className={styles.chatName}>{chat.name || 'Untitled'}</div>
                <div className={styles.chatPreview}>
                  {messages.length > 0 
                    ? messages[messages.length - 1].content.slice(0, 100) + '...'
                    : 'Нет сообщений'
                  }
                </div>
              </div>
            )
          })}
        </div>
      )}
    </div>
  )
}

// ===== app/components/ChatStats.tsx =====
import React from 'react'
import { useChat } from '../contexts/ChatContext'
import styles from './ChatStats.module.css'

export default function ChatStats() {
  const { state } = useChat()

  const stats = React.useMemo(() => {
    const chatList = state.chatsOrder.map(id => state.chatsById[id])
    const totalMessages = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.length
    }, 0)
    
    const userMessages = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.filter(msg => msg.role === 'user').length
    }, 0)
    
    const assistantMessages = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.filter(msg => msg.role === 'assistant').length
    }, 0)
    
    const totalWords = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.reduce((msgSum, msg) => 
        msgSum + msg.content.split(' ').length, 0
      )
    }, 0)

    const averageMessagesPerChat = chatList.length > 0 ? Math.round(totalMessages / chatList.length) : 0
    const averageWordsPerMessage = totalMessages > 0 ? Math.round(totalWords / totalMessages) : 0

    return {
      totalChats: chatList.length,
      totalMessages,
      userMessages,
      assistantMessages,
      totalWords,
      averageMessagesPerChat,
      averageWordsPerMessage
    }
  }, [state.chatsOrder, state.chatsById, state.messagesByChat])

  return (
    <div className={styles.statsContainer}>
      <h4 className={styles.statsTitle}>Статистика чатов</h4>
      
      <div className={styles.statsGrid}>
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.totalChats}</div>
          <div className={styles.statLabel}>Всего чатов</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.totalMessages}</div>
          <div className={styles.statLabel}>Всего сообщений</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.userMessages}</div>
          <div className={styles.statLabel}>Сообщений пользователя</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.assistantMessages}</div>
          <div className={styles.statLabel}>Ответов ассистента</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.totalWords.toLocaleString()}</div>
          <div className={styles.statLabel}>Всего слов</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.averageMessagesPerChat}</div>
          <div className={styles.statLabel}>Среднее сообщений на чат</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.averageWordsPerMessage}</div>
          <div className={styles.statLabel}>Среднее слов на сообщение</div>
        </div>
      </div>
    </div>
  )
}

// ===== app/components/OptimizedChatMessage.tsx =====
import React, { memo, useMemo } from 'react'
import { ChatMessage } from '../store/useChatStore'
import styles from './OptimizedChatMessage.module.css'

interface OptimizedChatMessageProps {
  message: ChatMessage
  index: number
}

const OptimizedChatMessage = memo<OptimizedChatMessageProps>(({ message, index }) => {
  const messageContent = useMemo(() => {
    return message.content
  }, [message.content])
  
  const messageTime = useMemo(() => {
    return message.created_at ? new Date(message.created_at).toLocaleTimeString() : null
  }, [message.created_at])
  
  const messageClass = useMemo(() => {
    return message.role === 'user' ? styles.user : styles.assistant
  }, [message.role])
  
  return (
    <div className={messageClass}>
      <div className={styles.messageContent}>{messageContent}</div>
      {messageTime && (
        <div className={styles.messageTime}>
          {messageTime}
        </div>
      )}
    </div>
  )
})

OptimizedChatMessage.displayName = 'OptimizedChatMessage'

export default OptimizedChatMessage

// ===== app/components/ChatExport.tsx =====
import React, { useState } from 'react'
import { useChat } from '../contexts/ChatContext'
import Button from '@shared/ui/Button'
import Modal from '@shared/ui/Modal'
import styles from './ChatExport.module.css'

export default function ChatExport() {
  const { state } = useChat()
  const [isOpen, setIsOpen] = useState(false)
  const [exportFormat, setExportFormat] = useState<'json' | 'txt' | 'md'>('json')

  const exportChats = () => {
    const chats = state.chatsOrder.map(id => state.chatsById[id])
    
    if (exportFormat === 'json') {
      const data = chats.map(chat => ({
        id: chat.id,
        name: chat.name,
        created_at: chat.created_at,
        messages: (state.messagesByChat[chat.id]?.items || []).map(msg => ({
          role: msg.role,
          content: msg.content,
          created_at: msg.created_at
        }))
      }))
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `chats_export_${new Date().toISOString().split('T')[0]}.json`
      a.click()
      URL.revokeObjectURL(url)
    } else if (exportFormat === 'txt') {
      const content = chats.map(chat => {
        let text = `=== ${chat.name || 'Untitled'} ===\n`
        text += `Created: ${chat.created_at ? new Date(chat.created_at).toLocaleString() : 'Unknown'}\n\n`
        
        const messages = state.messagesByChat[chat.id]?.items || []
        messages.forEach(msg => {
          text += `${msg.role.toUpperCase()}: ${msg.content}\n\n`
        })
        
        return text
      }).join('\n' + '='.repeat(50) + '\n\n')
      
      const blob = new Blob([content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `chats_export_${new Date().toISOString().split('T')[0]}.txt`
      a.click()
      URL.revokeObjectURL(url)
    } else if (exportFormat === 'md') {
      const content = chats.map(chat => {
        let md = `# ${chat.name || 'Untitled'}\n\n`
        md += `**Created:** ${chat.created_at ? new Date(chat.created_at).toLocaleString() : 'Unknown'}\n\n`
        
        const messages = state.messagesByChat[chat.id]?.items || []
        messages.forEach(msg => {
          md += `## ${msg.role === 'user' ? '👤 User' : '🤖 Assistant'}\n\n`
          md += `${msg.content}\n\n`
        })
        
        return md
      }).join('\n---\n\n')
      
      const blob = new Blob([content], { type: 'text/markdown' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `chats_export_${new Date().toISOString().split('T')[0]}.md`
      a.click()
      URL.revokeObjectURL(url)
    }
    
    setIsOpen(false)
  }

  return (
    <>
      <Button 
        onClick={() => setIsOpen(true)}
        size="small"
        variant="ghost"
        title="Экспорт чатов"
      >
        📤
      </Button>

      <Modal 
        open={isOpen} 
        onClose={() => setIsOpen(false)} 
        title="Экспорт чатов"
        footer={
          <>
            <Button variant="ghost" onClick={() => setIsOpen(false)}>
              Отмена
            </Button>
            <Button onClick={exportChats}>
              Экспортировать
            </Button>
          </>
        }
      >
        <div className={styles.exportOptions}>
          <p>Выберите формат экспорта:</p>
          
          <div className={styles.formatOptions}>
            <label className={styles.formatOption}>
              <input
                type="radio"
                name="format"
                value="json"
                checked={exportFormat === 'json'}
                onChange={e => setExportFormat(e.target.value as 'json')}
              />
              <span>JSON (полные данные)</span>
            </label>
            
            <label className={styles.formatOption}>
              <input
                type="radio"
                name="format"
                value="txt"
                checked={exportFormat === 'txt'}
                onChange={e => setExportFormat(e.target.value as 'txt')}
              />
              <span>TXT (текстовый формат)</span>
            </label>
            
            <label className={styles.formatOption}>
              <input
                type="radio"
                name="format"
                value="md"
                checked={exportFormat === 'md'}
                onChange={e => setExportFormat(e.target.value as 'md')}
              />
              <span>Markdown (для документации)</span>
            </label>
          </div>
          
          <div className={styles.exportInfo}>
            <p>Будет экспортировано чатов: <strong>{state.chatsOrder.length}</strong></p>
            <p>Общее количество сообщений: <strong>
              {state.chatsOrder.reduce((sum, chatId) => sum + (state.messagesByChat[chatId]?.items.length || 0), 0)}
            </strong></p>
          </div>
        </div>
      </Modal>
    </>
  )
}

// ===== app/components/EmptyState.tsx =====
import React from 'react'

export default function EmptyState({ title, description, action }: { title: string, description?: string, action?: React.ReactNode }) {
  return (
    <div style={{ display: 'grid', placeItems: 'center', minHeight: 260, textAlign: 'center', gap: 8 }}>
      <div style={{ fontWeight: 600, fontSize: 18 }}>{title}</div>
      {description && <div style={{ opacity: .75 }}>{description}</div>}
      {action}
    </div>
  )
}

// ===== app/components/ErrorBoundary.tsx =====
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo)
    this.props.onError?.(error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }

      return (
        <div className="error-boundary">
          <div className="error-content">
            <h2>Что-то пошло не так</h2>
            <p>Произошла неожиданная ошибка. Пожалуйста, обновите страницу.</p>
            <details>
              <summary>Детали ошибки</summary>
              <pre>{this.state.error?.stack}</pre>
            </details>
            <button 
              onClick={() => window.location.reload()}
              className="retry-button"
            >
              Обновить страницу
            </button>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

// Hook version for functional components
export function useErrorHandler() {
  return (error: Error, errorInfo?: ErrorInfo) => {
    console.error('Error caught by useErrorHandler:', error, errorInfo)
    // You can add error reporting here
  }
}

// ===== app/routes/Login.tsx =====
import React, { useState } from 'react'
import { useAuth } from '@app/store/auth'
import { useNavigate } from 'react-router-dom'
import Button from '@shared/ui/Button'
import Input from '@shared/ui/Input'
import Card from '@shared/ui/Card'
import styles from './Login.module.css'

export default function Login() {
  const nav = useNavigate()
  const { login, loading } = useAuth()
  const [form, setForm] = useState({ login: '', password: '' })
  const [error, setError] = useState<string | null>(null)

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    setError(null)
    try {
      await login(form.login, form.password)
      nav('/gpt/chat')
    } catch (e: any) {
      setError(e.message || 'Ошибка входа')
    }
  }
  return (
    <div className={styles.wrap}>
      <Card className={styles.card}>
        <h1>Войти</h1>
        <form className="stack" onSubmit={onSubmit}>
          <label>Логин</label>
          <Input placeholder="user" value={form.login} onChange={e=>setForm(f=>({ ...f, login:e.target.value }))} />
          <label>Пароль</label>
          <Input type="password" placeholder="••••••••" value={form.password} onChange={e=>setForm(f=>({ ...f, password:e.target.value }))} />
          {error && <div className={styles.error}>{error}</div>}
          <Button type="submit" disabled={loading}>{loading ? '…' : 'Войти'}</Button>
        </form>
      </Card>
    </div>
  )
}

// ===== app/routes/GPTGate.tsx =====
import React, { useEffect, useState } from 'react'
import { useAuth } from '@app/store/auth'
import { useNavigate } from 'react-router-dom'

export default function GPTGate({ children }: { children: React.ReactNode }) {
  const { user, fetchMe } = useAuth()
  const [checked, setChecked] = useState(false)
  const nav = useNavigate()

  useEffect(() => {
    (async () => {
      try { await fetchMe() } finally { setChecked(true) }
    })()
  }, [])

  useEffect(() => {
    if (checked && !user) nav('/login')
  }, [checked, user])

  if (!checked) return null
  if (!user) return null
  return <>{children}</>
}

// ===== app/routes/NotFound.tsx =====
import React from 'react'
import { Link } from 'react-router-dom'
import Card from '@shared/ui/Card'

export default function NotFound() {
  return (
    <div style={{display:'grid', placeItems:'center', minHeight:'60vh', padding:24}}>
      <Card>
        <h2>Страница не найдена</h2>
        <p>Мы не нашли такую страницу. Перейти в <Link to="/gpt/chat">чат</Link> или <Link to="/login">войти</Link>.</p>
      </Card>
    </div>
  )
}

// ===== app/routes/gpt/Doc.tsx =====
import React from 'react'
import Card from '@shared/ui/Card'

export default function Doc() {
  return (
    <Card>
      <h2>RAG Documents</h2>
      <p>Здесь позже появится список / загрузка / поиск.</p>
    </Card>
  )
}

// ===== app/routes/gpt/Analyze.tsx =====
import React, { useState, useEffect } from 'react'
import Card from '@shared/ui/Card'
import Button from '@shared/ui/Button'
import FilePicker from '@shared/ui/FilePicker'
import * as analyze from '@shared/api/analyze'
import { AnalyzeDocument } from '@shared/api/types'
import styles from './AnalyzePage.module.css'

export default function Analyze() {
  const [documents, setDocuments] = useState<AnalyzeDocument[]>([])
  const [loading, setLoading] = useState(false)
  const [uploading, setUploading] = useState(false)

  useEffect(() => {
    loadDocuments()
  }, [])

  const loadDocuments = async () => {
    setLoading(true)
    try {
      const res = await analyze.listAnalyze()
      setDocuments(res.items || [])
    } catch (error) {
      console.error('Failed to load documents:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleFileUpload = async (file: File) => {
    setUploading(true)
    try {
      await analyze.uploadAnalysisFile(file)
      await loadDocuments()
    } catch (error) {
      console.error('Failed to upload file:', error)
      alert('Ошибка загрузки файла')
    } finally {
      setUploading(false)
    }
  }

  const handleDownload = async (doc: AnalyzeDocument, kind: 'original' | 'canonical' = 'original') => {
    try {
      const res = await analyze.downloadAnalysisFile(doc.id, kind)
      if (res.url) {
        window.open(res.url, '_blank')
      }
    } catch (error) {
      console.error('Download failed:', error)
    }
  }

  const handleDelete = async (doc: AnalyzeDocument) => {
    if (!confirm('Удалить документ?')) return
    try {
      await analyze.deleteAnalysisFile(doc.id)
      await loadDocuments()
    } catch (error) {
      console.error('Delete failed:', error)
      alert('Ошибка удаления документа')
    }
  }

  const handleReanalyze = async (doc: AnalyzeDocument) => {
    if (!confirm('Повторно проанализировать документ?')) return
    try {
      await analyze.reanalyzeFile(doc.id)
      await loadDocuments()
    } catch (error) {
      console.error('Reanalyze failed:', error)
      alert('Ошибка повторного анализа')
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'done': return '#4caf50'
      case 'processing': return '#ff9800'
      case 'error': return '#f44336'
      case 'canceled': return '#9e9e9e'
      default: return '#2196f3'
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'queued': return 'В очереди'
      case 'processing': return 'Обработка'
      case 'done': return 'Готов'
      case 'error': return 'Ошибка'
      case 'canceled': return 'Отменен'
      default: return status
    }
  }

  return (
    <div className={styles.container}>
      <Card className={styles.uploadCard}>
        <h3>Загрузка файла для анализа</h3>
        <FilePicker
          onFileSelected={(file) => file && handleFileUpload(file)}
          accept=".txt,.pdf,.doc,.docx,.md,.rtf,.odt"
          disabled={uploading}
        />
        {uploading && <p>Загрузка...</p>}
      </Card>

      <Card className={styles.documentsCard}>
        <h3>Документы на анализе ({documents.length})</h3>
        {loading ? (
          <p>Загрузка...</p>
        ) : documents.length === 0 ? (
          <p>Нет документов</p>
        ) : (
          <div className={styles.documentsList}>
            {documents.map(doc => (
              <div key={doc.id} className={styles.documentItem}>
                <div className={styles.documentInfo}>
                  <div className={styles.documentName}>
                    Документ {doc.id.slice(0, 8)}
                  </div>
                  <div className={styles.documentStatus}>
                    <span 
                      className={styles.statusBadge}
                      style={{ backgroundColor: getStatusColor(doc.status) }}
                    >
                      {getStatusText(doc.status)}
                    </span>
                    {doc.error && (
                      <span className={styles.errorText}>
                        {doc.error}
                      </span>
                    )}
                  </div>
                  <div className={styles.documentDate}>
                    {doc.date_upload && new Date(doc.date_upload).toLocaleString()}
                  </div>
                  {doc.result && (
                    <div className={styles.resultPreview}>
                      <strong>Результат:</strong>
                      <pre>{JSON.stringify(doc.result, null, 2)}</pre>
                    </div>
                  )}
                </div>
                <div className={styles.documentActions}>
                  {doc.status === 'done' && (
                    <>
                      <Button 
                        size="small" 
                        onClick={() => handleDownload(doc, 'original')}
                      >
                        Скачать оригинал
                      </Button>
                      {doc.url_canonical_file && (
                        <Button 
                          size="small" 
                          onClick={() => handleDownload(doc, 'canonical')}
                        >
                          Скачать каноническую форму
                        </Button>
                      )}
                      <Button 
                        size="small" 
                        onClick={() => handleReanalyze(doc)}
                        title="Повторно проанализировать"
                      >
                        🔄
                      </Button>
                    </>
                  )}
                  <Button 
                    size="small" 
                    variant="danger"
                    onClick={() => handleDelete(doc)}
                  >
                    Удалить
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}
      </Card>
    </div>
  )
}

// ===== app/routes/gpt/Rag.tsx =====
import React, { useEffect, useMemo, useState } from 'react'
import Card from '@shared/ui/Card'
import Input from '@shared/ui/Input'
import Button from '@shared/ui/Button'
import Badge from '@shared/ui/Badge'
import Modal from '@shared/ui/Modal'
import Popover from '@shared/ui/Popover'
import { FilterIcon, MoreVerticalIcon, DownloadIcon, RefreshIcon, ArchiveIcon, TrashIcon } from '@shared/ui/Icon'
import Select from '@shared/ui/Select'
import FilePicker from '@shared/ui/FilePicker'
import * as rag from '@shared/api/rag'
import { RagDocument } from '@shared/api/types'
import styles from './Rag.module.css'

type ColKey = 'name' | 'status' | 'created_at' | 'tags'

export default function Rag() {
  const [items, setItems] = useState<RagDocument[]>([])
  const [busy, setBusy] = useState(false)
  const [q, setQ] = useState('')
  const [filters, setFilters] = useState<Partial<Record<ColKey, string>>>({})
  const [pop, setPop] = useState<{ open: boolean, col?: ColKey, anchor?: {x:number,y:number} }>({ open: false })
  const [openAdd, setOpenAdd] = useState(false)
  const [file, setFile] = useState<File | null>(null)
  const [uploadTags, setUploadTags] = useState<string[]>([])
  const [selectedDoc, setSelectedDoc] = useState<RagDocument | null>(null)
  const [actionMenuOpen, setActionMenuOpen] = useState(false)

  async function refresh() {
    const res = await rag.listDocs({ page: 1, size: 100 })
    setItems(res.items || [])
  }

  useEffect(() => {
    refresh()
  }, [])

  const rows = useMemo(() => {
    return (items||[]).filter(t => {
      const text = ((t.name||'') + ' ' + (t.status||'') + ' ' + (t.created_at||'') + ' ' + (t.tags?.join(' ')||'')).toLowerCase()
      if (q.trim() && !text.includes(q.toLowerCase())) return false
      if (filters.name && !(t.name||'').toLowerCase().includes((filters.name||'').toLowerCase())) return false
      if (filters.status && t.status !== filters.status) return false
      if (filters.tags && !(t.tags?.join(' ')||'').toLowerCase().includes((filters.tags||'').toLowerCase())) return false
      if (filters.created_at && !(t.created_at||'').toLowerCase().includes((filters.created_at||'').toLowerCase())) return false
      return true
    })
  }, [items, q, filters])

  function openFilter(col: ColKey, el: HTMLElement) {
    const r = el.getBoundingClientRect()
    setPop({ open: true, col, anchor: { x: r.left, y: r.bottom + 6 } })
  }
  function clearAll() { setFilters({}); setPop({ open:false }) }

  async function doUpload() {
    if (!file) return
    setBusy(true)
    try {
      await rag.uploadFile(file, file.name, uploadTags)
      setOpenAdd(false)
      setFile(null)
      setUploadTags([])
      await refresh()
    } finally { setBusy(false) }
  }

  const handleDownload = async (doc: RagDocument, kind: 'original' | 'canonical' = 'original') => {
    try {
      const res = await rag.downloadRagFile(doc.id, kind)
      if (res.url) {
        window.open(res.url, '_blank')
      }
    } catch (error) {
      console.error('Download failed:', error)
    }
  }

  const handleArchive = async (doc: RagDocument) => {
    try {
      await rag.archiveRagDocument(doc.id)
      await refresh()
    } catch (error) {
      console.error('Archive failed:', error)
    }
  }

  const handleDelete = async (doc: RagDocument) => {
    if (!confirm('Удалить документ?')) return
    try {
      await rag.deleteRagDocument(doc.id)
      await refresh()
    } catch (error) {
      console.error('Delete failed:', error)
    }
  }

  const handleReindex = async (doc: RagDocument) => {
    if (!confirm('Переиндексировать документ?')) return
    try {
      await rag.reindexRagDocument(doc.id)
      await refresh()
    } catch (error) {
      console.error('Reindex failed:', error)
      alert('Ошибка переиндексации')
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'queued': return 'В очереди'
      case 'processing': return 'Обработка'
      case 'ready': return 'Готов'
      case 'error': return 'Ошибка'
      case 'archived': return 'Архив'
      default: return status
    }
  }

  const hasAnyFilter = Object.values(filters).some(Boolean)

  return (
    <div className={styles.wrap}>
      <Card className={styles.card}>
        <div className={styles.header}>
          <div className={styles.title}>База знаний — документы</div>
          <div className={styles.controls}>
            <Input className={styles.search} placeholder="Поиск…" value={q} onChange={e=>setQ(e.target.value)} />
            {hasAnyFilter && <Badge onClick={clearAll}>Сбросить фильтры</Badge>}
            <Button onClick={()=>setOpenAdd(true)}>Добавить</Button>
          </div>
        </div>

        <div className={styles.tableWrap}>
          <table className="table">
            <thead>
              <tr>
                <th>Название <button className="icon" type="button" aria-label="Фильтр по названию" onClick={(e)=>openFilter('name', e.currentTarget)}><FilterIcon/></button></th>
                <th>Статус <button className="icon" type="button" aria-label="Фильтр по статусу" onClick={(e)=>openFilter('status', e.currentTarget)}><FilterIcon/></button></th>
                <th>Теги <button className="icon" type="button" aria-label="Фильтр по тегам" onClick={(e)=>openFilter('tags', e.currentTarget)}><FilterIcon/></button></th>
                <th>Создано <button className="icon" type="button" aria-label="Фильтр по дате создания" onClick={(e)=>openFilter('created_at', e.currentTarget)}><FilterIcon/></button></th>
                <th>Действия</th>
              </tr>
            </thead>
            <tbody>
              {rows.map((t) => (
                <tr key={t.id}>
                  <td className="muted">{t.name || '—'}</td>
                  <td><Badge tone={t.status==='ready'?'success':t.status==='error'?'danger':t.status==='processing'?'warn':'neutral'}>{getStatusText(t.status)}</Badge></td>
                  <td>{t.tags?.join(', ') || '—'}</td>
                  <td className="muted">{t.created_at || '—'}</td>
                  <td>
                    <Popover
                      trigger={
                        <button 
                          className="icon" 
                          type="button" 
                          aria-label="Действия"
                          onClick={() => {
                            setSelectedDoc(t)
                            setActionMenuOpen(true)
                          }}
                        >
                          <MoreVerticalIcon/>
                        </button>
                      }
                      content={
                        <div className="stack" style={{minWidth: 180}}>
                          {t.status === 'ready' && (
                            <>
                              <Button size="sm" variant="ghost" onClick={() => handleDownload(t, 'original')}>
                                <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                  <DownloadIcon size={12}/>
                                </span>
                                Скачать документ
                              </Button>
                              {t.url_canonical_file && (
                                <Button size="sm" variant="ghost" onClick={() => handleDownload(t, 'canonical')}>
                                  <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                    <DownloadIcon size={12}/>
                                  </span>
                                  Скачать канонический вид
                                </Button>
                              )}
                              <Button size="sm" variant="ghost" onClick={() => handleReindex(t)}>
                                <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                  <RefreshIcon size={12}/>
                                </span>
                                Пересчитать
                              </Button>
                              <Button size="sm" variant="ghost" onClick={() => handleArchive(t)}>
                                <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                  <ArchiveIcon size={12}/>
                                </span>
                                Заархивировать
                              </Button>
                            </>
                          )}
                          <Button size="sm" variant="ghost" onClick={() => handleDelete(t)}>
                            <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                              <TrashIcon size={12}/>
                            </span>
                            Удалить
                          </Button>
                        </div>
                      }
                      align="end"
                    />
                  </td>
                </tr>
              ))}
              {rows.length === 0 && <tr><td colSpan={5} className="muted">Нет записей</td></tr>}
            </tbody>
          </table>
        </div>
      </Card>

      <Modal open={openAdd} onClose={()=>setOpenAdd(false)} title="Новый документ"
        footer={<><Button variant="ghost" onClick={()=>setOpenAdd(false)}>Отмена</Button><Button onClick={doUpload} disabled={busy || !file}>Загрузить</Button></>}>
        <div className="stack">
          <FilePicker onFileSelected={setFile} accept=".txt,.pdf,.doc,.docx,.md,.rtf,.odt" />
          <div>
            <label>Теги (опционально):</label>
            <Input 
              placeholder="Введите теги через запятую..." 
              value={uploadTags.join(', ')} 
              onChange={e => setUploadTags(e.target.value.split(',').map(t => t.trim()).filter(Boolean))} 
            />
          </div>
        </div>
      </Modal>

      <Popover 
        trigger={<div />}
        content={
          <div className="stack" style={{minWidth: 260}}>
          {pop.col === 'status' ? (
            <Select
              value={filters.status || ''}
              onChange={e=>setFilters(f=>({ ...f, status: (e.target as HTMLSelectElement).value || undefined }))}
            >
              <option value="">Любой</option>
              <option value="queued">В очереди</option>
              <option value="processing">Обработка</option>
              <option value="ready">Готов</option>
              <option value="error">Ошибка</option>
              <option value="archived">Архив</option>
            </Select>
          ) : (
            <Input placeholder="Фильтр…" value={(filters[pop.col as ColKey] || '') as string} onChange={e=>{
              const val = e.target.value
              const col = pop.col as ColKey
              setFilters(f=>({ ...f, [col]: (val || '').trim() || undefined }))
            }} />
          )}
          <div style={{display:'flex', gap:8, justifyContent:'space-between'}}>
            <Button size="sm" variant="ghost" onClick={()=>{ const col = pop.col as ColKey; setFilters(f=>({ ...f, [col]: undefined })); }}>Очистить</Button>
            <Button size="sm" onClick={()=>setPop({open:false})}>Применить</Button>
          </div>
          </div>
        }
        align="end"
      />
    </div>
  )
}

// ===== app/routes/gpt/GPTLayout.tsx =====
import React from 'react'
import { Outlet, NavLink, useNavigate } from 'react-router-dom'
import Button from '@shared/ui/Button'
import styles from './GPTLayout.module.css'
import { useAuth } from '@app/store/auth'
import ThemeSwitch from '@shared/ui/ThemeSwitch'

const USE_MOCKS = import.meta.env.VITE_USE_MOCKS === 'true'

export default function GPTLayout() {
  const nav = useNavigate()
  const { logout, user } = useAuth()
  const isAdmin = (user?.role || '').toLowerCase() === 'admin'

  // Logo is served from /public/logo.png to avoid bundler import issues.
  const logoSrc = '/logo.png'

  return (
    <div className={styles.shell}>
      <header className={styles.header}>
        {/* Left: logo + brand */}
        <div className={styles.brand}>
          <img
            src={logoSrc}
            alt="Почемучка logo"
            onError={(e)=>{ const el=e.currentTarget as HTMLImageElement; el.style.display='none' }}
          />
          <div className={styles.brandName}>Почемучка</div>
        </div>

        {/* Center: segmented nav (50% header width) */}
        <nav className={styles.nav}>
          <div className={styles.segWrap}>
            <div className={styles.seg}>
              <NavLink to="/gpt/chat" className={({isActive}) => [styles.segBtn, isActive ? styles.active : ''].join(' ')}>Чат</NavLink>
              <NavLink to="/gpt/analyze" className={({isActive}) => [styles.segBtn, isActive ? styles.active : ''].join(' ')}>Аналитика</NavLink>
              {isAdmin && (
                <NavLink to="/gpt/rag" className={({isActive}) => [styles.segBtn, isActive ? styles.active : ''].join(' ')}>База знаний</NavLink>
              )}
            </div>
          </div>
        </nav>

        {/* Right: mocks -> role -> theme -> logout */}
        <div className={styles.right}>
          {USE_MOCKS && <span className={styles.mocks}>Mocks ON</span>}
          <span className={styles.user}>{user?.role || ''}</span>
          <ThemeSwitch />
          <Button variant="ghost" onClick={async () => { await logout(); nav('/login') }}>Выйти</Button>
        </div>
      </header>

      <main className={styles.main}>
        <Outlet />
      </main>

      <footer className={styles.footer}>{/* пустой подвал, заполним позже */}</footer>
    </div>
  )
}

// ===== app/routes/gpt/AnalyzePage.tsx =====
import React, { useEffect, useMemo, useState } from 'react'
import Card from '@shared/ui/Card'
import Input from '@shared/ui/Input'
import Button from '@shared/ui/Button'
import Badge from '@shared/ui/Badge'
import Modal from '@shared/ui/Modal'
import Popover from '@shared/ui/Popover'
import { FilterIcon } from '@shared/ui/Icon'
import Select from '@shared/ui/Select'
import FilePicker from '@shared/ui/FilePicker'
import * as analyze from '@shared/api/analyze'
import styles from './AnalyzePage.module.css'

type Task = { id: string; source?: string; status: string; result?: string; created_at?: string }
type ColKey = keyof Pick<Task, 'source'|'status'|'result'|'created_at'>

export default function AnalyzePage() {
  const [items, setItems] = useState<Task[]>([])
  const [busy, setBusy] = useState(false)

  const [q, setQ] = useState('')
  const [filters, setFilters] = useState<Partial<Record<ColKey, string>>>({})
  const [pop, setPop] = useState<{ open: boolean, col?: ColKey, anchor?: {x:number,y:number} }>({ open: false })

  const [openAdd, setOpenAdd] = useState(false)
  const [file, setFile] = useState<File | null>(null)

  async function refresh() {
    const res = await analyze.listAnalyze()
    setItems(res.items || [])
  }

  // Мягкий пуллинг (экспоненциальный backoff)
  useEffect(() => {
    let cancelled = false
    let delay = 1500
    const tick = async () => {
      while (!cancelled) {
        try { await refresh() } catch {}
        await new Promise(r => setTimeout(r, delay))
        delay = Math.min(delay * 2, 10000)
      }
    }
    tick()
    return () => { cancelled = true }
  }, [])

  const rows = useMemo(() => {
    return (items||[]).filter(t => {
      const text = ((t.source||'') + ' ' + (t.result||'') + ' ' + (t.created_at||'') + ' ' + t.status).toLowerCase()
      if (q.trim() && !text.includes(q.toLowerCase())) return false
      if (filters.source && !(t.source||'').toLowerCase().includes((filters.source||'').toLowerCase())) return false
      if (filters.status && t.status !== filters.status) return false
      if (filters.result && !(t.result||'').toLowerCase().includes((filters.result||'').toLowerCase())) return false
      if (filters.created_at && !(t.created_at||'').toLowerCase().includes((filters.created_at||'').toLowerCase())) return false
      return true
    })
  }, [items, q, filters])

  function openFilter(col: ColKey, el: HTMLElement) {
    const r = el.getBoundingClientRect()
    setPop({ open: true, col, anchor: { x: r.left, y: r.bottom + 6 } })
  }
  function clearAll() { setFilters({}); setPop({ open:false }) }

  async function doUpload() {
    if (!file) return
    setBusy(true)
    try {
      await analyze.uploadAnalysisFile(file)
      setOpenAdd(false)
      setFile(null)
      await refresh()
    } finally { setBusy(false) }
  }

  const hasAnyFilter = Object.values(filters).some(Boolean)

  return (
    <div className={styles.wrap}>
      <Card className={styles.card}>
        <div className={styles.header}>
          <div className={styles.title}>Анализ документов — задачи</div>
          <div className={styles.controls}>
            <Input className={styles.search} placeholder="Поиск…" value={q} onChange={e=>setQ(e.target.value)} />
            {hasAnyFilter && <Badge onClick={clearAll}>Сбросить фильтры</Badge>}
            <Button onClick={()=>setOpenAdd(true)}>Добавить</Button>
          </div>
        </div>

        <div className={styles.tableWrap}>
          <table className="table">
            <thead>
              <tr>
                <th>Источник <button className="icon" type="button" aria-label="Фильтр по источнику" onClick={(e)=>openFilter('source', e.currentTarget)}><FilterIcon/></button></th>
                <th>Статус <button className="icon" type="button" aria-label="Фильтр по статусу" onClick={(e)=>openFilter('status', e.currentTarget)}><FilterIcon/></button></th>
                <th>Результат <button className="icon" type="button" aria-label="Фильтр по результату" onClick={(e)=>openFilter('result', e.currentTarget)}><FilterIcon/></button></th>
                <th>Создано <button className="icon" type="button" aria-label="Фильтр по дате создания" onClick={(e)=>openFilter('created_at', e.currentTarget)}><FilterIcon/></button></th>
              </tr>
            </thead>
            <tbody>
              {rows.map((t) => (
                <tr key={t.id}>
                  <td className="muted">{t.source || '—'}</td>
                  <td><Badge tone={t.status==='done'?'success':t.status==='error'?'danger':t.status==='processing'?'warn':'neutral'}>{t.status}</Badge></td>
                  <td style={{maxWidth:480, whiteSpace:'nowrap', textOverflow:'ellipsis', overflow:'hidden'}}>{t.result || '—'}</td>
                  <td className="muted">{t.created_at || '—'}</td>
                </tr>
              ))}
              {rows.length === 0 && <tr><td colSpan={4} className="muted">Нет записей</td></tr>}
            </tbody>
          </table>
        </div>
      </Card>

      <Modal open={openAdd} onClose={()=>setOpenAdd(false)} title="Новый анализ"
        footer={<><Button variant="ghost" onClick={()=>setOpenAdd(false)}>Отмена</Button><Button onClick={doUpload} disabled={busy || !file}>Запустить</Button></>}>
        <FilePicker onFileSelected={setFile} />
      </Modal>

      <Popover 
        trigger={<div />}
        content={
          <div className="stack" style={{minWidth: 260}}>
          {pop.col === 'status' ? (
            <Select
              value={filters.status || ''}
              onChange={e=>setFilters(f=>({ ...f, status: (e.target as HTMLSelectElement).value || undefined }))}
            >
              <option value="">Любой</option>
              <option value="queued">queued</option>
              <option value="processing">processing</option>
              <option value="done">done</option>
              <option value="error">error</option>
            </Select>
          ) : (
            <Input placeholder="Фильтр…" value={(filters[pop.col as ColKey] || '') as string} onChange={e=>{
              const val = e.target.value
              const col = pop.col as ColKey
              setFilters(f=>({ ...f, [col]: (val || '').trim() || undefined }))
            }} />
          )}
          <div style={{display:'flex', gap:8, justifyContent:'space-between'}}>
            <Button size="sm" variant="ghost" onClick={()=>{ const col = pop.col as ColKey; setFilters(f=>({ ...f, [col]: undefined })); }}>Очистить</Button>
            <Button size="sm" onClick={()=>setPop({open:false})}>Применить</Button>
          </div>
          </div>
        }
        align="end"
      />
    </div>
  )
}

// ===== app/routes/gpt/Chat.tsx =====
import React, { useEffect, useMemo, useRef, useState } from 'react'
import styles from './Chat.module.css'
import Card from '@shared/ui/Card'
import Button from '@shared/ui/Button'
import Textarea from '@shared/ui/Textarea'
import { useNavigate, useParams } from 'react-router-dom'
import { useChat } from '../../contexts/ChatContext'
import EmptyState from '../../components/EmptyState'

export default function Chat() {
  const { chatId } = useParams()
  const nav = useNavigate()
  const { state, loadMessages, setCurrentChat, sendMessageStream } = useChat()

  const [text, setText] = useState('')
  const [busy, setBusy] = useState(false)
  const [useRag, setUseRag] = useState(false)
  const [streamText, setStreamText] = useState('')

  const current = useMemo(() => chatId ? state.messagesByChat[chatId] : undefined, [chatId, state.messagesByChat])
  const messages = current?.items || []

  useEffect(() => {
    if (!chatId) return
    setCurrentChat(chatId)
    // load once
    if (!state.messagesByChat[chatId]?.loaded) {
      loadMessages(chatId).catch(console.error)
    }
    // cleanup stream text on chat switch
    setStreamText('')
  }, [chatId])

  if (!chatId) {
    return (
      <div className={styles.main}>
        <EmptyState
          title="Выберите чат"
          description="Слева — список ваших чатов. Создайте новый или откройте существующий."
          action={<Button onClick={() => nav('/gpt/chat')}>Обновить</Button>}
        />
      </div>
    )
  }

  async function onSend() {
    if (!text.trim()) return
    setBusy(true)
    setStreamText('')
    const toSend = text
    setText('')
    try {
      await sendMessageStream(chatId, toSend, (delta) => setStreamText(delta), useRag)
    } catch (e) {
      console.error(e)
    } finally {
      setBusy(false)
      setStreamText('')
    }
  }

  const canSend = !!chatId && !!text.trim() && !busy

  return (
    <div className={styles.main}>
      <Card className={styles.card}>
        <div className={styles.history}>
          {messages.map(m => (
            <div key={m.id} className={m.role === 'user' ? styles.userMsg : styles.assistantMsg}>
              <div className={styles.body}>{m.content}</div>
            </div>
          ))}
          {streamText && (
            <div className={styles.assistantMsg}>
              <div className={styles.body}>{streamText}</div>
            </div>
          )}
          {messages.length === 0 && !state.isLoading && (
            <div style={{ opacity: .7 }}>Сообщений пока нет.</div>
          )}
        </div>

        <div className={styles.composer}>
          <Textarea
            placeholder="Ваше сообщение…"
            value={text}
            onChange={e => setText(e.target.value)}
            disabled={!chatId || busy}
            rows={3}
          />
          <div className={styles.controls}>
            <div />
            <div className={styles.actionsBottom}>
              <Button onClick={onSend} disabled={!canSend}>Отправить</Button>
              <label className={styles.ragToggle} title="Использовать базу знаний (RAG) при ответе">
                <input type="checkbox" checked={useRag} onChange={e => setUseRag(e.target.checked)} />
                RAG из БЗ
              </label>
            </div>
          </div>
        </div>
      </Card>
    </div>
  )
}

// ===== app/routes/gpt/ChatSidebar.tsx =====
import React, { useMemo, useState } from 'react'
import styles from './ChatSidebar.module.css'
import Button from '@shared/ui/Button'
import { useNavigate, useParams } from 'react-router-dom'
import Modal from '@shared/ui/Modal'
import Input from '@shared/ui/Input'
import Popover from '@shared/ui/Popover'
import { useChat } from '../../contexts/ChatContext'
import ChatTags from '../../components/ChatTags'

function hueFromString(s: string){
  let h = 0
  for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) >>> 0
  return h % 360
}

function KebabIcon() {
  return <svg width="16" height="16" viewBox="0 0 24 24"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>
}

export default function ChatSidebar() {
  const { chatId } = useParams()
  const nav = useNavigate()
  const { state, createChat, renameChat, deleteChat, updateChatTags, removeChatLocal, restoreChatLocal, deleteChatApiOnly } = useChat()

  const [renameTarget, setRenameTarget] = useState<{ id: string, name: string } | null>(null)
  const [deleteTarget, setDeleteTarget] = useState<{ id: string, name?: string } | null>(null)
  const [pendingUndo, setPendingUndo] = useState<{ id: string, name?: string|null, tags?: string[]|null, secs: number, tid: any, iid: any } | null>(null)
  const [editTagsTarget, setEditTagsTarget] = useState<{ id: string, tags: string[] } | null>(null)

  const chats = useMemo(() => state.chatsOrder.map(id => state.chatsById[id]), [state.chatsOrder, state.chatsById])

  async function onCreate() {
    const id = await createChat('Новый чат')
    nav(`/gpt/chat/${id}`)
  }

  return (
    <aside className={styles.sidebar}>
      <div className={styles.head}>
        <div className={styles.title}>Чаты</div>
        <Button size="sm" onClick={onCreate}>+ Новый</Button>
      </div>

      <div className={styles.list}>
        {chats.length === 0 && <div className={styles.item} style={{ opacity: .7 }}>Нет чатов</div>}
        {chats.map(chat => (
          <div key={chat.id} className={[styles.row, chatId === chat.id ? styles.active : ''].join(' ')}>
            <button className={styles.item} onClick={() => nav(`/gpt/chat/${chat.id}`)}>
              <div className={styles.name}>{chat.name || 'Без названия'}</div>
              {Array.isArray(chat.tags) && chat.tags.length > 0 && (
                <div className={styles.tags}>
                  {chat.tags.map(tag => {
                  const h = hueFromString(tag)
                  const bg = `hsla(${h}, 70%, 45%, .18)`
                  const bd = `hsla(${h}, 70%, 50%, .45)`
                  const fg = `hsla(${h}, 80%, 80%, .95)`
                  return <span key={tag} className={styles.tag} style={{ background: bg, borderColor: bd, color: fg }}>{tag}</span>
                  })}
                </div>
              )}
            </button>
            <Popover
              trigger={<button className={styles.kebabBtn} aria-label="Меню"><KebabIcon/></button>}
              content={<div className={styles.menu}>
                <button className={styles.item} onClick={() => setRenameTarget({ id: chat.id, name: chat.name || '' })}>Переименовать</button>
                <button className={styles.item} onClick={() => setEditTagsTarget({ id: chat.id, tags: chat.tags || [] })}>Теги…</button>
                <button className={styles.item} onClick={() => setDeleteTarget({ id: chat.id, name: chat.name || '' })}>Удалить</button>
              </div>}
              align="end"
            />
          </div>
        ))}
      </div>

      <Modal open={!!renameTarget} onClose={() => setRenameTarget(null)} title="Переименовать чат"
        footer={<>
          <Button variant="ghost" onClick={() => setRenameTarget(null)}>Отмена</Button>
          <Button onClick={async () => {
            if (!renameTarget) return
            await renameChat(renameTarget.id, renameTarget.name || 'Без названия')
            setRenameTarget(null)
          }}>Сохранить</Button>
        </>}
      >
        <Input value={renameTarget?.name || ''} onChange={e => setRenameTarget(v => v ? { ...v, name: e.target.value } : v)} className="w-100" />
      </Modal>

      <Modal open={!!deleteTarget} onClose={() => setDeleteTarget(null)} title="Удалить чат"
        footer={<>
          <Button variant="ghost" onClick={() => setDeleteTarget(null)}>Отмена</Button>
          <Button variant="danger" onClick={async () => {
            if (!deleteTarget) return
            const chat = state.chatsById[deleteTarget.id]
            // Optimistic remove from state
            // We will call API after countdown unless undone
            const secsTotal = 5
            let secs = secsTotal
            // remove locally
            removeChatLocal(deleteTarget.id)
            if (chatId === deleteTarget.id) nav('/gpt/chat')
            setDeleteTarget(null)

            const tid = setTimeout(async () => {
              try { await deleteChatApiOnly(chat.id) } catch(e){ console.error(e) }
              setPendingUndo(null)
            }, secsTotal*1000)
            const iid = setInterval(() => {
              secs -= 1
              setPendingUndo(v => v ? { ...v, secs } : v)
            }, 1000)
            setPendingUndo({ id: chat.id, name: chat?.name || 'Без названия', tags: chat?.tags || [], secs, tid, iid })
          }}>Удалить</Button>
        </>}
      >
        Вы уверены, что хотите удалить чат «{deleteTarget?.name || 'Без названия'}»?
      </Modal>

      {editTagsTarget && (
        <ChatTags
          chatId={editTagsTarget.id}
          tags={editTagsTarget.tags}
          onTagsChange={async (tags) => {
            await updateChatTags(editTagsTarget.id, tags)
            setEditTagsTarget(null)
          }}
        />
      )}
    {pendingUndo && (
        <div className={styles.undoBar} role="status">
          <div className={styles.undoText}>Чат «{pendingUndo.name}» удалён. Отменить можно в течение {pendingUndo.secs} с.</div>
          <button className={styles.undoBtn} onClick={() => {
            clearTimeout(pendingUndo.tid)
            clearInterval(pendingUndo.iid)
            // restore in local state
            restoreChatLocal({ id: pendingUndo.id, name: pendingUndo.name || null, tags: pendingUndo.tags || [] } as any)
            setPendingUndo(null)
          }}>Отменить</button>
        </div>
      )}
    </aside>
  )
}

// ===== app/routes/gpt/ChatPage.tsx =====
import React from 'react'
import styles from './ChatPage.module.css'
import ChatSidebar from './ChatSidebar'
import Chat from './Chat'
import { ChatProvider } from '../../contexts/ChatContext'
import ChatStatus from '../../components/ChatStatus'

export default function ChatPage() {
  return (
    <ChatProvider>
      <div className={styles.shell}>
        <ChatSidebar />
        <div className={styles.main}>
          <Chat />
        </div>
        <ChatStatus />
      </div>
    </ChatProvider>
  )
}

// ===== app/routes/admin/CreateUserPage.tsx =====
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { adminApi, type UserCreate } from '../../../shared/api/admin';
import { Button } from '../../../shared/ui/Button';
import { Input } from '../../../shared/ui/Input';
import { Select } from '../../../shared/ui/Select';
import { useErrorToast, useSuccessToast } from '../../../shared/ui/Toast';
import styles from './CreateUserPage.module.css';

interface FormData {
  login: string;
  email: string;
  role: 'admin' | 'editor' | 'reader';
  is_active: boolean;
  password: string;
  send_email: boolean;
  require_password_change: boolean;
}

interface FormErrors {
  login?: string;
  email?: string;
  password?: string;
  general?: string;
}

export function CreateUserPage() {
  const navigate = useNavigate();
  const showError = useErrorToast();
  const showSuccess = useSuccessToast();

  // State
  const [formData, setFormData] = useState<FormData>({
    login: '',
    email: '',
    role: 'reader',
    is_active: true,
    password: '',
    send_email: true,
    require_password_change: true,
  });

  const [errors, setErrors] = useState<FormErrors>({});
  const [loading, setLoading] = useState(false);
  const [emailEnabled, setEmailEnabled] = useState(false);

  // Load system status to check if email is enabled
  useEffect(() => {
    const loadSystemStatus = async () => {
      try {
        const status = await adminApi.getSystemStatus();
        setEmailEnabled(status.email_enabled);
        if (!status.email_enabled) {
          setFormData(prev => ({ ...prev, send_email: false }));
        }
      } catch (error) {
        console.error('Failed to load system status:', error);
      }
    };

    loadSystemStatus();
  }, []);

  // Password validation
  const validatePassword = (password: string) => {
    const rules = [
      { test: password.length >= 8, message: 'At least 8 characters' },
      { test: /[A-Z]/.test(password), message: 'One uppercase letter' },
      { test: /[a-z]/.test(password), message: 'One lowercase letter' },
      { test: /\d/.test(password), message: 'One number' },
      { test: /[!@#$%^&*(),.?":{}|<>]/.test(password), message: 'One special character' },
    ];

    return rules.map(rule => ({
      ...rule,
      valid: rule.test,
    }));
  };

  // Form validation
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};

    // Login validation
    if (!formData.login.trim()) {
      newErrors.login = 'Login is required';
    } else if (formData.login.length < 3) {
      newErrors.login = 'Login must be at least 3 characters';
    } else if (!/^[a-zA-Z0-9_-]+$/.test(formData.login)) {
      newErrors.login = 'Login can only contain letters, numbers, hyphens, and underscores';
    }

    // Email validation
    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = 'Please enter a valid email address';
    }

    // Password validation
    if (!formData.send_email) {
      if (!formData.password) {
        newErrors.password = 'Password is required when not sending email';
      } else {
        const passwordRules = validatePassword(formData.password);
        const invalidRules = passwordRules.filter(rule => !rule.valid);
        if (invalidRules.length > 0) {
          newErrors.password = 'Password does not meet requirements';
        }
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    setLoading(true);
    setErrors({});

    try {
      const userData: UserCreate = {
        login: formData.login.trim(),
        email: formData.email.trim() || undefined,
        role: formData.role,
        is_active: formData.is_active,
        send_email: formData.send_email,
      };

      // Only include password if not sending email
      if (!formData.send_email) {
        userData.password = formData.password;
      }

      const response = await adminApi.createUser(userData);

      showSuccess(
        `User ${formData.login} created successfully${
          response.password ? ` with password: ${response.password}` : ''
        }`
      );

      navigate(`/admin/users/${response.user.id}`);
    } catch (error: any) {
      console.error('Failed to create user:', error);
      
      if (error.response?.data?.detail?.error?.code === 'user_exists') {
        setErrors({ login: 'User with this login already exists' });
      } else if (error.response?.data?.detail?.error?.code === 'invalid_password') {
        setErrors({ password: error.response.data.detail.error.message });
      } else {
        setErrors({ general: 'Failed to create user. Please try again.' });
      }
    } finally {
      setLoading(false);
    }
  };

  // Handle input changes
  const handleInputChange = (field: keyof FormData) => (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    const value = e.target.type === 'checkbox' 
      ? (e.target as HTMLInputElement).checked 
      : e.target.value;

    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Clear error when user starts typing
    if (errors[field as keyof FormErrors]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  const passwordRules = validatePassword(formData.password);

  return (
    <div className={styles.page}>
      <div className={styles.pageHeader}>
        <h1 className={styles.pageTitle}>Create New User</h1>
        <p className={styles.pageDescription}>
          Create a new user account with appropriate role and permissions.
        </p>
      </div>

      <form onSubmit={handleSubmit} className={styles.form}>
        {errors.general && (
          <div className={styles.formError} style={{ marginBottom: 'var(--spacing-lg)' }}>
            {errors.general}
          </div>
        )}

        {/* Basic Information */}
        <div className={styles.formSection}>
          <h2 className={styles.sectionTitle}>Basic Information</h2>
          
          <div className={styles.formGrid}>
            <div className={styles.formGroup}>
              <label className={`${styles.formLabel} ${styles.required}`}>
                Login
              </label>
              <Input
                type="text"
                value={formData.login}
                onChange={handleInputChange('login')}
                placeholder="Enter username"
                className={styles.formInput}
                error={!!errors.login}
              />
              {errors.login && (
                <div className={styles.formError}>{errors.login}</div>
              )}
              <div className={styles.formHelp}>
                Username for login. Only letters, numbers, hyphens, and underscores allowed.
              </div>
            </div>

            <div className={styles.formGroup}>
              <label className={styles.formLabel}>
                Email
              </label>
              <Input
                type="email"
                value={formData.email}
                onChange={handleInputChange('email')}
                placeholder="Enter email address"
                className={styles.formInput}
                error={!!errors.email}
              />
              {errors.email && (
                <div className={styles.formError}>{errors.email}</div>
              )}
              <div className={styles.formHelp}>
                Optional email address for notifications.
              </div>
            </div>
          </div>

          <div className={styles.formGrid}>
            <div className={styles.formGroup}>
              <label className={`${styles.formLabel} ${styles.required}`}>
                Role
              </label>
              <Select
                value={formData.role}
                onChange={handleInputChange('role')}
                className={styles.formSelect}
              >
                <option value="reader">Reader - View only access</option>
                <option value="editor">Editor - Create and edit content</option>
                <option value="admin">Admin - Full system access</option>
              </Select>
              <div className={styles.formHelp}>
                Determines user permissions and access level.
              </div>
            </div>

            <div className={styles.formGroup}>
              <label className={styles.formLabel}>
                Status
              </label>
              <Select
                value={formData.is_active ? 'active' : 'inactive'}
                onChange={(e) => setFormData(prev => ({ 
                  ...prev, 
                  is_active: e.target.value === 'active' 
                }))}
                className={styles.formSelect}
              >
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
              </Select>
              <div className={styles.formHelp}>
                Inactive users cannot log in to the system.
              </div>
            </div>
          </div>
        </div>

        {/* Password Settings */}
        <div className={styles.formSection}>
          <h2 className={styles.sectionTitle}>Password Settings</h2>

          {emailEnabled && (
            <div className={styles.passwordToggle}>
              <label className={styles.passwordToggleLabel}>
                <input
                  type="checkbox"
                  checked={formData.send_email}
                  onChange={handleInputChange('send_email')}
                  className={styles.formCheckboxInput}
                />
                Send password setup link via email
              </label>
              <div 
                className={`${styles.passwordToggleSwitch} ${formData.send_email ? styles.active : ''}`}
                onClick={() => setFormData(prev => ({ ...prev, send_email: !prev.send_email }))}
              />
            </div>
          )}

          {!formData.send_email && (
            <div className={styles.passwordField}>
              <div className={styles.formGroup}>
                <label className={`${styles.formLabel} ${styles.required}`}>
                  Temporary Password
                </label>
                <Input
                  type="password"
                  value={formData.password}
                  onChange={handleInputChange('password')}
                  placeholder="Enter temporary password"
                  className={styles.formInput}
                  error={!!errors.password}
                />
                {errors.password && (
                  <div className={styles.formError}>{errors.password}</div>
                )}
                <div className={styles.formHelp}>
                  User will be required to change this password on first login.
                </div>
              </div>

              <div className={styles.passwordPolicy}>
                <div className={styles.passwordPolicyTitle}>Password Requirements:</div>
                <ul className={styles.passwordPolicyList}>
                  {passwordRules.map((rule, index) => (
                    <li 
                      key={index}
                      className={`${styles.passwordPolicyItem} ${rule.valid ? styles.valid : styles.invalid}`}
                    >
                      <span className={styles.passwordPolicyIcon}>
                        {rule.valid ? '✓' : '✕'}
                      </span>
                      {rule.message}
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          )}

          <div className={styles.formGroup}>
            <label className={styles.formCheckbox}>
              <input
                type="checkbox"
                checked={formData.require_password_change}
                onChange={handleInputChange('require_password_change')}
                className={styles.formCheckboxInput}
              />
              <span className={styles.formCheckboxLabel}>
                Require password change on first login
              </span>
            </label>
            <div className={styles.formHelp}>
              User must set a new password when they first log in.
            </div>
          </div>
        </div>

        {/* Form Actions */}
        <div className={styles.formActions}>
          <Button
            type="button"
            variant="outline"
            onClick={() => navigate('/admin/users')}
            disabled={loading}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={loading}
          >
            {loading ? 'Creating...' : 'Create User'}
          </Button>
        </div>
      </form>
    </div>
  );
}

export default CreateUserPage;

// ===== app/routes/admin/EmailSettingsPage.tsx =====
import React, { useState, useEffect } from 'react';
import { adminApi, type SystemStatus } from '../../../shared/api/admin';
import { Button } from '../../../shared/ui/Button';
import { Skeleton } from '../../../shared/ui/Skeleton';
import { useErrorToast } from '../../../shared/ui/Toast';
import styles from './EmailSettingsPage.module.css';

export function EmailSettingsPage() {
  const showError = useErrorToast();

  // State
  const [status, setStatus] = useState<SystemStatus | null>(null);
  const [loading, setLoading] = useState(true);

  // Load system status
  useEffect(() => {
    const loadSystemStatus = async () => {
      try {
        setLoading(true);
        const systemStatus = await adminApi.getSystemStatus();
        setStatus(systemStatus);
      } catch (error) {
        console.error('Failed to load system status:', error);
        showError('Failed to load system status. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    loadSystemStatus();
  }, [showError]);

  // Refresh status
  const handleRefresh = async () => {
    try {
      setLoading(true);
      const systemStatus = await adminApi.getSystemStatus();
      setStatus(systemStatus);
    } catch (error) {
      console.error('Failed to refresh system status:', error);
      showError('Failed to refresh system status. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className={styles.page}>
        <div className={styles.loadingState}>
          <div className={styles.loadingSpinner} />
          <p>Loading email settings...</p>
        </div>
      </div>
    );
  }

  if (!status) {
    return (
      <div className={styles.page}>
        <div className={styles.loadingState}>
          <div className="text-danger">Failed to load system status</div>
        </div>
      </div>
    );
  }

  const getStatusBadge = () => {
    if (!status.email_enabled) {
      return { className: styles.disabled, text: 'Disabled' };
    }
    
    switch (status.email_status) {
      case 'ok':
        return { className: styles.enabled, text: 'Enabled' };
      case 'error':
        return { className: styles.error, text: 'Error' };
      case 'disabled':
        return { className: styles.disabled, text: 'Disabled' };
      default:
        return { className: styles.disabled, text: 'Unknown' };
    }
  };

  const statusBadge = getStatusBadge();

  return (
    <div className={styles.page}>
      <div className={styles.pageHeader}>
        <h1 className={styles.pageTitle}>Email Settings</h1>
        <p className={styles.pageDescription}>
          Monitor email system status and configuration.
        </p>
      </div>

      {/* Email Status */}
      <div className={styles.statusCard}>
        <div className={styles.statusHeader}>
          <h2 className={styles.statusTitle}>Email System Status</h2>
          <span className={`${styles.statusBadge} ${statusBadge.className}`}>
            {statusBadge.text}
          </span>
        </div>

        <div className={styles.statusInfo}>
          <div className={styles.statusItem}>
            <div className={styles.statusLabel}>Email Enabled</div>
            <div className={`${styles.statusValue} ${styles.boolean} ${status.email_enabled ? styles.true : styles.false}`}>
              {status.email_enabled ? 'Yes' : 'No'}
            </div>
          </div>

          <div className={styles.statusItem}>
            <div className={styles.statusLabel}>Email Status</div>
            <div className={styles.statusValue}>
              {status.email_status}
            </div>
          </div>

          <div className={styles.statusItem}>
            <div className={styles.statusLabel}>Total Users</div>
            <div className={styles.statusValue}>
              {status.total_users.toLocaleString()}
            </div>
          </div>

          <div className={styles.statusItem}>
            <div className={styles.statusLabel}>Active Users</div>
            <div className={styles.statusValue}>
              {status.active_users.toLocaleString()}
            </div>
          </div>
        </div>
      </div>

      {/* Email Configuration Info */}
      <div className={styles.infoCard}>
        <h3 className={styles.infoTitle}>Email Configuration</h3>
        <div className={styles.infoContent}>
          <p>
            Email functionality is controlled by environment variables and system configuration.
            The following settings determine how email features work in the system:
          </p>
          
          <ul className={styles.infoList}>
            <li className={styles.infoListItem}>
              <span className={styles.infoListIcon}>📧</span>
              <span className={styles.infoListText}>
                <strong>EMAIL_ENABLED</strong> - Master switch for email functionality
              </span>
            </li>
            <li className={styles.infoListItem}>
              <span className={styles.infoListIcon}>🔧</span>
              <span className={styles.infoListText}>
                <strong>SMTP Settings</strong> - SMTP server configuration for sending emails
              </span>
            </li>
            <li className={styles.infoListItem}>
              <span className={styles.infoListIcon}>🔐</span>
              <span className={styles.infoListText}>
                <strong>Authentication</strong> - SMTP username and password for server access
              </span>
            </li>
            <li className={styles.infoListItem}>
              <span className={styles.infoListIcon}>🛡️</span>
              <span className={styles.infoListText}>
                <strong>TLS/SSL</strong> - Secure connection settings for email transmission
              </span>
            </li>
          </ul>
        </div>
      </div>

      {/* Warning for disabled email */}
      {!status.email_enabled && (
        <div className={styles.warningCard}>
          <h3 className={styles.warningTitle}>
            ⚠️ Email System Disabled
          </h3>
          <div className={styles.warningContent}>
            <p>
              Email functionality is currently disabled. This means:
            </p>
            <ul className={styles.infoList}>
              <li className={styles.infoListItem}>
                <span className={styles.infoListIcon}>❌</span>
                <span className={styles.infoListText}>
                  Password reset emails will not be sent
                </span>
              </li>
              <li className={styles.infoListItem}>
                <span className={styles.infoListIcon}>❌</span>
                <span className={styles.infoListText}>
                  User creation emails will not be sent
                </span>
              </li>
              <li className={styles.infoListItem}>
                <span className={styles.infoListIcon}>✅</span>
                <span className={styles.infoListText}>
                  Offline password reset will be used instead
                </span>
              </li>
            </ul>
            <p>
              To enable email functionality, configure the EMAIL_ENABLED environment variable
              and provide valid SMTP settings.
            </p>
          </div>
        </div>
      )}

      {/* System Metrics */}
      <div className={styles.metricsCard}>
        <h3 className={styles.metricsTitle}>System Metrics</h3>
        <div className={styles.metricsGrid}>
          <div className={styles.metricItem}>
            <div className={styles.metricValue}>
              {loading ? <Skeleton width={60} height={32} /> : status.total_users}
            </div>
            <div className={styles.metricLabel}>Total Users</div>
          </div>

          <div className={styles.metricItem}>
            <div className={styles.metricValue}>
              {loading ? <Skeleton width={60} height={32} /> : status.active_users}
            </div>
            <div className={styles.metricLabel}>Active Users</div>
          </div>

          <div className={styles.metricItem}>
            <div className={styles.metricValue}>
              {loading ? <Skeleton width={60} height={32} /> : status.total_tokens}
            </div>
            <div className={styles.metricLabel}>Total Tokens</div>
          </div>

          <div className={styles.metricItem}>
            <div className={styles.metricValue}>
              {loading ? <Skeleton width={60} height={32} /> : status.active_tokens}
            </div>
            <div className={styles.metricLabel}>Active Tokens</div>
          </div>
        </div>
      </div>

      {/* Actions */}
      <div style={{ display: 'flex', justifyContent: 'flex-end', gap: 'var(--spacing-md)' }}>
        <Button onClick={handleRefresh} variant="outline">
          Refresh Status
        </Button>
      </div>
    </div>
  );
}

export default EmailSettingsPage;

// ===== app/routes/admin/UsersPage.tsx =====
import React, { useState, useEffect, useCallback } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { adminApi, type User, type UserListResponse } from '../../../shared/api/admin';
import { Table, type TableColumn } from '../../../shared/ui/Table';
import { RoleBadge, StatusBadge } from '../../../shared/ui/RoleBadge';
import { Button } from '../../../shared/ui/Button';
import { Input } from '../../../shared/ui/Input';
import { Select } from '../../../shared/ui/Select';
import { Skeleton } from '../../../shared/ui/Skeleton';
import { useErrorToast, useSuccessToast } from '../../../shared/ui/Toast';
import styles from './UsersPage.module.css';

export function UsersPage() {
  const navigate = useNavigate();
  const showError = useErrorToast();
  const showSuccess = useSuccessToast();

  // State
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [total, setTotal] = useState(0);
  const [hasMore, setHasMore] = useState(false);
  const [nextCursor, setNextCursor] = useState<string | undefined>();
  const [currentCursor, setCurrentCursor] = useState<string | undefined>();

  // Filters
  const [query, setQuery] = useState('');
  const [roleFilter, setRoleFilter] = useState<string>('');
  const [statusFilter, setStatusFilter] = useState<string>('');
  const [sortBy, setSortBy] = useState<string>('created_at');
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');

  // Load users
  const loadUsers = useCallback(async (cursor?: string, reset = false) => {
    try {
      setLoading(true);
      
      const params = {
        query: query || undefined,
        role: roleFilter || undefined,
        is_active: statusFilter ? statusFilter === 'active' : undefined,
        limit: 20,
        cursor,
      };

      const response: UserListResponse = await adminApi.getUsers(params);
      
      if (reset) {
        setUsers(response.users);
        setCurrentCursor(undefined);
      } else {
        setUsers(prev => [...prev, ...response.users]);
      }
      
      setTotal(response.total);
      setHasMore(response.has_more);
      setNextCursor(response.next_cursor);
    } catch (error) {
      console.error('Failed to load users:', error);
      showError('Failed to load users. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [query, roleFilter, statusFilter, showError]);

  // Load more users
  const loadMore = useCallback(() => {
    if (hasMore && nextCursor && !loading) {
      setCurrentCursor(nextCursor);
      loadUsers(nextCursor, false);
    }
  }, [hasMore, nextCursor, loading, loadUsers]);

  // Refresh users
  const refreshUsers = useCallback(() => {
    loadUsers(undefined, true);
  }, [loadUsers]);

  // Handle search
  const handleSearch = useCallback(() => {
    loadUsers(undefined, true);
  }, [loadUsers]);

  // Handle sort
  const handleSort = useCallback((column: string, order: 'asc' | 'desc') => {
    setSortBy(column);
    setSortOrder(order);
    loadUsers(undefined, true);
  }, [loadUsers]);

  // Handle user actions
  const handleToggleUserStatus = useCallback(async (user: User) => {
    try {
      await adminApi.updateUser(user.id, { is_active: !user.is_active });
      showSuccess(`User ${user.login} ${user.is_active ? 'deactivated' : 'activated'} successfully`);
      refreshUsers();
    } catch (error) {
      console.error('Failed to toggle user status:', error);
      showError('Failed to update user status. Please try again.');
    }
  }, [showSuccess, showError, refreshUsers]);

  const handleDeleteUser = useCallback(async (user: User) => {
    if (!window.confirm(`Are you sure you want to deactivate user ${user.login}?`)) {
      return;
    }

    try {
      await adminApi.deleteUser(user.id);
      showSuccess(`User ${user.login} deactivated successfully`);
      refreshUsers();
    } catch (error) {
      console.error('Failed to delete user:', error);
      showError('Failed to deactivate user. Please try again.');
    }
  }, [showSuccess, showError, refreshUsers]);

  // Load users on mount and when filters change
  useEffect(() => {
    loadUsers(undefined, true);
  }, [loadUsers]);

  // Table columns
  const columns: TableColumn<User>[] = [
    {
      key: 'login',
      title: 'Login',
      dataIndex: 'login',
      sortable: true,
      render: (value, record) => (
        <Link 
          to={`/admin/users/${record.id}`}
          className="text-primary hover:text-primary-dark font-medium"
        >
          {value}
        </Link>
      ),
    },
    {
      key: 'role',
      title: 'Role',
      dataIndex: 'role',
      sortable: true,
      render: (value) => <RoleBadge role={value as any} />,
    },
    {
      key: 'email',
      title: 'Email',
      dataIndex: 'email',
      render: (value) => value || <span className="text-text-tertiary">—</span>,
    },
    {
      key: 'is_active',
      title: 'Status',
      dataIndex: 'is_active',
      sortable: true,
      render: (value) => <StatusBadge active={value} />,
    },
    {
      key: 'created_at',
      title: 'Created',
      dataIndex: 'created_at',
      sortable: true,
      render: (value) => new Date(value).toLocaleDateString(),
    },
    {
      key: 'actions',
      title: 'Actions',
      render: (_, record) => (
        <div className="flex gap-2">
          <Button
            size="small"
            variant="outline"
            onClick={() => navigate(`/admin/users/${record.id}`)}
          >
            View
          </Button>
          <Button
            size="small"
            variant="outline"
            onClick={() => handleToggleUserStatus(record)}
          >
            {record.is_active ? 'Deactivate' : 'Activate'}
          </Button>
          <Button
            size="small"
            variant="danger"
            onClick={() => handleDeleteUser(record)}
          >
            Delete
          </Button>
        </div>
      ),
    },
  ];

  return (
    <div className={styles.page}>
      <div className={styles.pageHeader}>
        <h1 className={styles.pageTitle}>Users</h1>
        <div className={styles.pageActions}>
          <Button onClick={refreshUsers} variant="outline">
            Refresh
          </Button>
          <Button onClick={() => navigate('/admin/users/new')}>
            Create User
          </Button>
        </div>
      </div>

      <div className={styles.filters}>
        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Search</label>
          <Input
            placeholder="Search by login or email..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
          />
        </div>

        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Role</label>
          <Select
            value={roleFilter}
            onChange={(e) => setRoleFilter(e.target.value)}
          >
            <option value="">All Roles</option>
            <option value="admin">Admin</option>
            <option value="editor">Editor</option>
            <option value="reader">Reader</option>
          </Select>
        </div>

        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Status</label>
          <Select
            value={statusFilter}
            onChange={(e) => setStatusFilter(e.target.value)}
          >
            <option value="">All Status</option>
            <option value="active">Active</option>
            <option value="inactive">Inactive</option>
          </Select>
        </div>

        <div className={styles.filterActions}>
          <Button onClick={handleSearch} variant="outline">
            Search
          </Button>
          <Button 
            onClick={() => {
              setQuery('');
              setRoleFilter('');
              setStatusFilter('');
              loadUsers(undefined, true);
            }}
            variant="outline"
          >
            Clear
          </Button>
        </div>
      </div>

      <div className={styles.tableContainer}>
        <div className={styles.tableHeader}>
          <h2 className={styles.tableTitle}>Users List</h2>
          <div className={styles.tableStats}>
            {loading ? (
              <Skeleton width={100} />
            ) : (
              `Showing ${users.length} of ${total} users`
            )}
          </div>
        </div>

        <div className={styles.tableContent}>
          {loading && users.length === 0 ? (
            <div className={styles.loadingState}>
              <div className={styles.loadingSpinner} />
              <p>Loading users...</p>
            </div>
          ) : (
            <Table
              columns={columns}
              data={users}
              loading={loading}
              onSort={handleSort}
              sortBy={sortBy}
              sortOrder={sortOrder}
              emptyText="No users found"
              emptyIcon="👥"
            />
          )}
        </div>

        {hasMore && (
          <div className={styles.pagination}>
            <div className={styles.paginationInfo}>
              Showing {users.length} of {total} users
            </div>
            <div className={styles.paginationControls}>
              <Button
                onClick={loadMore}
                disabled={loading}
                variant="outline"
              >
                {loading ? 'Loading...' : 'Load More'}
              </Button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default UsersPage;

// ===== app/routes/admin/UserDetailPage.tsx =====
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { adminApi, type User, type UserToken, type AuditLog, TOKEN_SCOPES } from '../../../shared/api/admin';
import { RoleBadge, StatusBadge } from '../../../shared/ui/RoleBadge';
import { Button } from '../../../shared/ui/Button';
import { Input } from '../../../shared/ui/Input';
import { Select } from '../../../shared/ui/Select';
import { Modal } from '../../../shared/ui/Modal';
import { Skeleton } from '../../../shared/ui/Skeleton';
import { useErrorToast, useSuccessToast } from '../../../shared/ui/Toast';
import styles from './UserDetailPage.module.css';

type TabType = 'profile' | 'security' | 'tokens' | 'audit';

export function UserDetailPage() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const showError = useErrorToast();
  const showSuccess = useSuccessToast();

  // State
  const [user, setUser] = useState<User | null>(null);
  const [tokens, setTokens] = useState<UserToken[]>([]);
  const [auditLogs, setAuditLogs] = useState<AuditLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState<TabType>('profile');
  const [editing, setEditing] = useState(false);
  const [saving, setSaving] = useState(false);

  // Form state
  const [formData, setFormData] = useState({
    role: 'reader' as 'admin' | 'editor' | 'reader',
    email: '',
    is_active: true,
  });

  // Token creation modal
  const [showTokenModal, setShowTokenModal] = useState(false);
  const [tokenForm, setTokenForm] = useState({
    name: '',
    scopes: [] as string[],
    expires_at: '',
  });

  // Load user data
  useEffect(() => {
    if (!id) return;

    const loadUserData = async () => {
      try {
        setLoading(true);
        const [userData, tokensData, auditData] = await Promise.all([
          adminApi.getUser(id),
          adminApi.getUserTokens(id),
          adminApi.getAuditLogs({ actor_user_id: id, limit: 10 }),
        ]);

        setUser(userData);
        setTokens(tokensData.tokens);
        setAuditLogs(auditData.logs);
        setFormData({
          role: userData.role,
          email: userData.email || '',
          is_active: userData.is_active,
        });
      } catch (error) {
        console.error('Failed to load user data:', error);
        showError('Failed to load user data. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    loadUserData();
  }, [id, showError]);

  // Handle form submission
  const handleSave = async () => {
    if (!user) return;

    try {
      setSaving(true);
      const updatedUser = await adminApi.updateUser(user.id, formData);
      setUser(updatedUser);
      setEditing(false);
      showSuccess('User updated successfully');
    } catch (error) {
      console.error('Failed to update user:', error);
      showError('Failed to update user. Please try again.');
    } finally {
      setSaving(false);
    }
  };

  // Handle password reset
  const handlePasswordReset = async () => {
    if (!user) return;

    if (!window.confirm(`Reset password for user ${user.login}?`)) {
      return;
    }

    try {
      const response = await adminApi.resetUserPassword(user.id, {});
      if (response.password) {
        showSuccess(`Password reset successfully. New password: ${response.password}`);
      } else {
        showSuccess('Password reset email sent successfully');
      }
    } catch (error) {
      console.error('Failed to reset password:', error);
      showError('Failed to reset password. Please try again.');
    }
  };

  // Handle token creation
  const handleCreateToken = async () => {
    if (!user) return;

    try {
      const response = await adminApi.createUserToken(user.id, {
        name: tokenForm.name,
        scopes: tokenForm.scopes,
        expires_at: tokenForm.expires_at || undefined,
      });

      setTokens(prev => [...prev, response]);
      setShowTokenModal(false);
      setTokenForm({ name: '', scopes: [], expires_at: '' });
      
      if (response.token_plain_once) {
        showSuccess(`Token created successfully: ${response.token_plain_once}`);
      } else {
        showSuccess('Token created successfully');
      }
    } catch (error) {
      console.error('Failed to create token:', error);
      showError('Failed to create token. Please try again.');
    }
  };

  // Handle token revocation
  const handleRevokeToken = async (tokenId: string) => {
    if (!window.confirm('Are you sure you want to revoke this token?')) {
      return;
    }

    try {
      await adminApi.revokeToken(tokenId);
      setTokens(prev => prev.filter(token => token.id !== tokenId));
      showSuccess('Token revoked successfully');
    } catch (error) {
      console.error('Failed to revoke token:', error);
      showError('Failed to revoke token. Please try again.');
    }
  };

  if (loading) {
    return (
      <div className={styles.page}>
        <div className={styles.loadingState}>
          <div className={styles.loadingSpinner} />
          <p>Loading user data...</p>
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className={styles.page}>
        <div className={styles.emptyState}>
          <div className={styles.emptyStateIcon}>👤</div>
          <div className={styles.emptyStateTitle}>User not found</div>
          <div className={styles.emptyStateDescription}>
            The requested user could not be found.
          </div>
          <Button onClick={() => navigate('/admin/users')}>
            Back to Users
          </Button>
        </div>
      </div>
    );
  }

  const getInitials = (name: string) => {
    return name
      .split(' ')
      .map(word => word[0])
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  return (
    <div className={styles.page}>
      <div className={styles.pageHeader}>
        <h1 className={styles.pageTitle}>User Details</h1>
        <div className={styles.pageActions}>
          <Button
            variant="outline"
            onClick={() => navigate('/admin/users')}
          >
            Back to Users
          </Button>
          {editing ? (
            <>
              <Button
                variant="outline"
                onClick={() => {
                  setEditing(false);
                  setFormData({
                    role: user.role,
                    email: user.email || '',
                    is_active: user.is_active,
                  });
                }}
              >
                Cancel
              </Button>
              <Button
                onClick={handleSave}
                disabled={saving}
              >
                {saving ? 'Saving...' : 'Save Changes'}
              </Button>
            </>
          ) : (
            <Button onClick={() => setEditing(true)}>
              Edit User
            </Button>
          )}
        </div>
      </div>

      <div className={styles.userInfo}>
        <div className={styles.userAvatar}>
          {getInitials(user.login)}
        </div>
        <div className={styles.userDetails}>
          <h2 className={styles.userName}>{user.login}</h2>
          <div className={styles.userRole}>
            <RoleBadge role={user.role} size="large" />
          </div>
          <div className={styles.userMeta}>
            <div className={styles.userMetaItem}>
              <strong>Status:</strong> <StatusBadge active={user.is_active} />
            </div>
            <div className={styles.userMetaItem}>
              <strong>Email:</strong> {user.email || 'Not provided'}
            </div>
            <div className={styles.userMetaItem}>
              <strong>Created:</strong> {new Date(user.created_at).toLocaleDateString()}
            </div>
            <div className={styles.userMetaItem}>
              <strong>Last Updated:</strong> {new Date(user.updated_at).toLocaleDateString()}
            </div>
          </div>
        </div>
      </div>

      <div className={styles.tabs}>
        <button
          className={`${styles.tab} ${activeTab === 'profile' ? styles.active : ''}`}
          onClick={() => setActiveTab('profile')}
        >
          Profile
        </button>
        <button
          className={`${styles.tab} ${activeTab === 'security' ? styles.active : ''}`}
          onClick={() => setActiveTab('security')}
        >
          Security
        </button>
        <button
          className={`${styles.tab} ${activeTab === 'tokens' ? styles.active : ''}`}
          onClick={() => setActiveTab('tokens')}
        >
          Tokens ({tokens.length})
        </button>
        <button
          className={`${styles.tab} ${activeTab === 'audit' ? styles.active : ''}`}
          onClick={() => setActiveTab('audit')}
        >
          Audit
        </button>
      </div>

      {/* Profile Tab */}
      <div className={`${styles.tabContent} ${activeTab === 'profile' ? styles.active : ''}`}>
        <div className={styles.section}>
          <h3 className={styles.sectionTitle}>Profile Information</h3>
          <div className={styles.sectionContent}>
            <div className={styles.formGroup}>
              <label className={styles.formLabel}>Login</label>
              <Input
                value={user.login}
                disabled
                className={styles.formInput}
              />
              <div className={styles.formHelp}>
                Username cannot be changed after creation.
              </div>
            </div>

            <div className={styles.formGroup}>
              <label className={styles.formLabel}>Email</label>
              {editing ? (
                <Input
                  type="email"
                  value={formData.email}
                  onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
                  className={styles.formInput}
                />
              ) : (
                <Input
                  value={user.email || 'Not provided'}
                  disabled
                  className={styles.formInput}
                />
              )}
            </div>

            <div className={styles.formGroup}>
              <label className={styles.formLabel}>Role</label>
              {editing ? (
                <Select
                  value={formData.role}
                  onChange={(e) => setFormData(prev => ({ 
                    ...prev, 
                    role: e.target.value as any 
                  }))}
                  className={styles.formSelect}
                >
                  <option value="reader">Reader</option>
                  <option value="editor">Editor</option>
                  <option value="admin">Admin</option>
                </Select>
              ) : (
                <div>
                  <RoleBadge role={user.role} />
                </div>
              )}
            </div>

            <div className={styles.formGroup}>
              <label className={styles.formLabel}>Status</label>
              {editing ? (
                <Select
                  value={formData.is_active ? 'active' : 'inactive'}
                  onChange={(e) => setFormData(prev => ({ 
                    ...prev, 
                    is_active: e.target.value === 'active' 
                  }))}
                  className={styles.formSelect}
                >
                  <option value="active">Active</option>
                  <option value="inactive">Inactive</option>
                </Select>
              ) : (
                <div>
                  <StatusBadge active={user.is_active} />
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Security Tab */}
      <div className={`${styles.tabContent} ${activeTab === 'security' ? styles.active : ''}`}>
        <div className={styles.section}>
          <h3 className={styles.sectionTitle}>Security Settings</h3>
          <div className={styles.sectionContent}>
            <div className={styles.formGroup}>
              <label className={styles.formLabel}>Password Reset</label>
              <div className={styles.formHelp}>
                Reset the user's password. They will be required to change it on next login.
              </div>
              <Button
                variant="outline"
                onClick={handlePasswordReset}
              >
                Reset Password
              </Button>
            </div>
          </div>
        </div>
      </div>

      {/* Tokens Tab */}
      <div className={`${styles.tabContent} ${activeTab === 'tokens' ? styles.active : ''}`}>
        <div className={styles.section}>
          <div className={styles.sectionTitle}>
            Personal Access Tokens
            <Button
              size="small"
              onClick={() => setShowTokenModal(true)}
              style={{ marginLeft: 'var(--spacing-md)' }}
            >
              Create Token
            </Button>
          </div>
          
          {tokens.length === 0 ? (
            <div className={styles.emptyState}>
              <div className={styles.emptyStateIcon}>🔑</div>
              <div className={styles.emptyStateTitle}>No tokens</div>
              <div className={styles.emptyStateDescription}>
                This user has no personal access tokens.
              </div>
            </div>
          ) : (
            <div className={styles.tokensList}>
              {tokens.map((token) => (
                <div key={token.id} className={styles.tokenItem}>
                  <div className={styles.tokenInfo}>
                    <div className={styles.tokenName}>{token.name}</div>
                    <div className={styles.tokenScopes}>
                      {token.scopes.map((scope) => (
                        <span key={scope.scope} className={styles.tokenScope}>
                          {scope.scope}
                        </span>
                      ))}
                    </div>
                    <div className={styles.tokenMeta}>
                      Created: {new Date(token.created_at).toLocaleDateString()}
                      {token.expires_at && (
                        <> • Expires: {new Date(token.expires_at).toLocaleDateString()}</>
                      )}
                      {token.last_used_at && (
                        <> • Last used: {new Date(token.last_used_at).toLocaleDateString()}</>
                      )}
                      {token.revoked_at && (
                        <> • Revoked: {new Date(token.revoked_at).toLocaleDateString()}</>
                      )}
                    </div>
                  </div>
                  <div className={styles.tokenActions}>
                    {!token.revoked_at && (
                      <Button
                        size="small"
                        variant="danger"
                        onClick={() => handleRevokeToken(token.id)}
                      >
                        Revoke
                      </Button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Audit Tab */}
      <div className={`${styles.tabContent} ${activeTab === 'audit' ? styles.active : ''}`}>
        <div className={styles.section}>
          <h3 className={styles.sectionTitle}>Recent Activity</h3>
          
          {auditLogs.length === 0 ? (
            <div className={styles.emptyState}>
              <div className={styles.emptyStateIcon}>📋</div>
              <div className={styles.emptyStateTitle}>No activity</div>
              <div className={styles.emptyStateDescription}>
                No recent activity found for this user.
              </div>
            </div>
          ) : (
            <div className={styles.auditList}>
              {auditLogs.map((log) => (
                <div key={log.id} className={styles.auditItem}>
                  <div className={styles.auditInfo}>
                    <div className={styles.auditAction}>{log.action}</div>
                    <div className={styles.auditDetails}>
                      {log.object_type && log.object_id && (
                        <>Object: {log.object_type} ({log.object_id})</>
                      )}
                    </div>
                    <div className={styles.auditMeta}>
                      {log.ip && <>IP: {log.ip}</>}
                      {log.user_agent && <> • {log.user_agent}</>}
                    </div>
                  </div>
                  <div className={styles.auditTime}>
                    {new Date(log.ts).toLocaleString()}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Token Creation Modal */}
      <Modal
        isOpen={showTokenModal}
        onClose={() => setShowTokenModal(false)}
        title="Create Personal Access Token"
      >
        <div className={styles.sectionContent}>
          <div className={styles.formGroup}>
            <label className={`${styles.formLabel} ${styles.required}`}>
              Token Name
            </label>
            <Input
              value={tokenForm.name}
              onChange={(e) => setTokenForm(prev => ({ ...prev, name: e.target.value }))}
              placeholder="Enter token name"
              className={styles.formInput}
            />
          </div>

          <div className={styles.formGroup}>
            <label className={`${styles.formLabel} ${styles.required}`}>
              Scopes
            </label>
            <div className={styles.formHelp}>
              Select the permissions this token should have.
            </div>
            <div style={{ maxHeight: '200px', overflowY: 'auto', border: '1px solid var(--color-border)', borderRadius: 'var(--border-radius)', padding: 'var(--spacing-sm)' }}>
              {TOKEN_SCOPES.map((scope) => (
                <label key={scope.scope} className={styles.formCheckbox}>
                  <input
                    type="checkbox"
                    checked={tokenForm.scopes.includes(scope.scope)}
                    onChange={(e) => {
                      if (e.target.checked) {
                        setTokenForm(prev => ({ 
                          ...prev, 
                          scopes: [...prev.scopes, scope.scope] 
                        }));
                      } else {
                        setTokenForm(prev => ({ 
                          ...prev, 
                          scopes: prev.scopes.filter(s => s !== scope.scope) 
                        }));
                      }
                    }}
                    className={styles.formCheckboxInput}
                  />
                  <span className={styles.formCheckboxLabel}>
                    <strong>{scope.scope}</strong> - {scope.description}
                  </span>
                </label>
              ))}
            </div>
          </div>

          <div className={styles.formGroup}>
            <label className={styles.formLabel}>
              Expires At
            </label>
            <Input
              type="datetime-local"
              value={tokenForm.expires_at}
              onChange={(e) => setTokenForm(prev => ({ ...prev, expires_at: e.target.value }))}
              className={styles.formInput}
            />
            <div className={styles.formHelp}>
              Leave empty for no expiration.
            </div>
          </div>
        </div>

        <div className={styles.formActions}>
          <Button
            variant="outline"
            onClick={() => setShowTokenModal(false)}
          >
            Cancel
          </Button>
          <Button
            onClick={handleCreateToken}
            disabled={!tokenForm.name || tokenForm.scopes.length === 0}
          >
            Create Token
          </Button>
        </div>
      </Modal>
    </div>
  );
}

export default UserDetailPage;

// ===== app/routes/admin/AuditPage.tsx =====
import React, { useState, useEffect, useCallback } from 'react';
import { adminApi, type AuditLog, type AuditLogListResponse } from '../../../shared/api/admin';
import { Button } from '../../../shared/ui/Button';
import { Input } from '../../../shared/ui/Input';
import { Select } from '../../../shared/ui/Select';
import { Skeleton } from '../../../shared/ui/Skeleton';
import { useErrorToast } from '../../../shared/ui/Toast';
import styles from './AuditPage.module.css';

export function AuditPage() {
  const showError = useErrorToast();

  // State
  const [logs, setLogs] = useState<AuditLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [total, setTotal] = useState(0);
  const [hasMore, setHasMore] = useState(false);
  const [nextCursor, setNextCursor] = useState<string | undefined>();
  const [currentCursor, setCurrentCursor] = useState<string | undefined>();

  // Filters
  const [filters, setFilters] = useState({
    actor_user_id: '',
    action: '',
    object_type: '',
    start_date: '',
    end_date: '',
  });

  // Load audit logs
  const loadLogs = useCallback(async (cursor?: string, reset = false) => {
    try {
      setLoading(true);
      
      const params = {
        actor_user_id: filters.actor_user_id || undefined,
        action: filters.action || undefined,
        object_type: filters.object_type || undefined,
        start_date: filters.start_date || undefined,
        end_date: filters.end_date || undefined,
        limit: 50,
        cursor,
      };

      const response: AuditLogListResponse = await adminApi.getAuditLogs(params);
      
      if (reset) {
        setLogs(response.logs);
        setCurrentCursor(undefined);
      } else {
        setLogs(prev => [...prev, ...response.logs]);
      }
      
      setTotal(response.total);
      setHasMore(response.has_more);
      setNextCursor(response.next_cursor);
    } catch (error) {
      console.error('Failed to load audit logs:', error);
      showError('Failed to load audit logs. Please try again.');
    } finally {
      setLoading(false);
    }
  }, [filters, showError]);

  // Load more logs
  const loadMore = useCallback(() => {
    if (hasMore && nextCursor && !loading) {
      setCurrentCursor(nextCursor);
      loadLogs(nextCursor, false);
    }
  }, [hasMore, nextCursor, loading, loadLogs]);

  // Refresh logs
  const refreshLogs = useCallback(() => {
    loadLogs(undefined, true);
  }, [loadLogs]);

  // Handle search
  const handleSearch = useCallback(() => {
    loadLogs(undefined, true);
  }, [loadLogs]);

  // Handle filter changes
  const handleFilterChange = (field: string) => (
    e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
  ) => {
    setFilters(prev => ({ ...prev, [field]: e.target.value }));
  };

  // Load logs on mount and when filters change
  useEffect(() => {
    loadLogs(undefined, true);
  }, [loadLogs]);

  // Get action badge style
  const getActionBadgeStyle = (action: string) => {
    if (action.includes('create') || action.includes('created')) return 'create';
    if (action.includes('update') || action.includes('updated')) return 'update';
    if (action.includes('delete') || action.includes('deleted')) return 'delete';
    if (action.includes('login') || action.includes('auth')) return 'login';
    return 'default';
  };

  // Get actor initials
  const getActorInitials = (actorUserId: string | undefined) => {
    if (!actorUserId) return 'S';
    return actorUserId.slice(0, 2).toUpperCase();
  };

  // Format action name
  const formatAction = (action: string) => {
    return action
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  };

  return (
    <div className={styles.page}>
      <div className={styles.pageHeader}>
        <h1 className={styles.pageTitle}>Audit Log</h1>
        <div className={styles.pageActions}>
          <Button onClick={refreshLogs} variant="outline">
            Refresh
          </Button>
        </div>
      </div>

      <div className={styles.filters}>
        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Actor</label>
          <Input
            placeholder="User ID or login..."
            value={filters.actor_user_id}
            onChange={handleFilterChange('actor_user_id')}
            className={styles.filterInput}
          />
        </div>

        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Action</label>
          <Input
            placeholder="Action name..."
            value={filters.action}
            onChange={handleFilterChange('action')}
            className={styles.filterInput}
          />
        </div>

        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Object Type</label>
          <Select
            value={filters.object_type}
            onChange={handleFilterChange('object_type')}
            className={styles.filterSelect}
          >
            <option value="">All Types</option>
            <option value="user">User</option>
            <option value="token">Token</option>
            <option value="password">Password</option>
            <option value="auth">Authentication</option>
          </Select>
        </div>

        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>Start Date</label>
          <Input
            type="datetime-local"
            value={filters.start_date}
            onChange={handleFilterChange('start_date')}
            className={styles.filterInput}
          />
        </div>

        <div className={styles.filterGroup}>
          <label className={styles.filterLabel}>End Date</label>
          <Input
            type="datetime-local"
            value={filters.end_date}
            onChange={handleFilterChange('end_date')}
            className={styles.filterInput}
          />
        </div>

        <div className={styles.filterActions}>
          <Button onClick={handleSearch} variant="outline">
            Search
          </Button>
          <Button 
            onClick={() => {
              setFilters({
                actor_user_id: '',
                action: '',
                object_type: '',
                start_date: '',
                end_date: '',
              });
              loadLogs(undefined, true);
            }}
            variant="outline"
          >
            Clear
          </Button>
        </div>
      </div>

      <div className={styles.tableContainer}>
        <div className={styles.tableHeader}>
          <h2 className={styles.tableTitle}>Audit Logs</h2>
          <div className={styles.tableStats}>
            {loading ? (
              <Skeleton width={100} />
            ) : (
              `Showing ${logs.length} of ${total} logs`
            )}
          </div>
        </div>

        <div className={styles.tableContent}>
          {loading && logs.length === 0 ? (
            <div className={styles.loadingState}>
              <div className={styles.loadingSpinner} />
              <p>Loading audit logs...</p>
            </div>
          ) : logs.length === 0 ? (
            <div className={styles.emptyState}>
              <div className={styles.emptyStateIcon}>📋</div>
              <div className={styles.emptyStateTitle}>No audit logs</div>
              <div className={styles.emptyStateDescription}>
                No audit logs found matching your criteria.
              </div>
            </div>
          ) : (
            <div>
              {logs.map((log) => (
                <div key={log.id} className={styles.auditItem}>
                  <div className={styles.auditInfo}>
                    <div className={styles.auditAction}>
                      <span className={`${styles.actionBadge} ${styles[getActionBadgeStyle(log.action)]}`}>
                        {formatAction(log.action)}
                      </span>
                    </div>
                    
                    <div className={styles.auditDetails}>
                      {log.object_type && log.object_id && (
                        <>
                          <span className={styles.objectType}>{log.object_type}</span>
                          <span className={styles.objectId}> ({log.object_id})</span>
                        </>
                      )}
                    </div>
                    
                    <div className={styles.auditMeta}>
                      <div className={styles.actorInfo}>
                        <div className={styles.actorAvatar}>
                          {getActorInitials(log.actor_user_id)}
                        </div>
                        <span className={log.actor_user_id ? styles.actorName : styles.systemActor}>
                          {log.actor_user_id ? `User ${log.actor_user_id.slice(0, 8)}` : 'System'}
                        </span>
                      </div>
                      
                      {log.ip && (
                        <>
                          <span>•</span>
                          <span>IP: {log.ip}</span>
                        </>
                      )}
                      
                      {log.user_agent && (
                        <>
                          <span>•</span>
                          <span title={log.user_agent}>
                            {log.user_agent.length > 50 
                              ? `${log.user_agent.slice(0, 50)}...` 
                              : log.user_agent
                            }
                          </span>
                        </>
                      )}
                    </div>
                  </div>
                  
                  <div className={styles.auditTime}>
                    {new Date(log.ts).toLocaleString()}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {hasMore && (
          <div className={styles.pagination}>
            <div className={styles.paginationInfo}>
              Showing {logs.length} of {total} logs
            </div>
            <div className={styles.paginationControls}>
              <Button
                onClick={loadMore}
                disabled={loading}
                variant="outline"
              >
                {loading ? 'Loading...' : 'Load More'}
              </Button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default AuditPage;

// ===== app/routes/admin/AdminLayout.tsx =====
import React from 'react';
import { Outlet, useLocation, Link } from 'react-router-dom';
import styles from './AdminLayout.module.css';

interface AdminLayoutProps {
  children?: React.ReactNode;
}

export function AdminLayout({ children }: AdminLayoutProps) {
  const location = useLocation();

  const navItems = [
    {
      group: 'Users',
      items: [
        { path: '/admin/users', label: 'Users', icon: '👥' },
        { path: '/admin/users/new', label: 'New User', icon: '➕' },
      ],
    },
    {
      group: 'System',
      items: [
        { path: '/admin/audit', label: 'Audit Log', icon: '📋' },
        { path: '/admin/settings/email', label: 'Email Settings', icon: '📧' },
      ],
    },
  ];

  const getBreadcrumb = () => {
    const pathSegments = location.pathname.split('/').filter(Boolean);
    const breadcrumbs = [{ label: 'Admin', path: '/admin' }];
    
    if (pathSegments.length > 1) {
      const currentPath = pathSegments.slice(0, 2).join('/');
      const currentLabel = navItems
        .flatMap(group => group.items)
        .find(item => item.path === `/${currentPath}`)?.label || pathSegments[1];
      
      breadcrumbs.push({ label: currentLabel, path: `/${currentPath}` });
    }
    
    if (pathSegments.length > 2) {
      breadcrumbs.push({ label: pathSegments[2], path: location.pathname });
    }
    
    return breadcrumbs;
  };

  const breadcrumbs = getBreadcrumb();

  return (
    <div className={styles.layout}>
      <aside className={styles.sidebar}>
        <div className={styles.sidebarHeader}>
          <h1 className={styles.sidebarTitle}>Administration</h1>
          <p className={styles.sidebarSubtitle}>Manage users and system</p>
        </div>
        
        <nav className={styles.nav}>
          {navItems.map((group) => (
            <div key={group.group} className={styles.navGroup}>
              <div className={styles.navGroupTitle}>{group.group}</div>
              {group.items.map((item) => (
                <Link
                  key={item.path}
                  to={item.path}
                  className={`${styles.navItem} ${
                    location.pathname === item.path ? styles.active : ''
                  }`}
                >
                  <span className={styles.navItemIcon}>{item.icon}</span>
                  <span className={styles.navItemText}>{item.label}</span>
                </Link>
              ))}
            </div>
          ))}
        </nav>
      </aside>
      
      <main className={styles.main}>
        <header className={styles.header}>
          <div>
            <nav className={styles.breadcrumb}>
              {breadcrumbs.map((crumb, index) => (
                <React.Fragment key={crumb.path}>
                  {index > 0 && <span className={styles.breadcrumbSeparator}>/</span>}
                  {index === breadcrumbs.length - 1 ? (
                    <span className={styles.breadcrumbCurrent}>{crumb.label}</span>
                  ) : (
                    <Link to={crumb.path} className={styles.breadcrumbItem}>
                      {crumb.label}
                    </Link>
                  )}
                </React.Fragment>
              ))}
            </nav>
            <h1 className={styles.headerTitle}>
              {breadcrumbs[breadcrumbs.length - 1]?.label || 'Admin'}
            </h1>
          </div>
          
          <div className={styles.headerActions}>
            {/* Add header actions here */}
          </div>
        </header>
        
        <div className={styles.content}>
          {children || <Outlet />}
        </div>
      </main>
    </div>
  );
}

export default AdminLayout;

// ===== app/components/__tests__/ChatTags.test.tsx =====
import React from 'react'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import '@testing-library/jest-dom'
import { vi } from 'vitest'
import ChatTags from '../ChatTags'

// Mock the useChat hook
vi.mock('../../contexts/ChatContext', () => ({
  useChat: () => ({
    updateChatTags: vi.fn()
  })
}))

describe('ChatTags', () => {
  const defaultProps = {
    chatId: 'test-chat-id',
    tags: ['test', 'example'],
    onTagsChange: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders existing tags', () => {
    render(<ChatTags {...defaultProps} />)
    
    expect(screen.getByText('test')).toBeInTheDocument()
    expect(screen.getByText('example')).toBeInTheDocument()
  })

  it('renders "No tags" when no tags provided', () => {
    render(<ChatTags {...defaultProps} tags={[]} />)
    
    expect(screen.getByText('Нет тегов')).toBeInTheDocument()
  })

  it('opens modal when edit button is clicked', () => {
    render(<ChatTags {...defaultProps} />)
    
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    expect(screen.getByText('Управление тегами')).toBeInTheDocument()
  })

  it('adds new tag when input is filled and add button clicked', async () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    expect(screen.getByText('new-tag')).toBeInTheDocument()
  })

  it('removes tag when remove button is clicked', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Remove tag
    const removeButtons = screen.getAllByText('×')
    fireEvent.click(removeButtons[0]) // Remove first tag
    
    expect(screen.queryByText('test')).not.toBeInTheDocument()
    expect(screen.getByText('example')).toBeInTheDocument()
  })

  it('saves changes when save button is clicked', async () => {
    const onTagsChange = vi.fn()
    render(<ChatTags {...defaultProps} onTagsChange={onTagsChange} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    // Save changes
    const saveButton = screen.getByText('Сохранить')
    fireEvent.click(saveButton)
    
    await waitFor(() => {
      expect(onTagsChange).toHaveBeenCalledWith(['test', 'example', 'new-tag'])
    })
  })

  it('cancels changes when cancel button is clicked', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    // Cancel changes
    const cancelButton = screen.getByText('Отмена')
    fireEvent.click(cancelButton)
    
    // Modal should be closed and original tags should remain
    expect(screen.queryByText('Управление тегами')).not.toBeInTheDocument()
    expect(screen.getByText('test')).toBeInTheDocument()
    expect(screen.getByText('example')).toBeInTheDocument()
  })

  it('adds tag when Enter key is pressed', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag with Enter key
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    fireEvent.keyPress(input, { key: 'Enter', code: 'Enter' })
    
    expect(screen.getByText('new-tag')).toBeInTheDocument()
  })

  it('does not add empty tag', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Try to add empty tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: '   ' } })
    
    const addButton = screen.getByText('Добавить')
    expect(addButton).toBeDisabled()
  })

  it('does not add duplicate tag', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Try to add existing tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'test' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    // Should not add duplicate
    const testTags = screen.getAllByText('test')
    expect(testTags).toHaveLength(1) // Only the original one
  })
})
