
// ===== vite-env.d.ts =====
/// <reference types="vite/client" />

declare module '*.module.css' {
  const classes: { readonly [key: string]: string }
  export default classes
}

// ===== mocks/mockFetch.ts =====
// Simple in-app fetch mock. Works when VITE_USE_MOCKS=true
// Emulates a subset of backend endpoints used by the app, including SSE for chat and simple queues.
type Opts = RequestInit & { idempotencyKey?: string }
const encoder = new TextEncoder()

type User = { id: string; login: string; fio?: string; role?: string; password?: string }
type Message = { role: 'user'|'assistant'; content: string }
type Chat = { id: string; name: string; messages: Message[] }
type RagDoc = { id: string; name: string; status: 'uploaded'|'processing'|'ready'|'error'; tags: string[]; created_at: string }
type AnalyzeTask = { id: string; source?: string; status: 'queued'|'processing'|'done'|'error'; result?: string; created_at: string }

const db = {
  users: [{ id: 'u1', login: 'admin', password: 'admin', fio: 'Администратор', role: 'admin' } as User],
  chats: new Map<string, Chat>(),
  tokens: new Map<string, string>(), // access_token -> userId
  rag: [] as RagDoc[],
  analyze: [] as AnalyzeTask[]
}

function jsonResponse(body: any, init: ResponseInit = {}) {
  return new Response(JSON.stringify(body), { status: 200, headers: { 'Content-Type': 'application/json' }, ...init })
}
function noContent() { return new Response(null, { status: 204 }) }
function unauthorized() { return new Response('unauthorized', { status: 401 }) }
function notFound() { return new Response('not found', { status: 404 }) }
function badRequest(msg='bad request') { return new Response(msg, { status: 400 }) }

function parseUrl(url: string) {
  // Works with relative like "/api/..." and absolute like "http://x/api/..."
  try {
    const u = new URL(url, window.location.origin)
    return u
  } catch {
    return new URL(window.location.origin + url.replace(/^\//, ''))
  }
}

async function readJson(body?: BodyInit | null) {
  if (!body) return null
  if (typeof body === 'string') { try { return JSON.parse(body) } catch { return null } }
  if (body instanceof FormData) { return body }
  // Other types: ignore for simplicity
  return null
}

function requireAuth(headers: Headers): User | null {
  const auth = headers.get('Authorization') || ''
  const token = auth.startsWith('Bearer ') ? auth.slice(7) : null
  if (!token) return null
  const uid = db.tokens.get(token || '')
  const user = db.users.find(u => u.id === uid)
  return user || null
}

function sseStream(lines: string[], delayMs = 40) {
  return new ReadableStream<Uint8Array>({
    async start(controller) {
      for (const part of lines) {
        const chunk = `data: ${part}\n\n`
        controller.enqueue(encoder.encode(chunk))
        await new Promise(r => setTimeout(r, delayMs))
      }
      controller.close()
    }
  })
}

function paginate<T extends { id?: string }>(arr: T[], cursor?: string | null, limit = 20) {
  let start = 0
  if (cursor) {
    const idx = (arr as any[]).findIndex((it:any) => (it.id || it.chat_id) === cursor)
    start = idx >= 0 ? idx + 1 : 0
  }
  const items = (arr as any[]).slice(start, start + limit)
  const next_cursor = (start + limit) < (arr as any[]).length ? ((arr as any[])[start + limit - 1] as any).id : null
  return { items, next_cursor }
}

// Seed some RAG docs on first GET
function seedRag() {
  if (db.rag.length > 0) return
  const now = new Date().toISOString()
  db.rag.push(
    { id: 'doc1', name: 'Guide.pdf', status: 'ready', tags: ['guide'], created_at: now },
    { id: 'doc2', name: 'Spec.md', status: 'processing', tags: ['spec'], created_at: now },
    { id: 'doc3', name: 'Manual.txt', status: 'uploaded', tags: ['manual'], created_at: now }
  )
}

// Simple background progression helper (uploaded -> processing -> ready)
function progressRag(doc: RagDoc) {
  setTimeout(() => { doc.status = 'processing' }, 600)
  setTimeout(() => { doc.status = 'ready' }, 1400)
}

// Analyze progression (queued -> processing -> done with text result)
function progressAnalyze(task: AnalyzeTask) {
  setTimeout(() => { task.status = 'processing' }, 500)
  setTimeout(() => { task.status = 'done'; task.result = `Результат анализа: «${task.source || 'file'}» обработан.` }, 1500)
}

export async function mockFetch(url: string, opts: Opts = {}) {
  const u = parseUrl(url)
  const path = u.pathname
  const method = (opts.method || 'GET').toUpperCase()
  const body = await readJson(opts.body || null)

  // AUTH
  if (path === '/api/auth/login' && method === 'POST') {
    const { login, password } = (body as any) || {}
    const user = db.users.find(u => u.login === login && u.password === password)
    if (!user) return badRequest('invalid credentials')
    const access = crypto.randomUUID()
    db.tokens.set(access, user.id)
    return jsonResponse({ access_token: access, refresh_token: 'refresh_' + user.id, expires_in: 3600 })
  }
  if (path === '/api/auth/refresh' && method === 'POST') {
    // accept any refresh token that starts with "refresh_"
    const { refresh_token } = (body as any) || {}
    if (!refresh_token || !String(refresh_token).startsWith('refresh_')) return unauthorized()
    const uid = String(refresh_token).slice('refresh_'.length)
    const user = db.users.find(u => u.id === uid)
    if (!user) return unauthorized()
    const access = crypto.randomUUID()
    db.tokens.set(access, user.id)
    return jsonResponse({ access_token: access, expires_in: 3600 })
  }
  if (path === '/api/auth/me' && method === 'GET') {
    const user = requireAuth(new Headers(opts.headers || {}))
    if (!user) return unauthorized()
    const { password, ...safe } = user as any
    return jsonResponse(safe)
  }
  if (path === '/api/auth/logout' && method === 'POST') {
    const auth = new Headers(opts.headers || {}).get('Authorization') || ''
    const token = auth.startsWith('Bearer ') ? auth.slice(7) : ''
    db.tokens.delete(token)
    return noContent()
  }

  // CHATS
  if (path === '/api/chats' && method === 'POST') {
    const id = crypto.randomUUID()
    const name = (body && (body as any).name) || 'New chat'
    db.chats.set(id, { id, name, messages: [] })
    return jsonResponse({ chat_id: id })
  }
  if (path === '/api/chats' && method === 'GET') {
    const list = Array.from(db.chats.values()).map(c => ({ id: c.id, name: c.name }))
    return jsonResponse({ items: list, next_cursor: null })
  }
  const chatIdMatch = path.match(/^\/api\/chats\/([^\/]+)(?:\/(messages))?$/)
  if (chatIdMatch) {
    const chatId = chatIdMatch[1]
    const sub = chatIdMatch[2] // 'messages' or undefined
    const chat = db.chats.get(chatId)
    if (!chat && method !== 'PATCH' && method !== 'DELETE') return notFound()

    if (!sub && method === 'PATCH') {
      const name = (body as any)?.name || 'Untitled'
      const c = db.chats.get(chatId)
      if (!c) return notFound()
      c.name = name
      return jsonResponse({ ok: true })
    }
    if (!sub && method === 'DELETE') {
      db.chats.delete(chatId)
      return noContent()
    }

    if (sub === 'messages' && method === 'GET') {
      const msgs = chat ? chat.messages : []
      return jsonResponse({ items: msgs, next_cursor: null })
    }

    if (sub === 'messages' && method === 'POST') {
      const payload = (body as any) || {}
      const userMsg = (payload.messages?.[0]?.content) || ''
      if (chat) chat.messages.push({ role: 'user', content: userMsg })

      const canned = `Привет! Это моковый ответ на: "${userMsg}".\nМоки включены, бэкенд не требуется.`

      if (payload.response_stream) {
        const tokens = Array.from(canned)
        const stream = sseStream(tokens, 18)
        // also push the final assistant message into history (joined)
        const full = tokens.join('')
        if (chat) chat.messages.push({ role: 'assistant', content: full })
        const headers = new Headers({
          'Content-Type': 'text/event-stream; charset=utf-8',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive'
        })
        return new Response(stream, { status: 200, headers })
      } else {
        if (chat) chat.messages.push({ role: 'assistant', content: canned })
        return jsonResponse({ message: { role: 'assistant', content: canned } })
      }
    }
  }

  // RAG
  if (path === '/api/rag' && method === 'GET') {
    seedRag()
    const q = u.searchParams.get('q')?.toLowerCase() || ''
    const status = u.searchParams.get('status') || ''
    const cursor = u.searchParams.get('cursor') || undefined
    let data = db.rag.slice()
    if (q) data = data.filter(d => d.name.toLowerCase().includes(q))
    if (status) data = data.filter(d => d.status === status)
    const { items, next_cursor } = paginate(data, cursor, 20)
    return jsonResponse({ items, next_cursor })
  }
  if (path === '/api/rag/upload' && method === 'POST') {
    const name = (body instanceof FormData) ? (body.get('name') as string || (body.get('file') as File)?.name || 'document') : 'document'
    const doc: RagDoc = { id: crypto.randomUUID(), name, status: 'uploaded', tags: [], created_at: new Date().toISOString() }
    db.rag.unshift(doc)
    progressRag(doc)
    return jsonResponse({ id: doc.id, status: doc.status })
  }
  if (path === '/api/rag/search' && method === 'POST') {
    const q = (body as any)?.text || ''
    return jsonResponse({ items: [
      { document_id: db.rag[0]?.id || 'doc1', chunk_id: '1', score: 0.92, snippet: `Найдено по запросу "${q}" — фрагмент №1` },
      { document_id: db.rag[0]?.id || 'doc1', chunk_id: '2', score: 0.87, snippet: `Найдено по запросу "${q}" — фрагмент №2` }
    ]})
  }

  // ANALYZE
  if (path === '/api/analyze' && method === 'GET') {
    const items = db.analyze.slice().sort((a,b) => (b.created_at > a.created_at ? 1 : -1))
    return jsonResponse({ items })
  }
  if (path === '/api/analyze' && method === 'POST') {
    let source = ''
    if (body instanceof FormData) {
      source = (body.get('file') as File)?.name || 'file'
    } else {
      source = (body as any)?.url || ''
    }
    if (!source) return badRequest('source required')
    const task: AnalyzeTask = { id: crypto.randomUUID(), source, status: 'queued', created_at: new Date().toISOString() }
    db.analyze.unshift(task)
    progressAnalyze(task)
    return jsonResponse({ id: task.id, status: task.status })
  }
  const analyzeMatch = path.match(/^\/api\/analyze\/([^\/]+)$/)
  if (analyzeMatch && method === 'GET') {
    const id = analyzeMatch[1]
    const t = db.analyze.find(x => x.id === id)
    if (!t) return notFound()
    return jsonResponse(t)
  }

  // Unknown: pass-through to real fetch (allows gradual mocking)
  return fetch(url, opts)
}

// ===== mocks/enableMocks.ts =====
import { mockFetch } from './mockFetch'

function toUrl(input: RequestInfo | URL): string {
  if (typeof input === 'string') return input
  if (input instanceof URL) return input.toString()
  // Request
  try {
    // @ts-ignore
    return input.url || String(input)
  } catch {
    // @ts-ignore
    return String(input)
  }
}

// Replace global fetch to ensure ALL calls go through mocks in dev.
if (typeof window !== 'undefined') {
  const original = window.fetch.bind(window)
  // @ts-ignore
  window.fetch = (input: RequestInfo | URL, init?: RequestInit) => {
    const url = toUrl(input)
    // Allow opting-out: if request has header 'X-Bypass-Mock', go to real fetch
    if (init && (init as any).headers && (init as any).headers['X-Bypass-Mock']) {
      return original(input, init)
    }
    return mockFetch(url, init as any)
  }
}

// ===== mocks/index.ts =====
// Auto-enable mocks when VITE_USE_MOCKS === 'true'
// No top-level await to keep TS/Vite happy in all setups.
if (import.meta.env.VITE_USE_MOCKS === 'true') {
  import('./mockFetch');
}
export {};

// ===== test/setup.ts =====
import '@testing-library/jest-dom'
import { vi } from 'vitest'

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock crypto.randomUUID
Object.defineProperty(global, 'crypto', {
  value: {
    randomUUID: vi.fn(() => 'test-uuid-123')
  }
})

// ===== entities/auth/model/auth.store.ts =====
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { apiRequest, setAuthTokens, clearAuthTokens, refreshAccessToken } from "@/shared/api/http";
import type { User, LoginResponse, AuthTokens } from "@/shared/api/types";

type AuthState = {
  user: User | null;
  tokens: AuthTokens | null;
  isAuthReady: boolean;
  login: (login: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  hydrate: () => Promise<void>;
};

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      tokens: null,
      isAuthReady: false,
      async login(login, password) {
        const data = await apiRequest<LoginResponse>("/auth/login", { method: "POST", body: JSON.stringify({ login, password }) });
        const tokens = { 
          access_token: data.access_token, 
          token_type: data.token_type,
          refresh_token: data.refresh_token, 
          expires_in: data.expires_in 
        };
        setAuthTokens(tokens);
        set({ tokens });
        set({ user: data.user });
      },
      async logout() {
        try { await apiRequest<void>("/auth/logout", { method: "POST" }); } catch {}
        clearAuthTokens();
        set({ tokens: null, user: null });
      },
      async hydrate() {
        try {
          const me = await apiRequest<User>("/auth/me", { method: "GET" });
          set({ user: me, isAuthReady: true });
        } catch {
          try {
            await refreshAccessToken();
            const me = await apiRequest<User>("/auth/me", { method: "GET" });
            set({ user: me, isAuthReady: true });
          } catch {
            clearAuthTokens();
            set({ user: null, tokens: null, isAuthReady: true });
          }
        }
      },
    }),
    { name: "auth-store", partialize: (s) => ({ tokens: s.tokens }) }
  )
);

// ===== shared/config/env.ts =====
export const USE_MOCKS = (import.meta as any).env?.VITE_USE_MOCKS === 'true'
export const API_BASE: string = ((import.meta as any).env?.VITE_API_BASE as string) || '/api'

// ===== shared/lib/storage.ts =====
export type Tokens = { access_token: string; refresh_token?: string; expires_at?: number }
const KEY = 'auth.tokens.v1'

export function set(key: string, value: any) {
  if (value === undefined || value === null) { localStorage.removeItem(key); return }
  if (typeof value === 'string') localStorage.setItem(key, value)
  else localStorage.setItem(key, JSON.stringify(value))
}
export function get<T = string>(key: string): T | null {
  const raw = localStorage.getItem(key)
  if (raw === null) return null
  try { return JSON.parse(raw) as T } catch { return raw as unknown as T }
}
export function del(key: string) { localStorage.removeItem(key) }

export function saveTokens(t: Tokens | null) {
  if (!t) {
    localStorage.removeItem(KEY)
    del('token'); del('refresh_token')
    return
  }
  localStorage.setItem(KEY, JSON.stringify(t))
  set('token', t.access_token)
  if (t.refresh_token) set('refresh_token', t.refresh_token); else del('refresh_token')
}
export function loadTokens(): Tokens | null {
  try { return JSON.parse(localStorage.getItem(KEY) || 'null') } catch { return null }
}

// ===== shared/lib/sse.ts =====
export type SSEEvent = { event?: string; data?: string; id?: string }
export async function* parseSSE(stream: ReadableStream<Uint8Array>) {
  const reader = stream.getReader()
  const decoder = new TextDecoder()
  let buf = ''
  try {
    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      buf += decoder.decode(value, { stream: true })
      let idx
      while ((idx = buf.indexOf('\n\n')) !== -1) {
        const chunk = buf.slice(0, idx).trim()
        buf = buf.slice(idx + 2)
        if (!chunk) continue
        const ev: SSEEvent = {}
        for (const line of chunk.split('\n')) {
          const [k, ...rest] = line.split(':')
          const v = rest.join(':').trimStart()
          if (k === 'event') ev.event = v
          else if (k === 'data') ev.data = (ev.data ? ev.data + '\n' : '') + v
          else if (k === 'id') ev.id = v
        }
        yield ev
      }
    }
  } finally { reader.releaseLock() }
}

// ===== shared/lib/idempotency.ts =====
export function idempotencyKey(): string {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) return (crypto as any).randomUUID();
  return "idem_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
}

// ===== shared/lib/apiFetch.ts =====
import { API_BASE } from '@shared/api'
import { get, set, del } from './storage'
import { idempotencyKey } from './idempotency'

type Opts = RequestInit & { auth?: boolean, idempotent?: boolean }

function token() { return get<string>('token') }
function refreshToken() { return get<string>('refresh_token') }

async function refresh() {
  const res = await fetch(API_BASE + '/auth/refresh', { method:'POST', headers:{ 'Content-Type': 'application/json' }, body: JSON.stringify({ refresh_token: refreshToken() }) })
  if (!res.ok) throw new Error('refresh failed')
  const data = await res.json()
  set('token', data.access_token); if (data.refresh_token) set('refresh_token', data.refresh_token)
  return data.access_token
}

export async function apiFetch(path: string, opts: Opts = {}) {
  const url = path.startsWith('http') ? path : API_BASE + path
  const headers: Record<string,string> = { ...(opts.headers||{}) as any }
  if (opts.auth !== false && token()) headers['Authorization'] = 'Bearer ' + token()
  if (opts.idempotent) headers['Idempotency-Key'] = idempotencyKey()
  const doFetch = () => fetch(url, { ...opts, headers })
  let res = await doFetch()
  if (res.status === 401 && token()) {
    try { const t = await refresh(); headers['Authorization'] = 'Bearer ' + t; res = await doFetch() }
    catch { del('token'); del('refresh_token'); throw new Error('Не авторизован') }
  }
  if (!res.ok) {
    let msg = 'Request failed'
    try { const j = await res.json(); msg = j.message || j.detail || JSON.stringify(j) } catch {}
    throw new Error(msg)
  }
  return res
}

// ===== shared/api/analyze.ts =====
import { apiRequest } from './http'

export async function listAnalyze() {
  return apiRequest<{ items: any[] }>('/analyze')
}

export async function uploadAnalysisFile(file: File) {
  const fd = new FormData()
  fd.set('file', file)
  return apiRequest<{ id: string; status: string }>('/analyze/upload', { method: 'POST', body: fd })
}

export async function getAnalyze(id: string) {
  return apiRequest<any>(`/analyze/${id}`)
}

export async function downloadAnalysisFile(doc_id: string, kind: 'original' | 'canonical' = 'original') {
  return apiRequest<{ url: string }>(`/analyze/${doc_id}/download?kind=${kind}`)
}

export async function deleteAnalysisFile(doc_id: string) {
  return apiRequest<{ id: string; deleted: boolean }>(`/analyze/${doc_id}`, { method: 'DELETE' })
}

export async function reanalyzeFile(doc_id: string) {
  return apiRequest<{ id: string; status: string }>(`/analyze/${doc_id}/reanalyze`, { method: 'POST' })
}

// ===== shared/api/errors.ts =====
export type ErrorEnvelope = {
  error: { code: string; message: string; details?: unknown };
  request_id?: string;
};

export class ApiError extends Error {
  code: string;
  requestId?: string;
  details?: unknown;
  constructor(message: string, code = "unknown_error", requestId?: string, details?: unknown) {
    super(message);
    this.name = "ApiError";
    this.code = code;
    this.requestId = requestId;
    this.details = details;
  }
}

export async function toApiError(resp: Response): Promise<ApiError> {
  let msg = `${resp.status} ${resp.statusText}`;
  let code = "http_error";
  let requestId: string | undefined;
  let details: unknown;
  try {
    const data = await resp.json();
    if (data && typeof data === "object" && "error" in data) {
      const err = (data as any).error;
      msg = err?.message || msg;
      code = err?.code || code;
      requestId = (data as any).request_id;
      details = err?.details;
    }
  } catch {}
  return new ApiError(msg, code, requestId, details);
}

// ===== shared/api/chats.ts =====
import { apiRequest } from './http'
import { parseSSE } from '@shared/lib/sse'
import type { 
  PaginatedResponse, 
  Chat, 
  ChatCreateRequest, 
  ChatUpdateRequest, 
  ChatTagsUpdateRequest,
  ChatMessageRequest,
  ChatMessageResponse,
  ChatMessage
} from './types'

export async function listChats(params: { cursor?: string; limit?: number; q?: string } = {}) {
  const qs = new URLSearchParams()
  if (params.limit) qs.set('limit', String(params.limit))
  if (params.cursor) qs.set('cursor', params.cursor)
  if (params.q) qs.set('q', params.q)
  return apiRequest<PaginatedResponse<Chat>>(`/chats?${qs.toString()}`)
}

export async function createChat(name?: string | null, tags?: string[] | null) {
  const body: ChatCreateRequest = { name: name ?? null, tags: tags ?? null }
  return apiRequest<{ chat_id: string }>('/chats', { method: 'POST', body: JSON.stringify(body) })
}

export async function listMessages(chat_id: string, params: { cursor?: string; limit?: number } = {}) {
  const qs = new URLSearchParams()
  if (params.limit) qs.set('limit', String(params.limit))
  if (params.cursor) qs.set('cursor', params.cursor)
  return apiRequest<PaginatedResponse<ChatMessage>>(`/chats/${chat_id}/messages?${qs.toString()}`)
}

export async function sendMessage(chat_id: string, body: ChatMessageRequest) {
  return apiRequest<ChatMessageResponse>(`/chats/${chat_id}/messages`, { 
    method: 'POST', 
    body: JSON.stringify(body),
    idempotent: true 
  })
}

export async function* sendMessageStream(chat_id: string, body: { content: string; use_rag?: boolean }) {
  const headers: Record<string, string> = { 'Content-Type': 'application/json' }
  // Add auth token if available
  const token = (window as any).__auth_tokens?.access_token || localStorage.getItem('access_token')
  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }
  
  const API_BASE = import.meta.env.VITE_API_BASE || '/api'
  const res = await fetch(`${API_BASE}/chats/${chat_id}/messages`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ ...body, response_stream: true })
  })
  if (!res.ok) throw new Error(`HTTP ${res.status}`)

  const contentType = res.headers.get('content-type') || ''
  if (contentType.includes('text/event-stream')) {
    for await (const ev of parseSSE(res.body!)) {
      if (ev.data) yield ev.data
    }
  } else {
    const reader = res.body!.getReader()
    const decoder = new TextDecoder()
    let pending = ''
    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      pending += decoder.decode(value, { stream: true })
      let idx
      while ((idx = pending.indexOf('\n')) !== -1) {
        const line = pending.slice(0, idx).trim()
        pending = pending.slice(idx + 1)
        if (line) yield line
      }
    }
    if (pending.trim()) yield pending.trim()
  }
}

export async function renameChat(chat_id: string, name: string) {
  const body: ChatUpdateRequest = { name }
  return apiRequest<Chat>(`/chats/${chat_id}`, { 
    method: 'PATCH', 
    body: JSON.stringify(body) 
  })
}

export async function updateChatTags(chat_id: string, tags: string[]) {
  const body: ChatTagsUpdateRequest = { tags }
  return apiRequest<{ id: string; tags: string[] }>(`/chats/${chat_id}/tags`, { 
    method: 'PUT', 
    body: JSON.stringify(body) 
  })
}

export async function deleteChat(chat_id: string) {
  return apiRequest<{ id: string; deleted: boolean }>(`/chats/${chat_id}`, { method: 'DELETE' })
}

// ===== shared/api/http.ts =====
import { API_BASE } from "@/shared/config/env";
import { ApiError, toApiError } from "@/shared/api/errors";
import { idempotencyKey } from "@/shared/lib/idempotency";

export type RequestOptions = RequestInit & { idempotent?: boolean };

export type AuthTokens = { access_token: string; refresh_token?: string; expires_in?: number };
let _tokens: AuthTokens | null = null;
let _refreshPromise: Promise<void> | null = null;

export function setAuthTokens(tokens: AuthTokens | null) { 
  _tokens = tokens; 
  // Also save to global state for client.ts
  (window as any).__auth_tokens = tokens;
  if (tokens?.access_token) {
    localStorage.setItem('access_token', tokens.access_token);
  } else {
    localStorage.removeItem('access_token');
  }
}
export function clearAuthTokens() { 
  _tokens = null; 
  (window as any).__auth_tokens = null;
  localStorage.removeItem('access_token');
}
export function getAccessToken(): string | null { return _tokens?.access_token || null; }

export async function apiRequest<T>(path: string, opts: RequestOptions = {}): Promise<T> {
  const url = path.startsWith("http") ? path : API_BASE.replace(/\/$/, "") + path;
  const headers = new Headers(opts.headers || {});
  if (!headers.has("Content-Type") && !(opts.body instanceof FormData)) headers.set("Content-Type", "application/json");
  if (!headers.has("Accept")) headers.set("Accept", "application/json");
  if (_tokens?.access_token && !headers.has("Authorization")) headers.set("Authorization", `Bearer ${_tokens.access_token}`);
  const method = (opts.method || "GET").toUpperCase();
  if ((method !== "GET" && method !== "HEAD") || opts.idempotent) {
    if (!headers.has("Idempotency-Key")) headers.set("Idempotency-Key", idempotencyKey());
  }
  const attempt = () => fetch(url, { ...opts, headers });
  let resp = await attempt();
  if (resp.status === 401 && _tokens?.refresh_token) {
    try {
      await refreshAccessToken();
      const retryHeaders = new Headers(headers);
      if (_tokens?.access_token) retryHeaders.set("Authorization", `Bearer ${_tokens.access_token}`);
      resp = await fetch(url, { ...opts, headers: retryHeaders });
    } catch {}
  }
  if (!resp.ok) throw await toApiError(resp);
  if (resp.status === 204) return undefined as unknown as T;
  const ct = resp.headers.get("Content-Type") || "";
  if (ct.includes("application/json")) return await resp.json() as T;
  return await resp.text() as unknown as T;
}

export async function refreshAccessToken(): Promise<void> {
  if (_refreshPromise) return _refreshPromise;
  if (!_tokens?.refresh_token) throw new ApiError("No refresh token", "no_refresh_token");
  _refreshPromise = (async () => {
    const url = API_BASE.replace(/\/$/, "") + "/auth/refresh";
    const resp = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json", Accept: "application/json" },
      body: JSON.stringify({ refresh_token: _tokens!.refresh_token })
    });
    if (!resp.ok) {
      _refreshPromise = null; _tokens = null; throw await toApiError(resp);
    }
    const data = await resp.json();
    _tokens = {
      access_token: data.access_token,
      refresh_token: data.refresh_token ?? _tokens!.refresh_token,
      expires_in: data.expires_in
    };
    // Update global state and localStorage
    (window as any).__auth_tokens = _tokens;
    localStorage.setItem('access_token', _tokens.access_token);
    _refreshPromise = null;
  })();
  return _refreshPromise;
}

// ===== shared/api/rag.ts =====
import { apiRequest } from './http'

export async function listDocs(params: { 
  page?: number; 
  size?: number; 
  status?: string; 
  search?: string; 
} = {}) {
  const qs = new URLSearchParams()
  if (params.page) qs.set('page', String(params.page))
  if (params.size) qs.set('size', String(params.size))
  if (params.status) qs.set('status', params.status)
  if (params.search) qs.set('search', params.search)
  return apiRequest<{ 
    items: any[]; 
    pagination: {
      page: number;
      size: number;
      total: number;
      total_pages: number;
      has_next: boolean;
      has_prev: boolean;
    }
  }>(`/rag/?${qs.toString()}`)
}

export async function uploadFile(file: File, name?: string, tags?: string[]) {
  const fd = new FormData()
  fd.set('file', file)
  if (name) fd.set('name', name)
  if (tags?.length) fd.set('tags', JSON.stringify(tags))
  return apiRequest<{ id: string; status: string }>('/rag/upload', { method: 'POST', body: fd })
}

export async function updateRagDocumentTags(docId: string, tags: string[]) {
  return apiRequest<{ id: string; tags: string[] }>(`/rag/${docId}/tags`, { 
    method: 'PUT', 
    body: JSON.stringify(tags) 
  })
}

export async function getRagProgress(doc_id: string) {
  return apiRequest<any>(`/rag/${doc_id}/progress`)
}

export async function getRagStats() {
  return apiRequest<any>('/rag/stats')
}

export async function getRagMetrics() {
  return apiRequest<any>('/rag/metrics')
}

export async function downloadRagFile(doc_id: string, kind: 'original' | 'canonical' = 'original') {
  return apiRequest<{ url: string }>(`/rag/${doc_id}/download?kind=${kind}`)
}

export async function archiveRagDocument(doc_id: string) {
  return apiRequest<{ id: string; archived: boolean }>(`/rag/${doc_id}/archive`, { method: 'POST' })
}

export async function deleteRagDocument(doc_id: string) {
  return apiRequest<{ id: string; deleted: boolean }>(`/rag/${doc_id}`, { method: 'DELETE' })
}

export async function ragSearch(payload: { text?: string; top_k?: number; min_score?: number }) {
  return apiRequest<{ items: Array<{ document_id: string; chunk_id: string; score: number; snippet: string }> }>('/rag/search', { 
    method: 'POST', 
    body: JSON.stringify(payload) 
  })
}

export async function reindexRagDocument(doc_id: string) {
  return apiRequest<{ id: string; status: string }>(`/rag/${doc_id}/reindex`, { method: 'POST' })
}

export async function reindexAllRagDocuments() {
  return apiRequest<{ reindexed_count: number; total_documents: number }>('/rag/reindex', { method: 'POST' })
}

// ===== shared/api/types.ts =====
/** Shared API types */
export interface Pagination {
  page?: number
  size?: number
  total?: number
  total_pages?: number
  has_next?: boolean
  has_prev?: boolean
}

export interface PaginatedResponse<T> {
  items: T[]
  next_cursor?: string | null
  pagination?: Pagination
}

export interface Chat {
  id: string
  name?: string | null
  tags?: string[] | null
  created_at?: string | null
  updated_at?: string | null
  last_message_at?: string | null
}

export interface ChatMessage {
  id: string
  chat_id: string
  role: 'system' | 'user' | 'assistant' | 'tool'
  content: string
  created_at?: string | null
}

export interface ChatCreateRequest {
  name?: string | null
  tags?: string[] | null
}

export interface ChatUpdateRequest {
  name?: string | null
}

export interface ChatTagsUpdateRequest {
  tags: string[]
}

export interface ChatMessageRequest {
  content: string
  use_rag?: boolean
  response_stream?: boolean
}

export interface ChatMessageResponse {
  message_id: string
  content: string
  answer: string
  message?: string
}

export interface User {
  id: string
  email: string
  name?: string
  role?: string
  created_at?: string
  updated_at?: string
}

export interface LoginResponse {
  access_token: string
  token_type: string
  user: User
  refresh_token?: string
  expires_in?: number
}

export interface AuthTokens {
  access_token: string
  token_type: string
  refresh_token?: string
  expires_in?: number
}

export interface AnalyzeDocument {
  id: string
  name: string
  status: string
  created_at: string
  updated_at: string
  error?: string
  date_upload?: string
  result?: any
  url_canonical_file?: string
}

export interface RagDocument {
  id: string
  title: string
  content: string
  created_at: string
  updated_at: string
  name?: string
  status?: string
  progress?: number
  date_upload?: string
  tags?: string[]
  url_canonical_file?: string
}

// ===== shared/api/index.ts =====
export const API_BASE = (import.meta.env.VITE_API_BASE || '/api') as string

// ===== shared/api/auth.ts =====
import { apiRequest } from './http'
import type { LoginResponse, User } from './types'

export async function login(login: string, password: string): Promise<LoginResponse> {
  return apiRequest<LoginResponse>('/auth/login', { method: 'POST', body: JSON.stringify({ login, password }) })
}

export async function me(): Promise<User> {
  return apiRequest<User>('/auth/me', { method: 'GET' })
}

export async function logout(): Promise<void> {
  return apiRequest<void>('/auth/logout', { method: 'POST' })
}

// ===== app/store/useChatStore.ts =====
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

export interface ChatMessage {
  id?: string
  role: 'user' | 'assistant' | 'system'
  content: string
  created_at?: string
  chat_id?: string
}

export interface Chat {
  id: string
  name?: string
  tags?: string[]
  created_at?: string
  updated_at?: string
  last_message_at?: string
  messages: ChatMessage[]
  isLoading?: boolean
  hasMore?: boolean
  nextCursor?: string | null
}

interface ChatState {
  chats: Record<string, Chat>
  currentChatId: string | null
  isLoading: boolean
  error: string | null
  searchQuery: string
  selectedTags: string[]
}

interface ChatActions {
  // Chat management
  addChat: (chat: Chat) => void
  updateChat: (chatId: string, updates: Partial<Chat>) => void
  deleteChat: (chatId: string) => void
  setCurrentChat: (chatId: string | null) => void
  
  // Messages
  addMessage: (chatId: string, message: ChatMessage) => void
  updateMessage: (chatId: string, messageId: string, updates: Partial<ChatMessage>) => void
  setMessages: (chatId: string, messages: ChatMessage[], hasMore: boolean, nextCursor: string | null) => void
  appendMessages: (chatId: string, messages: ChatMessage[], hasMore: boolean, nextCursor: string | null) => void
  
  // UI state
  setLoading: (loading: boolean) => void
  setError: (error: string | null) => void
  setSearchQuery: (query: string) => void
  setSelectedTags: (tags: string[]) => void
  
  // Bulk operations
  loadChats: (chats: Chat[]) => void
  clearError: () => void
  reset: () => void
}

type ChatStore = ChatState & ChatActions

const initialState: ChatState = {
  chats: {},
  currentChatId: null,
  isLoading: false,
  error: null,
  searchQuery: '',
  selectedTags: []
}

export const useChatStore = create<ChatStore>()(
  devtools(
    persist(
      immer((set, get) => ({
        ...initialState,
        
        // Chat management
        addChat: (chat) => set((state) => {
          state.chats[chat.id] = chat
        }),
        
        updateChat: (chatId, updates) => set((state) => {
          if (state.chats[chatId]) {
            Object.assign(state.chats[chatId], updates)
          }
        }),
        
        deleteChat: (chatId) => set((state) => {
          delete state.chats[chatId]
          if (state.currentChatId === chatId) {
            state.currentChatId = null
          }
        }),
        
        setCurrentChat: (chatId) => set((state) => {
          state.currentChatId = chatId
        }),
        
        // Messages
        addMessage: (chatId, message) => set((state) => {
          if (state.chats[chatId]) {
            state.chats[chatId].messages.push(message)
            state.chats[chatId].last_message_at = message.created_at || new Date().toISOString()
          }
        }),
        
        updateMessage: (chatId, messageId, updates) => set((state) => {
          if (state.chats[chatId]) {
            const messageIndex = state.chats[chatId].messages.findIndex(m => m.id === messageId)
            if (messageIndex !== -1) {
              Object.assign(state.chats[chatId].messages[messageIndex], updates)
            }
          }
        }),
        
        setMessages: (chatId, messages, hasMore, nextCursor) => set((state) => {
          if (state.chats[chatId]) {
            state.chats[chatId].messages = messages
            state.chats[chatId].hasMore = hasMore
            state.chats[chatId].nextCursor = nextCursor
            state.chats[chatId].isLoading = false
          }
        }),
        
        appendMessages: (chatId, messages, hasMore, nextCursor) => set((state) => {
          if (state.chats[chatId]) {
            state.chats[chatId].messages = [...messages, ...state.chats[chatId].messages]
            state.chats[chatId].hasMore = hasMore
            state.chats[chatId].nextCursor = nextCursor
            state.chats[chatId].isLoading = false
          }
        }),
        
        // UI state
        setLoading: (loading) => set((state) => {
          state.isLoading = loading
        }),
        
        setError: (error) => set((state) => {
          state.error = error
        }),
        
        setSearchQuery: (query) => set((state) => {
          state.searchQuery = query
        }),
        
        setSelectedTags: (tags) => set((state) => {
          state.selectedTags = tags
        }),
        
        // Bulk operations
        loadChats: (chats) => set((state) => {
          chats.forEach(chat => {
            state.chats[chat.id] = chat
          })
        }),
        
        clearError: () => set((state) => {
          state.error = null
        }),
        
        reset: () => set(() => initialState)
      })),
      {
        name: 'chat-store',
        partialize: (state) => ({
          chats: state.chats,
          currentChatId: state.currentChatId,
          searchQuery: state.searchQuery,
          selectedTags: state.selectedTags
        })
      }
    ),
    {
      name: 'chat-store'
    }
  )
)

// Selectors
export const useCurrentChat = () => useChatStore((state) => 
  state.currentChatId ? state.chats[state.currentChatId] : null
)

export const useChatMessages = (chatId: string) => useChatStore((state) => 
  state.chats[chatId]?.messages || []
)

export const useFilteredChats = () => useChatStore((state) => {
  const { chats, searchQuery, selectedTags } = state
  
  return Object.values(chats).filter(chat => {
    const matchesSearch = !searchQuery || 
      chat.name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      chat.messages.some(msg => 
        msg.content.toLowerCase().includes(searchQuery.toLowerCase())
      )
    
    const matchesTags = selectedTags.length === 0 ||
      selectedTags.every(tag => chat.tags?.includes(tag))
    
    return matchesSearch && matchesTags
  }).sort((a, b) => 
    new Date(b.last_message_at || b.created_at || 0).getTime() - 
    new Date(a.last_message_at || a.created_at || 0).getTime()
  )
})

export const useChatStats = () => useChatStore((state) => {
  const chats = Object.values(state.chats)
  const totalMessages = chats.reduce((sum, chat) => sum + chat.messages.length, 0)
  const userMessages = chats.reduce((sum, chat) => 
    sum + chat.messages.filter(msg => msg.role === 'user').length, 0
  )
  const assistantMessages = chats.reduce((sum, chat) => 
    sum + chat.messages.filter(msg => msg.role === 'assistant').length, 0
  )
  
  return {
    totalChats: chats.length,
    totalMessages,
    userMessages,
    assistantMessages,
    averageMessagesPerChat: chats.length > 0 ? Math.round(totalMessages / chats.length) : 0
  }
})

// ===== app/store/auth.ts =====
import { useAuthStore } from '@/entities/auth/model/auth.store'

export type User = { id: string; login?: string; fio?: string; role?: string }

export const useAuth = () => {
  const authStore = useAuthStore()
  
  return {
    user: authStore.user,
    loading: false, // authStore doesn't have loading state
    error: null, // authStore doesn't have error state
    login: authStore.login,
    fetchMe: async () => {
      try {
        await authStore.hydrate()
        return authStore.user
      } catch {
        return null
      }
    },
    logout: authStore.logout
  }
}

// ===== main.tsx =====
import React from 'react'
import ReactDOM from 'react-dom/client'
import AppRouter from './app/router'
import './theme.css'

// Initialize auth tokens from localStorage
const initAuthTokens = () => {
  const token = localStorage.getItem('access_token');
  if (token) {
    (window as any).__auth_tokens = { access_token: token };
  }
};

initAuthTokens();

if ((import.meta as any).env?.VITE_USE_MOCKS === 'true') {
  import('./mocks/enableMocks')
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <AppRouter />
  </React.StrictMode>
)

// ===== app/router.tsx =====
import React, { Suspense, lazy } from 'react'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'

const GPTGate = lazy(() => import('./routes/GPTGate'))
const Login = lazy(() => import('./routes/Login'))
const GPTLayout = lazy(() => import('./routes/gpt/GPTLayout'))
const ChatPage = lazy(() => import('./routes/gpt/ChatPage'))
const AnalyzePage = lazy(() => import('./routes/gpt/AnalyzePage'))
const RagPage = lazy(() => import('./routes/gpt/Rag'))
const NotFound = lazy(() => import('./routes/NotFound'))

const withSuspense = (el: React.ReactNode) => <Suspense fallback={<div />}>{el}</Suspense>

const router = createBrowserRouter([
  { path: '/login', element: withSuspense(<Login />) },
  {
    path: '/gpt',
    element: withSuspense(<GPTGate>{withSuspense(<GPTLayout />)}</GPTGate>),
    children: [
      { path: 'chat', element: withSuspense(<ChatPage />) },
      { path: 'chat/:chatId', element: withSuspense(<ChatPage />) },
      { path: 'analyze', element: withSuspense(<AnalyzePage />) },
      { path: 'rag', element: withSuspense(<RagPage />) }
    ]
  },
  { path: '*', element: withSuspense(<NotFound />) }
])

export default function AppRouter() {
  return <RouterProvider router={router} />
}

// ===== app/MockBadge.tsx =====
import React from 'react'
const USE_MOCKS = import.meta.env.VITE_USE_MOCKS === 'true'
export default function MockBadge() {
  if (!USE_MOCKS) return null
  const style: React.CSSProperties = {
    position: 'fixed', bottom: 12, right: 12, padding: '6px 10px',
    background: 'rgba(79,124,255,0.15)', border: '1px solid rgba(79,124,255,0.35)',
    borderRadius: 10, fontSize: 12, color: 'var(--text)', zIndex: 9999
  }
  return <div style={style}>Mocks ON</div>
}

// ===== shared/ui/Card.tsx =====
import React from 'react'
import styles from './Card.module.css'

export default function Card({ className='', ...rest }: React.HTMLAttributes<HTMLDivElement>) {
  return <div {...rest} className={[styles.card, className].join(' ')} />
}

// ===== shared/ui/Popover.tsx =====
import React, { useEffect, useRef, useState } from 'react'

export default function Popover({ trigger, content, align = 'start' }: { trigger: React.ReactNode, content: React.ReactNode, align?: 'start' | 'end' }) {
  const [open, setOpen] = useState(false)
  const ref = useRef<HTMLDivElement>(null)
  useEffect(() => {
    function onDoc(e: MouseEvent) { if (!ref.current?.contains(e.target as any)) setOpen(false) }
    document.addEventListener('mousedown', onDoc)
    return () => document.removeEventListener('mousedown', onDoc)
  }, [])
  return (
    <div ref={ref} style={{ position: 'relative' }}>
      <div onClick={() => setOpen(v => !v)}>{trigger}</div>
      {open && (
        <div style={{ position: 'absolute', top: '100%', [align === 'end' ? 'right' : 'left']: 0, zIndex: 10, background: 'var(--panel)', border: '1px solid rgba(255,255,255,.12)', borderRadius: 8, padding: 4, boxShadow: '0 6px 24px rgba(0,0,0,.35)' } as any}>
          {content}
        </div>
      )}
    </div>
  )
}

// ===== shared/ui/Icon.tsx =====
import React from 'react'

export function FilterIcon({ active=false, size=14 }: { active?: boolean, size?: number }) {
  const stroke = active ? 'var(--primary)' : 'currentColor'
  const fill = active ? 'var(--primary)' : 'none'
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M3 5h18l-7 8v5l-4 2v-7L3 5z" fill={fill} stroke={stroke} strokeWidth="1.5"/>
    </svg>
  )
}

export function MoreVerticalIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <circle cx="12" cy="6" r="2" fill="currentColor"/>
      <circle cx="12" cy="12" r="2" fill="currentColor"/>
      <circle cx="12" cy="18" r="2" fill="currentColor"/>
    </svg>
  )
}

export function DownloadIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" strokeWidth="2" fill="none"/>
      <polyline points="7,10 12,15 17,10" stroke="currentColor" strokeWidth="2" fill="none"/>
      <line x1="12" y1="15" x2="12" y2="3" stroke="currentColor" strokeWidth="2"/>
    </svg>
  )
}

export function RefreshIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" stroke="currentColor" strokeWidth="2" fill="none"/>
    </svg>
  )
}

export function ArchiveIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <rect x="2" y="3" width="20" height="4" rx="2" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M4 7v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M10 13h4" stroke="currentColor" strokeWidth="2"/>
    </svg>
  )
}

export function TrashIcon({ size=14 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" aria-hidden="true" style={{ verticalAlign: 'middle' }}>
      <path d="M3 6h18" stroke="currentColor" strokeWidth="2"/>
      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" stroke="currentColor" strokeWidth="2" fill="none"/>
      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" stroke="currentColor" strokeWidth="2" fill="none"/>
    </svg>
  )
}

// ===== shared/ui/FilePicker.tsx =====
import React, { useRef } from 'react'
import Button from './Button'
import styles from './FilePicker.module.css'

type Props = {
  onFileSelected: (file: File | null) => void
  accept?: string
  disabled?: boolean
  label?: string
}

export default function FilePicker({ onFileSelected, accept, disabled, label='Choose file' }: Props) {
  const ref = useRef<HTMLInputElement>(null)
  return (
    <div className={styles.wrap}>
      <input
        ref={ref}
        type="file"
        className={styles.inputHidden}
        accept={accept}
        onChange={e => onFileSelected(e.target.files?.[0] || null)}
        disabled={disabled}
      />
      <Button onClick={() => ref.current?.click()} disabled={disabled}>{label}</Button>
    </div>
  )
}

// ===== shared/ui/Badge.tsx =====
import React from 'react'
import styles from './Badge.module.css'

type Props = React.HTMLAttributes<HTMLSpanElement> & {
  tone?: 'neutral' | 'success' | 'warn' | 'danger' | 'info'
  children: React.ReactNode
  className?: string
}

export default function Badge({ tone='neutral', className='', children, ...rest }: Props) {
  return <span {...rest} className={[styles.badge, styles[tone], className].join(' ')}>{children}</span>
}

// ===== shared/ui/Button.tsx =====
import React from 'react'
import styles from './Button.module.css'

type Props = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: 'primary' | 'ghost' | 'danger'
  size?: 'md' | 'sm' | 'small'
}

export default function Button({ variant='primary', size='md', className='', ...rest }: Props) {
  const sizeClass = size === 'small' ? 'sm' : size
  const cls = [styles.btn, styles[variant], styles[sizeClass], className].join(' ')
  return <button {...rest} className={cls} />
}

// ===== shared/ui/Modal.tsx =====
import React from 'react'
import styles from './Modal.module.css'
import Button from './Button'

type Size = 'md' | 'half'

type Props = {
  open: boolean
  title?: string
  onClose: () => void
  footer?: React.ReactNode
  children?: React.ReactNode
  size?: Size
}

export default function Modal({ open, title, onClose, children, footer, size='md' }: Props) {
  if (!open) return null
  return (
    <div className={styles.backdrop} onClick={onClose}>
      <div className={[styles.modal, size==='half' ? styles.half : ''].join(' ')} onClick={e=>e.stopPropagation()}>
        <div className={styles.head}>
          <div className={styles.title}>{title}</div>
          <Button size="sm" variant="ghost" onClick={onClose}>✕</Button>
        </div>
        <div className={styles.body}>{children}</div>
        {footer && <div className={styles.foot}>{footer}</div>}
      </div>
    </div>
  )
}

// ===== shared/ui/Select.tsx =====
import React from 'react'
import styles from './Select.module.css'

type Props = React.SelectHTMLAttributes<HTMLSelectElement> & { containerClassName?: string }

const Select = React.forwardRef<HTMLSelectElement, Props>(({ containerClassName, className, children, ...rest }, ref) => {
  return (
    <span className={[styles.root, containerClassName||''].join(' ')}>
      <select ref={ref} className={[styles.select, className||''].join(' ')} {...rest}>
        {children}
      </select>
      <svg className={styles.arrow} width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
      </svg>
    </span>
  )
})
Select.displayName = 'Select'
export default Select

// ===== shared/ui/Textarea.tsx =====
import React from 'react'
import styles from './Textarea.module.css'

type Props = React.TextareaHTMLAttributes<HTMLTextAreaElement>

const Textarea = React.forwardRef<HTMLTextAreaElement, Props>((props, ref) => {
  return <textarea {...props} ref={ref} className={[styles.textarea, props.className||''].join(' ')} />
})
Textarea.displayName = 'Textarea'

export default Textarea

// ===== shared/ui/Input.tsx =====
import React from 'react'
import styles from './Input.module.css'

type Props = React.InputHTMLAttributes<HTMLInputElement>

export default function Input(props: Props) {
  return <input {...props} className={[styles.input, props.className||''].join(' ')} />
}

// ===== shared/ui/ThemeSwitch.tsx =====
import React, { useEffect, useState } from 'react'

type Mode = 'light' | 'dark'
const KEY = 'theme'

function getInitial(): Mode {
  const saved = (localStorage.getItem(KEY) as Mode | null)
  if (saved === 'light' || saved === 'dark') return saved
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  return prefersDark ? 'dark' : 'light'
}

export default function ThemeSwitch() {
  const [mode, setMode] = useState<Mode>(getInitial())

  useEffect(() => {
    const root = document.documentElement
    if (mode === 'dark') {
      root.removeAttribute('data-theme') // было '' — убираем атрибут полностью
    } else {
      root.setAttribute('data-theme', 'light')
    }
    localStorage.setItem(KEY, mode)
  }, [mode])

  return (
    <button
      onClick={() => setMode(m => (m === 'dark' ? 'light' : 'dark'))}
      aria-label="Переключить тему"
      style={{
        background: 'transparent',
        border: '1px solid rgba(255,255,255,.15)',
        color: 'inherit',
        borderRadius: 12,
        padding: '6px 10px',
        cursor: 'pointer'
      }}
    >
      {mode === 'light' ? '☀️ Light' : '🌙 Dark'}
    </button>
  )
}

// ===== shared/ui/ErrorBoundary.tsx =====
import React from 'react'

type State = { hasError: boolean, error?: any }
export default class ErrorBoundary extends React.Component<React.PropsWithChildren, State> {
  state: State = { hasError: false }
  static getDerivedStateFromError(error: any) { return { hasError: true, error } }
  componentDidCatch(error: any, errorInfo: any) { console.error('UI error:', error, errorInfo) }
  render() {
    if (this.state.hasError) {
      return (
        <div style={{padding:24}}>
          <h2>Что-то пошло не так</h2>
          <div style={{opacity:.7, fontSize:14}}>{String(this.state.error || '')}</div>
          <button onClick={()=>this.setState({hasError:false, error: undefined})} style={{marginTop:12}}>Перезагрузить вид</button>
        </div>
      )
    }
    return this.props.children
  }
}

// ===== app/contexts/ChatContext.tsx =====
import React, { createContext, useContext, useReducer, useEffect, useRef } from 'react'
import * as chatsApi from '@shared/api/chats'
import type { Chat, ChatMessage } from '@shared/api/types'

type MessagesState = {
  items: ChatMessage[]
  nextCursor: string | null
  hasMore: boolean
  loaded: boolean
}

type ChatState = {
  isLoading: boolean
  error: string | null
  chatsOrder: string[]
  chatsById: Record<string, Chat>
  messagesByChat: Record<string, MessagesState>
  currentChatId: string | null
}

type ChatAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_CHATS'; payload: Chat[] }
  | { type: 'UPSERT_CHAT'; payload: Chat }
  | { type: 'DELETE_CHAT'; payload: string }
  | { type: 'SET_CURRENT_CHAT'; payload: string | null }
  | { type: 'SET_MESSAGES'; payload: { chatId: string; items: ChatMessage[]; nextCursor: string | null; hasMore: boolean } }
  | { type: 'APPEND_MESSAGES'; payload: { chatId: string; items: ChatMessage[]; nextCursor: string | null; hasMore: boolean } }
  | { type: 'ADD_MESSAGE'; payload: { chatId: string; item: ChatMessage } }
  | { type: 'UPDATE_CHAT_PARTIAL'; payload: { chatId: string; patch: Partial<Chat> } }

const initialState: ChatState = {
  isLoading: false,
  error: null,
  chatsOrder: [],
  chatsById: {},
  messagesByChat: {},
  currentChatId: null,
}

function reducer(state: ChatState, action: ChatAction): ChatState {
  switch (action.type) {
    case 'SET_LOADING': return { ...state, isLoading: action.payload }
    case 'SET_ERROR': return { ...state, error: action.payload }
    case 'SET_CURRENT_CHAT': return { ...state, currentChatId: action.payload }

    case 'SET_CHATS': {
      const byId: Record<string, Chat> = {}
      const order: string[] = []
      for (const c of action.payload) {
        byId[c.id] = c
        order.push(c.id)
      }
      return { ...state, chatsById: byId, chatsOrder: order }
    }

    case 'UPSERT_CHAT': {
      const id = action.payload.id
      const exists = !!state.chatsById[id]
      const chatsById = { ...state.chatsById, [id]: { ...state.chatsById[id], ...action.payload } }
      const chatsOrder = exists ? state.chatsOrder : [id, ...state.chatsOrder]
      return { ...state, chatsById, chatsOrder }
    }

    case 'DELETE_CHAT': {
      const { [action.payload]: _omit, ...rest } = state.chatsById
      return { ...state, chatsById: rest, chatsOrder: state.chatsOrder.filter(id => id !== action.payload) }
    }

    case 'SET_MESSAGES': {
      const { chatId, items, nextCursor, hasMore } = action.payload
      const messagesByChat = { ...state.messagesByChat, [chatId]: { items, nextCursor, hasMore, loaded: true } }
      return { ...state, messagesByChat }
    }

    case 'APPEND_MESSAGES': {
      const { chatId, items, nextCursor, hasMore } = action.payload
      const prev = state.messagesByChat[chatId] || { items: [], nextCursor: null, hasMore: false, loaded: false }
      const merged = [...prev.items, ...items]
      return { ...state, messagesByChat: { ...state.messagesByChat, [chatId]: { items: merged, nextCursor, hasMore, loaded: true } } }
    }

    case 'ADD_MESSAGE': {
      const { chatId, item } = action.payload
      const prev = state.messagesByChat[chatId] || { items: [], nextCursor: null, hasMore: false, loaded: false }
      return { ...state, messagesByChat: { ...state.messagesByChat, [chatId]: { ...prev, items: [...prev.items, item], loaded: true } } }
    }

    case 'UPDATE_CHAT_PARTIAL': {
      const { chatId, patch } = action.payload
      const chat = state.chatsById[chatId]
      if (!chat) return state
      return { ...state, chatsById: { ...state.chatsById, [chatId]: { ...chat, ...patch } } }
    }
  }
}

type ChatContextValue = {
  state: ChatState
  loadChats: () => Promise<void>
  loadChatsIfAuthenticated: () => Promise<void>
  createChat: (name?: string | null, tags?: string[] | null) => Promise<string>
  renameChat: (chatId: string, name: string) => Promise<void>
  deleteChat: (chatId: string) => Promise<void>
  removeChatLocal: (chatId: string) => void
  restoreChatLocal: (chat: Chat) => void
  deleteChatApiOnly: (chatId: string) => Promise<void>
  updateChatTags: (chatId: string, tags: string[]) => Promise<void>
  setCurrentChat: (chatId: string | null) => void
  loadMessages: (chatId: string, append?: boolean) => Promise<void>
  sendMessage: (chatId: string, content: string, useRag?: boolean) => Promise<string>
  sendMessageStream: (chatId: string, content: string, onDelta: (chunk: string) => void, useRag?: boolean) => Promise<void>
}

const ChatContext = createContext<ChatContextValue | undefined>(undefined)

export function ChatProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(reducer, initialState)
  const bootRef = useRef(false)

  async function loadChats() {
    dispatch({ type: 'SET_LOADING', payload: true })
    try {
      const res = await chatsApi.listChats({ limit: 100 })
      dispatch({ type: 'SET_CHATS', payload: res.items })
      dispatch({ type: 'SET_ERROR', payload: null })
    } catch (e: any) {
      dispatch({ type: 'SET_ERROR', payload: e?.message || 'failed_to_load_chats' })
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false })
    }
  }

  async function loadChatsIfAuthenticated() {
    const token = (window as any).__auth_tokens?.access_token || localStorage.getItem('access_token')
    if (token) {
      await loadChats()
    }
  }

  useEffect(() => {
    if (bootRef.current) return
    bootRef.current = true
    loadChatsIfAuthenticated()
  }, [])

  async function createChat(name?: string | null, tags?: string[] | null) {
    const res = await chatsApi.createChat(name ?? null, tags ?? null)
    const chatId = res.chat_id
    // optimistic
    dispatch({ type: 'UPSERT_CHAT', payload: { id: chatId, name: name ?? null, tags: tags ?? null } as Chat })
    return chatId
  }

  async function renameChat(chatId: string, name: string) {
    await chatsApi.renameChat(chatId, name)
    dispatch({ type: 'UPDATE_CHAT_PARTIAL', payload: { chatId, patch: { name } } })
  }

  async function deleteChat(chatId: string) {
    await chatsApi.deleteChat(chatId)
    dispatch({ type: 'DELETE_CHAT', payload: chatId })
    if (state.currentChatId === chatId) dispatch({ type: 'SET_CURRENT_CHAT', payload: null })
  }

function removeChatLocal(chatId: string) {
  dispatch({ type: 'DELETE_CHAT', payload: chatId })
  if (state.currentChatId === chatId) dispatch({ type: 'SET_CURRENT_CHAT', payload: null })
}

function restoreChatLocal(chat: Chat) {
  dispatch({ type: 'UPSERT_CHAT', payload: chat })
}

async function deleteChatApiOnly(chatId: string) {
  await chatsApi.deleteChat(chatId)
}

  async function updateChatTags(chatId: string, tags: string[]) {
    await chatsApi.updateChatTags(chatId, tags)
    dispatch({ type: 'UPDATE_CHAT_PARTIAL', payload: { chatId, patch: { tags } } })
  }

  function setCurrentChat(chatId: string | null) {
    dispatch({ type: 'SET_CURRENT_CHAT', payload: chatId })
  }

  async function loadMessages(chatId: string, append?: boolean) {
    const cur = state.messagesByChat[chatId]
    if (!append && cur?.loaded) return // avoid duplicate initial load
    const res = await chatsApi.listMessages(chatId, append ? { cursor: cur?.nextCursor || undefined } : {})
    const items = res.items
    const next = res.next_cursor ?? null
    const hasMore = !!next && items.length > 0
    dispatch({ type: append ? 'APPEND_MESSAGES' : 'SET_MESSAGES', payload: { chatId, items, nextCursor: next, hasMore } })
  }

  async function sendMessage(chatId: string, content: string, useRag?: boolean) {
    const res = await chatsApi.sendMessage(chatId, { content, use_rag: !!useRag })
    const userMsg: ChatMessage = { id: res.message_id, chat_id: chatId, role: 'user', content }
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: userMsg } })
    const assistantMsg: ChatMessage = { id: crypto.randomUUID(), chat_id: chatId, role: 'assistant', content: res.answer }
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: assistantMsg } })
    return res.message_id
  }

  async function sendMessageStream(chatId: string, content: string, onDelta: (chunk: string) => void, useRag?: boolean) {
    // add user message immediately
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: { id: crypto.randomUUID(), chat_id: chatId, role: 'user', content } } })
    let acc = ''
    for await (const chunk of chatsApi.sendMessageStream(chatId, { content, use_rag: !!useRag })) {
      acc += chunk
      onDelta(acc)
    }
    // push final assistant message
    dispatch({ type: 'ADD_MESSAGE', payload: { chatId, item: { id: crypto.randomUUID(), chat_id: chatId, role: 'assistant', content: acc } } })
  }

  const value: ChatContextValue = {
    state,
    loadChats,
    loadChatsIfAuthenticated,
    createChat,
    renameChat,
    deleteChat,
    removeChatLocal,
    restoreChatLocal,
    deleteChatApiOnly,
    updateChatTags,
    setCurrentChat,
    loadMessages,
    sendMessage,
    sendMessageStream,
  }

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>
}

export function useChat() {
  const ctx = useContext(ChatContext)
  if (!ctx) throw new Error('useChat must be used within ChatProvider')
  return ctx
}

// ===== app/components/AccessibleButton.tsx =====
import React from 'react'
import Button from '@shared/ui/Button'
import styles from './AccessibleButton.module.css'

interface AccessibleButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'ghost' | 'danger'
  size?: 'md' | 'sm' | 'small'
  loading?: boolean
  icon?: React.ReactNode
  children: React.ReactNode
  ariaLabel?: string
  ariaDescribedBy?: string
  ariaExpanded?: boolean
  ariaControls?: string
  ariaPressed?: boolean
}

const AccessibleButton = React.forwardRef<HTMLButtonElement, AccessibleButtonProps>(
  ({
    variant = 'primary',
    size = 'md',
    loading = false,
    icon,
    children,
    ariaLabel,
    ariaDescribedBy,
    ariaExpanded,
    ariaControls,
    ariaPressed,
    disabled,
    className = '',
    ...rest
  }, ref) => {
    const sizeClass = size === 'small' ? 'sm' : size
    const cls = [styles.btn, styles[variant], styles[sizeClass], className].join(' ')
    
    return (
      <button
        ref={ref}
        className={cls}
        disabled={disabled || loading}
        aria-label={ariaLabel}
        aria-describedby={ariaDescribedBy}
        aria-expanded={ariaExpanded}
        aria-controls={ariaControls}
        aria-pressed={ariaPressed}
        aria-busy={loading}
        {...rest}
      >
        {loading && (
          <span 
            className={styles.spinner} 
            aria-hidden="true"
            role="status"
          />
        )}
        {icon && !loading && (
          <span className={styles.icon} aria-hidden="true">
            {icon}
          </span>
        )}
        <span className={loading ? styles.hidden : ''}>
          {children}
        </span>
      </button>
    )
  }
)

AccessibleButton.displayName = 'AccessibleButton'

export default AccessibleButton

// ===== app/components/ChatStatus.tsx =====
import React from 'react'
import { useChat } from '../contexts/ChatContext'
import styles from './ChatStatus.module.css'

export default function ChatStatus() {
  const { state } = useChat()
  const { error, isLoading } = state

  if (!error && !isLoading) return null

  return (
    <div className={styles.statusBar}>
      {isLoading && (
        <div className={styles.loading}>
          <div className={styles.spinner} />
          Загрузка...
        </div>
      )}
      {error && (
        <div className={styles.error}>
          ⚠️ {error}
        </div>
      )}
    </div>
  )
}

// ===== app/components/ChatTags.tsx =====
import React, { useState } from 'react'
import Modal from '@shared/ui/Modal'
import Input from '@shared/ui/Input'
import Button from '@shared/ui/Button'

export default function ChatTags({ chatId, tags, onTagsChange }: { chatId: string, tags: string[], onTagsChange: (tags: string[]) => void }) {
  const [local, setLocal] = useState<string[]>(tags || [])
  const [open, setOpen] = useState(true)
  const [draft, setDraft] = useState('')

  function add() {
    const t = draft.trim()
    if (!t) return
    if (local.includes(t)) return
    setLocal([...local, t])
    setDraft('')
  }
  function remove(t: string) {
    setLocal(local.filter(x => x !== t))
  }

  return (
    <Modal open={open} onClose={() => setOpen(false)} title="Теги"
      footer={<>
        <Button variant="ghost" onClick={() => setOpen(false)}>Закрыть</Button>
        <Button onClick={() => { onTagsChange(local); setOpen(false) }}>Сохранить</Button>
      </>}
    >
      <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8 }}>
        <Input value={draft} onChange={e => setDraft(e.target.value)} placeholder="Новый тег" onKeyDown={e => { if (e.key === 'Enter') add() }} />
        <Button onClick={add}>Добавить</Button>
      </div>
      <div style={{ display: 'flex', gap: 6, flexWrap: 'wrap' }}>
        {local.map(t => (
          <span key={t} style={{ border: '1px solid rgba(255,255,255,.2)', padding: '2px 8px', borderRadius: 999 }}>
            {t} <button onClick={() => remove(t)} style={{ marginLeft: 6, opacity: .7 }}>×</button>
          </span>
        ))}
        {local.length === 0 && <div style={{ opacity: .7 }}>Пока пусто</div>}
      </div>
    </Modal>
  )
}

// ===== app/components/ChatSearch.tsx =====
import React, { useState, useMemo } from 'react'
import { useChat } from '../contexts/ChatContext'
import Input from '@shared/ui/Input'
import styles from './ChatSearch.module.css'

export default function ChatSearch() {
  const { state } = useChat()
  const [searchQuery, setSearchQuery] = useState('')
  
  const filteredChats = useMemo(() => {
    if (!searchQuery.trim()) return state.chatsOrder.map(id => state.chatsById[id])
    
    const query = searchQuery.toLowerCase()
    return state.chatsOrder.map(id => state.chatsById[id]).filter(chat => 
      chat.name?.toLowerCase().includes(query) ||
      (state.messagesByChat[chat.id]?.items || []).some(msg => 
        msg.content.toLowerCase().includes(query)
      )
    )
  }, [state.chatsOrder, state.chatsById, state.messagesByChat, searchQuery])

  return (
    <div className={styles.searchContainer}>
      <Input
        value={searchQuery}
        onChange={e => setSearchQuery(e.target.value)}
        placeholder="Поиск по чатам и сообщениям..."
        className={styles.searchInput}
      />
      {searchQuery && (
        <div className={styles.searchResults}>
          <div className={styles.resultsHeader}>
            Найдено чатов: {filteredChats.length}
          </div>
          {filteredChats.map(chat => {
            const messages = state.messagesByChat[chat.id]?.items || []
            return (
              <div key={chat.id} className={styles.chatResult}>
                <div className={styles.chatName}>{chat.name || 'Untitled'}</div>
                <div className={styles.chatPreview}>
                  {messages.length > 0 
                    ? messages[messages.length - 1].content.slice(0, 100) + '...'
                    : 'Нет сообщений'
                  }
                </div>
              </div>
            )
          })}
        </div>
      )}
    </div>
  )
}

// ===== app/components/ChatStats.tsx =====
import React from 'react'
import { useChat } from '../contexts/ChatContext'
import styles from './ChatStats.module.css'

export default function ChatStats() {
  const { state } = useChat()

  const stats = React.useMemo(() => {
    const chatList = state.chatsOrder.map(id => state.chatsById[id])
    const totalMessages = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.length
    }, 0)
    
    const userMessages = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.filter(msg => msg.role === 'user').length
    }, 0)
    
    const assistantMessages = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.filter(msg => msg.role === 'assistant').length
    }, 0)
    
    const totalWords = chatList.reduce((sum, chat) => {
      const messages = state.messagesByChat[chat.id]?.items || []
      return sum + messages.reduce((msgSum, msg) => 
        msgSum + msg.content.split(' ').length, 0
      )
    }, 0)

    const averageMessagesPerChat = chatList.length > 0 ? Math.round(totalMessages / chatList.length) : 0
    const averageWordsPerMessage = totalMessages > 0 ? Math.round(totalWords / totalMessages) : 0

    return {
      totalChats: chatList.length,
      totalMessages,
      userMessages,
      assistantMessages,
      totalWords,
      averageMessagesPerChat,
      averageWordsPerMessage
    }
  }, [state.chatsOrder, state.chatsById, state.messagesByChat])

  return (
    <div className={styles.statsContainer}>
      <h4 className={styles.statsTitle}>Статистика чатов</h4>
      
      <div className={styles.statsGrid}>
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.totalChats}</div>
          <div className={styles.statLabel}>Всего чатов</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.totalMessages}</div>
          <div className={styles.statLabel}>Всего сообщений</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.userMessages}</div>
          <div className={styles.statLabel}>Сообщений пользователя</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.assistantMessages}</div>
          <div className={styles.statLabel}>Ответов ассистента</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.totalWords.toLocaleString()}</div>
          <div className={styles.statLabel}>Всего слов</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.averageMessagesPerChat}</div>
          <div className={styles.statLabel}>Среднее сообщений на чат</div>
        </div>
        
        <div className={styles.statItem}>
          <div className={styles.statValue}>{stats.averageWordsPerMessage}</div>
          <div className={styles.statLabel}>Среднее слов на сообщение</div>
        </div>
      </div>
    </div>
  )
}

// ===== app/components/OptimizedChatMessage.tsx =====
import React, { memo, useMemo } from 'react'
import { ChatMessage } from '../store/useChatStore'
import styles from './OptimizedChatMessage.module.css'

interface OptimizedChatMessageProps {
  message: ChatMessage
  index: number
}

const OptimizedChatMessage = memo<OptimizedChatMessageProps>(({ message, index }) => {
  const messageContent = useMemo(() => {
    return message.content
  }, [message.content])
  
  const messageTime = useMemo(() => {
    return message.created_at ? new Date(message.created_at).toLocaleTimeString() : null
  }, [message.created_at])
  
  const messageClass = useMemo(() => {
    return message.role === 'user' ? styles.user : styles.assistant
  }, [message.role])
  
  return (
    <div className={messageClass}>
      <div className={styles.messageContent}>{messageContent}</div>
      {messageTime && (
        <div className={styles.messageTime}>
          {messageTime}
        </div>
      )}
    </div>
  )
})

OptimizedChatMessage.displayName = 'OptimizedChatMessage'

export default OptimizedChatMessage

// ===== app/components/ChatExport.tsx =====
import React, { useState } from 'react'
import { useChat } from '../contexts/ChatContext'
import Button from '@shared/ui/Button'
import Modal from '@shared/ui/Modal'
import styles from './ChatExport.module.css'

export default function ChatExport() {
  const { state } = useChat()
  const [isOpen, setIsOpen] = useState(false)
  const [exportFormat, setExportFormat] = useState<'json' | 'txt' | 'md'>('json')

  const exportChats = () => {
    const chats = state.chatsOrder.map(id => state.chatsById[id])
    
    if (exportFormat === 'json') {
      const data = chats.map(chat => ({
        id: chat.id,
        name: chat.name,
        created_at: chat.created_at,
        messages: (state.messagesByChat[chat.id]?.items || []).map(msg => ({
          role: msg.role,
          content: msg.content,
          created_at: msg.created_at
        }))
      }))
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `chats_export_${new Date().toISOString().split('T')[0]}.json`
      a.click()
      URL.revokeObjectURL(url)
    } else if (exportFormat === 'txt') {
      const content = chats.map(chat => {
        let text = `=== ${chat.name || 'Untitled'} ===\n`
        text += `Created: ${chat.created_at ? new Date(chat.created_at).toLocaleString() : 'Unknown'}\n\n`
        
        const messages = state.messagesByChat[chat.id]?.items || []
        messages.forEach(msg => {
          text += `${msg.role.toUpperCase()}: ${msg.content}\n\n`
        })
        
        return text
      }).join('\n' + '='.repeat(50) + '\n\n')
      
      const blob = new Blob([content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `chats_export_${new Date().toISOString().split('T')[0]}.txt`
      a.click()
      URL.revokeObjectURL(url)
    } else if (exportFormat === 'md') {
      const content = chats.map(chat => {
        let md = `# ${chat.name || 'Untitled'}\n\n`
        md += `**Created:** ${chat.created_at ? new Date(chat.created_at).toLocaleString() : 'Unknown'}\n\n`
        
        const messages = state.messagesByChat[chat.id]?.items || []
        messages.forEach(msg => {
          md += `## ${msg.role === 'user' ? '👤 User' : '🤖 Assistant'}\n\n`
          md += `${msg.content}\n\n`
        })
        
        return md
      }).join('\n---\n\n')
      
      const blob = new Blob([content], { type: 'text/markdown' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `chats_export_${new Date().toISOString().split('T')[0]}.md`
      a.click()
      URL.revokeObjectURL(url)
    }
    
    setIsOpen(false)
  }

  return (
    <>
      <Button 
        onClick={() => setIsOpen(true)}
        size="small"
        variant="ghost"
        title="Экспорт чатов"
      >
        📤
      </Button>

      <Modal 
        open={isOpen} 
        onClose={() => setIsOpen(false)} 
        title="Экспорт чатов"
        footer={
          <>
            <Button variant="ghost" onClick={() => setIsOpen(false)}>
              Отмена
            </Button>
            <Button onClick={exportChats}>
              Экспортировать
            </Button>
          </>
        }
      >
        <div className={styles.exportOptions}>
          <p>Выберите формат экспорта:</p>
          
          <div className={styles.formatOptions}>
            <label className={styles.formatOption}>
              <input
                type="radio"
                name="format"
                value="json"
                checked={exportFormat === 'json'}
                onChange={e => setExportFormat(e.target.value as 'json')}
              />
              <span>JSON (полные данные)</span>
            </label>
            
            <label className={styles.formatOption}>
              <input
                type="radio"
                name="format"
                value="txt"
                checked={exportFormat === 'txt'}
                onChange={e => setExportFormat(e.target.value as 'txt')}
              />
              <span>TXT (текстовый формат)</span>
            </label>
            
            <label className={styles.formatOption}>
              <input
                type="radio"
                name="format"
                value="md"
                checked={exportFormat === 'md'}
                onChange={e => setExportFormat(e.target.value as 'md')}
              />
              <span>Markdown (для документации)</span>
            </label>
          </div>
          
          <div className={styles.exportInfo}>
            <p>Будет экспортировано чатов: <strong>{state.chatsOrder.length}</strong></p>
            <p>Общее количество сообщений: <strong>
              {state.chatsOrder.reduce((sum, chatId) => sum + (state.messagesByChat[chatId]?.items.length || 0), 0)}
            </strong></p>
          </div>
        </div>
      </Modal>
    </>
  )
}

// ===== app/components/EmptyState.tsx =====
import React from 'react'

export default function EmptyState({ title, description, action }: { title: string, description?: string, action?: React.ReactNode }) {
  return (
    <div style={{ display: 'grid', placeItems: 'center', minHeight: 260, textAlign: 'center', gap: 8 }}>
      <div style={{ fontWeight: 600, fontSize: 18 }}>{title}</div>
      {description && <div style={{ opacity: .75 }}>{description}</div>}
      {action}
    </div>
  )
}

// ===== app/components/ErrorBoundary.tsx =====
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo)
    this.props.onError?.(error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }

      return (
        <div className="error-boundary">
          <div className="error-content">
            <h2>Что-то пошло не так</h2>
            <p>Произошла неожиданная ошибка. Пожалуйста, обновите страницу.</p>
            <details>
              <summary>Детали ошибки</summary>
              <pre>{this.state.error?.stack}</pre>
            </details>
            <button 
              onClick={() => window.location.reload()}
              className="retry-button"
            >
              Обновить страницу
            </button>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

// Hook version for functional components
export function useErrorHandler() {
  return (error: Error, errorInfo?: ErrorInfo) => {
    console.error('Error caught by useErrorHandler:', error, errorInfo)
    // You can add error reporting here
  }
}

// ===== app/routes/Login.tsx =====
import React, { useState } from 'react'
import { useAuth } from '@app/store/auth'
import { useNavigate } from 'react-router-dom'
import Button from '@shared/ui/Button'
import Input from '@shared/ui/Input'
import Card from '@shared/ui/Card'
import styles from './Login.module.css'

export default function Login() {
  const nav = useNavigate()
  const { login, loading } = useAuth()
  const [form, setForm] = useState({ login: '', password: '' })
  const [error, setError] = useState<string | null>(null)

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    setError(null)
    try {
      await login(form.login, form.password)
      nav('/gpt/chat')
    } catch (e: any) {
      setError(e.message || 'Ошибка входа')
    }
  }
  return (
    <div className={styles.wrap}>
      <Card className={styles.card}>
        <h1>Войти</h1>
        <form className="stack" onSubmit={onSubmit}>
          <label>Логин</label>
          <Input placeholder="user" value={form.login} onChange={e=>setForm(f=>({ ...f, login:e.target.value }))} />
          <label>Пароль</label>
          <Input type="password" placeholder="••••••••" value={form.password} onChange={e=>setForm(f=>({ ...f, password:e.target.value }))} />
          {error && <div className={styles.error}>{error}</div>}
          <Button type="submit" disabled={loading}>{loading ? '…' : 'Войти'}</Button>
        </form>
      </Card>
    </div>
  )
}

// ===== app/routes/GPTGate.tsx =====
import React, { useEffect, useState } from 'react'
import { useAuth } from '@app/store/auth'
import { useNavigate } from 'react-router-dom'

export default function GPTGate({ children }: { children: React.ReactNode }) {
  const { user, fetchMe } = useAuth()
  const [checked, setChecked] = useState(false)
  const nav = useNavigate()

  useEffect(() => {
    (async () => {
      try { await fetchMe() } finally { setChecked(true) }
    })()
  }, [])

  useEffect(() => {
    if (checked && !user) nav('/login')
  }, [checked, user])

  if (!checked) return null
  if (!user) return null
  return <>{children}</>
}

// ===== app/routes/NotFound.tsx =====
import React from 'react'
import { Link } from 'react-router-dom'
import Card from '@shared/ui/Card'

export default function NotFound() {
  return (
    <div style={{display:'grid', placeItems:'center', minHeight:'60vh', padding:24}}>
      <Card>
        <h2>Страница не найдена</h2>
        <p>Мы не нашли такую страницу. Перейти в <Link to="/gpt/chat">чат</Link> или <Link to="/login">войти</Link>.</p>
      </Card>
    </div>
  )
}

// ===== app/routes/gpt/Doc.tsx =====
import React from 'react'
import Card from '@shared/ui/Card'

export default function Doc() {
  return (
    <Card>
      <h2>RAG Documents</h2>
      <p>Здесь позже появится список / загрузка / поиск.</p>
    </Card>
  )
}

// ===== app/routes/gpt/Analyze.tsx =====
import React, { useState, useEffect } from 'react'
import Card from '@shared/ui/Card'
import Button from '@shared/ui/Button'
import FilePicker from '@shared/ui/FilePicker'
import * as analyze from '@shared/api/analyze'
import { AnalyzeDocument } from '@shared/api/types'
import styles from './AnalyzePage.module.css'

export default function Analyze() {
  const [documents, setDocuments] = useState<AnalyzeDocument[]>([])
  const [loading, setLoading] = useState(false)
  const [uploading, setUploading] = useState(false)

  useEffect(() => {
    loadDocuments()
  }, [])

  const loadDocuments = async () => {
    setLoading(true)
    try {
      const res = await analyze.listAnalyze()
      setDocuments(res.items || [])
    } catch (error) {
      console.error('Failed to load documents:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleFileUpload = async (file: File) => {
    setUploading(true)
    try {
      await analyze.uploadAnalysisFile(file)
      await loadDocuments()
    } catch (error) {
      console.error('Failed to upload file:', error)
      alert('Ошибка загрузки файла')
    } finally {
      setUploading(false)
    }
  }

  const handleDownload = async (doc: AnalyzeDocument, kind: 'original' | 'canonical' = 'original') => {
    try {
      const res = await analyze.downloadAnalysisFile(doc.id, kind)
      if (res.url) {
        window.open(res.url, '_blank')
      }
    } catch (error) {
      console.error('Download failed:', error)
    }
  }

  const handleDelete = async (doc: AnalyzeDocument) => {
    if (!confirm('Удалить документ?')) return
    try {
      await analyze.deleteAnalysisFile(doc.id)
      await loadDocuments()
    } catch (error) {
      console.error('Delete failed:', error)
      alert('Ошибка удаления документа')
    }
  }

  const handleReanalyze = async (doc: AnalyzeDocument) => {
    if (!confirm('Повторно проанализировать документ?')) return
    try {
      await analyze.reanalyzeFile(doc.id)
      await loadDocuments()
    } catch (error) {
      console.error('Reanalyze failed:', error)
      alert('Ошибка повторного анализа')
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'done': return '#4caf50'
      case 'processing': return '#ff9800'
      case 'error': return '#f44336'
      case 'canceled': return '#9e9e9e'
      default: return '#2196f3'
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'queued': return 'В очереди'
      case 'processing': return 'Обработка'
      case 'done': return 'Готов'
      case 'error': return 'Ошибка'
      case 'canceled': return 'Отменен'
      default: return status
    }
  }

  return (
    <div className={styles.container}>
      <Card className={styles.uploadCard}>
        <h3>Загрузка файла для анализа</h3>
        <FilePicker
          onFileSelected={(file) => file && handleFileUpload(file)}
          accept=".txt,.pdf,.doc,.docx,.md,.rtf,.odt"
          disabled={uploading}
        />
        {uploading && <p>Загрузка...</p>}
      </Card>

      <Card className={styles.documentsCard}>
        <h3>Документы на анализе ({documents.length})</h3>
        {loading ? (
          <p>Загрузка...</p>
        ) : documents.length === 0 ? (
          <p>Нет документов</p>
        ) : (
          <div className={styles.documentsList}>
            {documents.map(doc => (
              <div key={doc.id} className={styles.documentItem}>
                <div className={styles.documentInfo}>
                  <div className={styles.documentName}>
                    Документ {doc.id.slice(0, 8)}
                  </div>
                  <div className={styles.documentStatus}>
                    <span 
                      className={styles.statusBadge}
                      style={{ backgroundColor: getStatusColor(doc.status) }}
                    >
                      {getStatusText(doc.status)}
                    </span>
                    {doc.error && (
                      <span className={styles.errorText}>
                        {doc.error}
                      </span>
                    )}
                  </div>
                  <div className={styles.documentDate}>
                    {doc.date_upload && new Date(doc.date_upload).toLocaleString()}
                  </div>
                  {doc.result && (
                    <div className={styles.resultPreview}>
                      <strong>Результат:</strong>
                      <pre>{JSON.stringify(doc.result, null, 2)}</pre>
                    </div>
                  )}
                </div>
                <div className={styles.documentActions}>
                  {doc.status === 'done' && (
                    <>
                      <Button 
                        size="small" 
                        onClick={() => handleDownload(doc, 'original')}
                      >
                        Скачать оригинал
                      </Button>
                      {doc.url_canonical_file && (
                        <Button 
                          size="small" 
                          onClick={() => handleDownload(doc, 'canonical')}
                        >
                          Скачать каноническую форму
                        </Button>
                      )}
                      <Button 
                        size="small" 
                        onClick={() => handleReanalyze(doc)}
                        title="Повторно проанализировать"
                      >
                        🔄
                      </Button>
                    </>
                  )}
                  <Button 
                    size="small" 
                    variant="danger"
                    onClick={() => handleDelete(doc)}
                  >
                    Удалить
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}
      </Card>
    </div>
  )
}

// ===== app/routes/gpt/Rag.tsx =====
import React, { useEffect, useMemo, useState } from 'react'
import Card from '@shared/ui/Card'
import Input from '@shared/ui/Input'
import Button from '@shared/ui/Button'
import Badge from '@shared/ui/Badge'
import Modal from '@shared/ui/Modal'
import Popover from '@shared/ui/Popover'
import { FilterIcon, MoreVerticalIcon, DownloadIcon, RefreshIcon, ArchiveIcon, TrashIcon } from '@shared/ui/Icon'
import Select from '@shared/ui/Select'
import FilePicker from '@shared/ui/FilePicker'
import * as rag from '@shared/api/rag'
import { RagDocument } from '@shared/api/types'
import styles from './Rag.module.css'

type ColKey = 'name' | 'status' | 'created_at' | 'tags'

export default function Rag() {
  const [items, setItems] = useState<RagDocument[]>([])
  const [busy, setBusy] = useState(false)
  const [q, setQ] = useState('')
  const [filters, setFilters] = useState<Partial<Record<ColKey, string>>>({})
  const [pop, setPop] = useState<{ open: boolean, col?: ColKey, anchor?: {x:number,y:number} }>({ open: false })
  const [openAdd, setOpenAdd] = useState(false)
  const [file, setFile] = useState<File | null>(null)
  const [uploadTags, setUploadTags] = useState<string[]>([])
  const [selectedDoc, setSelectedDoc] = useState<RagDocument | null>(null)
  const [actionMenuOpen, setActionMenuOpen] = useState(false)

  async function refresh() {
    const res = await rag.listDocs({ page: 1, size: 100 })
    setItems(res.items || [])
  }

  useEffect(() => {
    refresh()
  }, [])

  const rows = useMemo(() => {
    return (items||[]).filter(t => {
      const text = ((t.name||'') + ' ' + (t.status||'') + ' ' + (t.created_at||'') + ' ' + (t.tags?.join(' ')||'')).toLowerCase()
      if (q.trim() && !text.includes(q.toLowerCase())) return false
      if (filters.name && !(t.name||'').toLowerCase().includes((filters.name||'').toLowerCase())) return false
      if (filters.status && t.status !== filters.status) return false
      if (filters.tags && !(t.tags?.join(' ')||'').toLowerCase().includes((filters.tags||'').toLowerCase())) return false
      if (filters.created_at && !(t.created_at||'').toLowerCase().includes((filters.created_at||'').toLowerCase())) return false
      return true
    })
  }, [items, q, filters])

  function openFilter(col: ColKey, el: HTMLElement) {
    const r = el.getBoundingClientRect()
    setPop({ open: true, col, anchor: { x: r.left, y: r.bottom + 6 } })
  }
  function clearAll() { setFilters({}); setPop({ open:false }) }

  async function doUpload() {
    if (!file) return
    setBusy(true)
    try {
      await rag.uploadFile(file, file.name, uploadTags)
      setOpenAdd(false)
      setFile(null)
      setUploadTags([])
      await refresh()
    } finally { setBusy(false) }
  }

  const handleDownload = async (doc: RagDocument, kind: 'original' | 'canonical' = 'original') => {
    try {
      const res = await rag.downloadRagFile(doc.id, kind)
      if (res.url) {
        window.open(res.url, '_blank')
      }
    } catch (error) {
      console.error('Download failed:', error)
    }
  }

  const handleArchive = async (doc: RagDocument) => {
    try {
      await rag.archiveRagDocument(doc.id)
      await refresh()
    } catch (error) {
      console.error('Archive failed:', error)
    }
  }

  const handleDelete = async (doc: RagDocument) => {
    if (!confirm('Удалить документ?')) return
    try {
      await rag.deleteRagDocument(doc.id)
      await refresh()
    } catch (error) {
      console.error('Delete failed:', error)
    }
  }

  const handleReindex = async (doc: RagDocument) => {
    if (!confirm('Переиндексировать документ?')) return
    try {
      await rag.reindexRagDocument(doc.id)
      await refresh()
    } catch (error) {
      console.error('Reindex failed:', error)
      alert('Ошибка переиндексации')
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'queued': return 'В очереди'
      case 'processing': return 'Обработка'
      case 'ready': return 'Готов'
      case 'error': return 'Ошибка'
      case 'archived': return 'Архив'
      default: return status
    }
  }

  const hasAnyFilter = Object.values(filters).some(Boolean)

  return (
    <div className={styles.wrap}>
      <Card className={styles.card}>
        <div className={styles.header}>
          <div className={styles.title}>База знаний — документы</div>
          <div className={styles.controls}>
            <Input className={styles.search} placeholder="Поиск…" value={q} onChange={e=>setQ(e.target.value)} />
            {hasAnyFilter && <Badge onClick={clearAll}>Сбросить фильтры</Badge>}
            <Button onClick={()=>setOpenAdd(true)}>Добавить</Button>
          </div>
        </div>

        <div className={styles.tableWrap}>
          <table className="table">
            <thead>
              <tr>
                <th>Название <button className="icon" type="button" aria-label="Фильтр по названию" onClick={(e)=>openFilter('name', e.currentTarget)}><FilterIcon/></button></th>
                <th>Статус <button className="icon" type="button" aria-label="Фильтр по статусу" onClick={(e)=>openFilter('status', e.currentTarget)}><FilterIcon/></button></th>
                <th>Теги <button className="icon" type="button" aria-label="Фильтр по тегам" onClick={(e)=>openFilter('tags', e.currentTarget)}><FilterIcon/></button></th>
                <th>Создано <button className="icon" type="button" aria-label="Фильтр по дате создания" onClick={(e)=>openFilter('created_at', e.currentTarget)}><FilterIcon/></button></th>
                <th>Действия</th>
              </tr>
            </thead>
            <tbody>
              {rows.map((t) => (
                <tr key={t.id}>
                  <td className="muted">{t.name || '—'}</td>
                  <td><Badge tone={t.status==='ready'?'success':t.status==='error'?'danger':t.status==='processing'?'warn':'neutral'}>{getStatusText(t.status)}</Badge></td>
                  <td>{t.tags?.join(', ') || '—'}</td>
                  <td className="muted">{t.created_at || '—'}</td>
                  <td>
                    <Popover
                      trigger={
                        <button 
                          className="icon" 
                          type="button" 
                          aria-label="Действия"
                          onClick={() => {
                            setSelectedDoc(t)
                            setActionMenuOpen(true)
                          }}
                        >
                          <MoreVerticalIcon/>
                        </button>
                      }
                      content={
                        <div className="stack" style={{minWidth: 180}}>
                          {t.status === 'ready' && (
                            <>
                              <Button size="sm" variant="ghost" onClick={() => handleDownload(t, 'original')}>
                                <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                  <DownloadIcon size={12}/>
                                </span>
                                Скачать документ
                              </Button>
                              {t.url_canonical_file && (
                                <Button size="sm" variant="ghost" onClick={() => handleDownload(t, 'canonical')}>
                                  <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                    <DownloadIcon size={12}/>
                                  </span>
                                  Скачать канонический вид
                                </Button>
                              )}
                              <Button size="sm" variant="ghost" onClick={() => handleReindex(t)}>
                                <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                  <RefreshIcon size={12}/>
                                </span>
                                Пересчитать
                              </Button>
                              <Button size="sm" variant="ghost" onClick={() => handleArchive(t)}>
                                <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                                  <ArchiveIcon size={12}/>
                                </span>
                                Заархивировать
                              </Button>
                            </>
                          )}
                          <Button size="sm" variant="ghost" onClick={() => handleDelete(t)}>
                            <span style={{marginRight: 6, display: 'inline-flex', alignItems: 'center'}}>
                              <TrashIcon size={12}/>
                            </span>
                            Удалить
                          </Button>
                        </div>
                      }
                      align="end"
                    />
                  </td>
                </tr>
              ))}
              {rows.length === 0 && <tr><td colSpan={5} className="muted">Нет записей</td></tr>}
            </tbody>
          </table>
        </div>
      </Card>

      <Modal open={openAdd} onClose={()=>setOpenAdd(false)} title="Новый документ"
        footer={<><Button variant="ghost" onClick={()=>setOpenAdd(false)}>Отмена</Button><Button onClick={doUpload} disabled={busy || !file}>Загрузить</Button></>}>
        <div className="stack">
          <FilePicker onFileSelected={setFile} accept=".txt,.pdf,.doc,.docx,.md,.rtf,.odt" />
          <div>
            <label>Теги (опционально):</label>
            <Input 
              placeholder="Введите теги через запятую..." 
              value={uploadTags.join(', ')} 
              onChange={e => setUploadTags(e.target.value.split(',').map(t => t.trim()).filter(Boolean))} 
            />
          </div>
        </div>
      </Modal>

      <Popover 
        trigger={<div />}
        content={
          <div className="stack" style={{minWidth: 260}}>
          {pop.col === 'status' ? (
            <Select
              value={filters.status || ''}
              onChange={e=>setFilters(f=>({ ...f, status: (e.target as HTMLSelectElement).value || undefined }))}
            >
              <option value="">Любой</option>
              <option value="queued">В очереди</option>
              <option value="processing">Обработка</option>
              <option value="ready">Готов</option>
              <option value="error">Ошибка</option>
              <option value="archived">Архив</option>
            </Select>
          ) : (
            <Input placeholder="Фильтр…" value={(filters[pop.col as ColKey] || '') as string} onChange={e=>{
              const val = e.target.value
              const col = pop.col as ColKey
              setFilters(f=>({ ...f, [col]: (val || '').trim() || undefined }))
            }} />
          )}
          <div style={{display:'flex', gap:8, justifyContent:'space-between'}}>
            <Button size="sm" variant="ghost" onClick={()=>{ const col = pop.col as ColKey; setFilters(f=>({ ...f, [col]: undefined })); }}>Очистить</Button>
            <Button size="sm" onClick={()=>setPop({open:false})}>Применить</Button>
          </div>
          </div>
        }
        align="end"
      />
    </div>
  )
}

// ===== app/routes/gpt/GPTLayout.tsx =====
import React from 'react'
import { Outlet, NavLink, useNavigate } from 'react-router-dom'
import Button from '@shared/ui/Button'
import styles from './GPTLayout.module.css'
import { useAuth } from '@app/store/auth'
import ThemeSwitch from '@shared/ui/ThemeSwitch'

const USE_MOCKS = import.meta.env.VITE_USE_MOCKS === 'true'

export default function GPTLayout() {
  const nav = useNavigate()
  const { logout, user } = useAuth()
  const isAdmin = (user?.role || '').toLowerCase() === 'admin'

  // Logo is served from /public/logo.png to avoid bundler import issues.
  const logoSrc = '/logo.png'

  return (
    <div className={styles.shell}>
      <header className={styles.header}>
        {/* Left: logo + brand */}
        <div className={styles.brand}>
          <img
            src={logoSrc}
            alt="Почемучка logo"
            onError={(e)=>{ const el=e.currentTarget as HTMLImageElement; el.style.display='none' }}
          />
          <div className={styles.brandName}>Почемучка</div>
        </div>

        {/* Center: segmented nav (50% header width) */}
        <nav className={styles.nav}>
          <div className={styles.segWrap}>
            <div className={styles.seg}>
              <NavLink to="/gpt/chat" className={({isActive}) => [styles.segBtn, isActive ? styles.active : ''].join(' ')}>Чат</NavLink>
              <NavLink to="/gpt/analyze" className={({isActive}) => [styles.segBtn, isActive ? styles.active : ''].join(' ')}>Аналитика</NavLink>
              {isAdmin && (
                <NavLink to="/gpt/rag" className={({isActive}) => [styles.segBtn, isActive ? styles.active : ''].join(' ')}>База знаний</NavLink>
              )}
            </div>
          </div>
        </nav>

        {/* Right: mocks -> role -> theme -> logout */}
        <div className={styles.right}>
          {USE_MOCKS && <span className={styles.mocks}>Mocks ON</span>}
          <span className={styles.user}>{user?.role || ''}</span>
          <ThemeSwitch />
          <Button variant="ghost" onClick={async () => { await logout(); nav('/login') }}>Выйти</Button>
        </div>
      </header>

      <main className={styles.main}>
        <Outlet />
      </main>

      <footer className={styles.footer}>{/* пустой подвал, заполним позже */}</footer>
    </div>
  )
}

// ===== app/routes/gpt/AnalyzePage.tsx =====
import React, { useEffect, useMemo, useState } from 'react'
import Card from '@shared/ui/Card'
import Input from '@shared/ui/Input'
import Button from '@shared/ui/Button'
import Badge from '@shared/ui/Badge'
import Modal from '@shared/ui/Modal'
import Popover from '@shared/ui/Popover'
import { FilterIcon } from '@shared/ui/Icon'
import Select from '@shared/ui/Select'
import FilePicker from '@shared/ui/FilePicker'
import * as analyze from '@shared/api/analyze'
import styles from './AnalyzePage.module.css'

type Task = { id: string; source?: string; status: string; result?: string; created_at?: string }
type ColKey = keyof Pick<Task, 'source'|'status'|'result'|'created_at'>

export default function AnalyzePage() {
  const [items, setItems] = useState<Task[]>([])
  const [busy, setBusy] = useState(false)

  const [q, setQ] = useState('')
  const [filters, setFilters] = useState<Partial<Record<ColKey, string>>>({})
  const [pop, setPop] = useState<{ open: boolean, col?: ColKey, anchor?: {x:number,y:number} }>({ open: false })

  const [openAdd, setOpenAdd] = useState(false)
  const [file, setFile] = useState<File | null>(null)

  async function refresh() {
    const res = await analyze.listAnalyze()
    setItems(res.items || [])
  }

  // Мягкий пуллинг (экспоненциальный backoff)
  useEffect(() => {
    let cancelled = false
    let delay = 1500
    const tick = async () => {
      while (!cancelled) {
        try { await refresh() } catch {}
        await new Promise(r => setTimeout(r, delay))
        delay = Math.min(delay * 2, 10000)
      }
    }
    tick()
    return () => { cancelled = true }
  }, [])

  const rows = useMemo(() => {
    return (items||[]).filter(t => {
      const text = ((t.source||'') + ' ' + (t.result||'') + ' ' + (t.created_at||'') + ' ' + t.status).toLowerCase()
      if (q.trim() && !text.includes(q.toLowerCase())) return false
      if (filters.source && !(t.source||'').toLowerCase().includes((filters.source||'').toLowerCase())) return false
      if (filters.status && t.status !== filters.status) return false
      if (filters.result && !(t.result||'').toLowerCase().includes((filters.result||'').toLowerCase())) return false
      if (filters.created_at && !(t.created_at||'').toLowerCase().includes((filters.created_at||'').toLowerCase())) return false
      return true
    })
  }, [items, q, filters])

  function openFilter(col: ColKey, el: HTMLElement) {
    const r = el.getBoundingClientRect()
    setPop({ open: true, col, anchor: { x: r.left, y: r.bottom + 6 } })
  }
  function clearAll() { setFilters({}); setPop({ open:false }) }

  async function doUpload() {
    if (!file) return
    setBusy(true)
    try {
      await analyze.uploadAnalysisFile(file)
      setOpenAdd(false)
      setFile(null)
      await refresh()
    } finally { setBusy(false) }
  }

  const hasAnyFilter = Object.values(filters).some(Boolean)

  return (
    <div className={styles.wrap}>
      <Card className={styles.card}>
        <div className={styles.header}>
          <div className={styles.title}>Анализ документов — задачи</div>
          <div className={styles.controls}>
            <Input className={styles.search} placeholder="Поиск…" value={q} onChange={e=>setQ(e.target.value)} />
            {hasAnyFilter && <Badge onClick={clearAll}>Сбросить фильтры</Badge>}
            <Button onClick={()=>setOpenAdd(true)}>Добавить</Button>
          </div>
        </div>

        <div className={styles.tableWrap}>
          <table className="table">
            <thead>
              <tr>
                <th>Источник <button className="icon" type="button" aria-label="Фильтр по источнику" onClick={(e)=>openFilter('source', e.currentTarget)}><FilterIcon/></button></th>
                <th>Статус <button className="icon" type="button" aria-label="Фильтр по статусу" onClick={(e)=>openFilter('status', e.currentTarget)}><FilterIcon/></button></th>
                <th>Результат <button className="icon" type="button" aria-label="Фильтр по результату" onClick={(e)=>openFilter('result', e.currentTarget)}><FilterIcon/></button></th>
                <th>Создано <button className="icon" type="button" aria-label="Фильтр по дате создания" onClick={(e)=>openFilter('created_at', e.currentTarget)}><FilterIcon/></button></th>
              </tr>
            </thead>
            <tbody>
              {rows.map((t) => (
                <tr key={t.id}>
                  <td className="muted">{t.source || '—'}</td>
                  <td><Badge tone={t.status==='done'?'success':t.status==='error'?'danger':t.status==='processing'?'warn':'neutral'}>{t.status}</Badge></td>
                  <td style={{maxWidth:480, whiteSpace:'nowrap', textOverflow:'ellipsis', overflow:'hidden'}}>{t.result || '—'}</td>
                  <td className="muted">{t.created_at || '—'}</td>
                </tr>
              ))}
              {rows.length === 0 && <tr><td colSpan={4} className="muted">Нет записей</td></tr>}
            </tbody>
          </table>
        </div>
      </Card>

      <Modal open={openAdd} onClose={()=>setOpenAdd(false)} title="Новый анализ"
        footer={<><Button variant="ghost" onClick={()=>setOpenAdd(false)}>Отмена</Button><Button onClick={doUpload} disabled={busy || !file}>Запустить</Button></>}>
        <FilePicker onFileSelected={setFile} />
      </Modal>

      <Popover 
        trigger={<div />}
        content={
          <div className="stack" style={{minWidth: 260}}>
          {pop.col === 'status' ? (
            <Select
              value={filters.status || ''}
              onChange={e=>setFilters(f=>({ ...f, status: (e.target as HTMLSelectElement).value || undefined }))}
            >
              <option value="">Любой</option>
              <option value="queued">queued</option>
              <option value="processing">processing</option>
              <option value="done">done</option>
              <option value="error">error</option>
            </Select>
          ) : (
            <Input placeholder="Фильтр…" value={(filters[pop.col as ColKey] || '') as string} onChange={e=>{
              const val = e.target.value
              const col = pop.col as ColKey
              setFilters(f=>({ ...f, [col]: (val || '').trim() || undefined }))
            }} />
          )}
          <div style={{display:'flex', gap:8, justifyContent:'space-between'}}>
            <Button size="sm" variant="ghost" onClick={()=>{ const col = pop.col as ColKey; setFilters(f=>({ ...f, [col]: undefined })); }}>Очистить</Button>
            <Button size="sm" onClick={()=>setPop({open:false})}>Применить</Button>
          </div>
          </div>
        }
        align="end"
      />
    </div>
  )
}

// ===== app/routes/gpt/Chat.tsx =====
import React, { useEffect, useMemo, useRef, useState } from 'react'
import styles from './Chat.module.css'
import Card from '@shared/ui/Card'
import Button from '@shared/ui/Button'
import Textarea from '@shared/ui/Textarea'
import { useNavigate, useParams } from 'react-router-dom'
import { useChat } from '../../contexts/ChatContext'
import EmptyState from '../../components/EmptyState'

export default function Chat() {
  const { chatId } = useParams()
  const nav = useNavigate()
  const { state, loadMessages, setCurrentChat, sendMessageStream } = useChat()

  const [text, setText] = useState('')
  const [busy, setBusy] = useState(false)
  const [useRag, setUseRag] = useState(false)
  const [streamText, setStreamText] = useState('')

  const current = useMemo(() => chatId ? state.messagesByChat[chatId] : undefined, [chatId, state.messagesByChat])
  const messages = current?.items || []

  useEffect(() => {
    if (!chatId) return
    setCurrentChat(chatId)
    // load once
    if (!state.messagesByChat[chatId]?.loaded) {
      loadMessages(chatId).catch(console.error)
    }
    // cleanup stream text on chat switch
    setStreamText('')
  }, [chatId])

  if (!chatId) {
    return (
      <div className={styles.main}>
        <EmptyState
          title="Выберите чат"
          description="Слева — список ваших чатов. Создайте новый или откройте существующий."
          action={<Button onClick={() => nav('/gpt/chat')}>Обновить</Button>}
        />
      </div>
    )
  }

  async function onSend() {
    if (!text.trim()) return
    setBusy(true)
    setStreamText('')
    const toSend = text
    setText('')
    try {
      await sendMessageStream(chatId, toSend, (delta) => setStreamText(delta), useRag)
    } catch (e) {
      console.error(e)
    } finally {
      setBusy(false)
      setStreamText('')
    }
  }

  const canSend = !!chatId && !!text.trim() && !busy

  return (
    <div className={styles.main}>
      <Card className={styles.card}>
        <div className={styles.history}>
          {messages.map(m => (
            <div key={m.id} className={m.role === 'user' ? styles.userMsg : styles.assistantMsg}>
              <div className={styles.body}>{m.content}</div>
            </div>
          ))}
          {streamText && (
            <div className={styles.assistantMsg}>
              <div className={styles.body}>{streamText}</div>
            </div>
          )}
          {messages.length === 0 && !state.isLoading && (
            <div style={{ opacity: .7 }}>Сообщений пока нет.</div>
          )}
        </div>

        <div className={styles.composer}>
          <Textarea
            placeholder="Ваше сообщение…"
            value={text}
            onChange={e => setText(e.target.value)}
            disabled={!chatId || busy}
            rows={3}
          />
          <div className={styles.controls}>
            <div />
            <div className={styles.actionsBottom}>
              <Button onClick={onSend} disabled={!canSend}>Отправить</Button>
              <label className={styles.ragToggle} title="Использовать базу знаний (RAG) при ответе">
                <input type="checkbox" checked={useRag} onChange={e => setUseRag(e.target.checked)} />
                RAG из БЗ
              </label>
            </div>
          </div>
        </div>
      </Card>
    </div>
  )
}

// ===== app/routes/gpt/ChatSidebar.tsx =====
import React, { useMemo, useState } from 'react'
import styles from './ChatSidebar.module.css'
import Button from '@shared/ui/Button'
import { useNavigate, useParams } from 'react-router-dom'
import Modal from '@shared/ui/Modal'
import Input from '@shared/ui/Input'
import Popover from '@shared/ui/Popover'
import { useChat } from '../../contexts/ChatContext'
import ChatTags from '../../components/ChatTags'

function hueFromString(s: string){
  let h = 0
  for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) >>> 0
  return h % 360
}

function KebabIcon() {
  return <svg width="16" height="16" viewBox="0 0 24 24"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>
}

export default function ChatSidebar() {
  const { chatId } = useParams()
  const nav = useNavigate()
  const { state, createChat, renameChat, deleteChat, updateChatTags, removeChatLocal, restoreChatLocal, deleteChatApiOnly } = useChat()

  const [renameTarget, setRenameTarget] = useState<{ id: string, name: string } | null>(null)
  const [deleteTarget, setDeleteTarget] = useState<{ id: string, name?: string } | null>(null)
  const [pendingUndo, setPendingUndo] = useState<{ id: string, name?: string|null, tags?: string[]|null, secs: number, tid: any, iid: any } | null>(null)
  const [editTagsTarget, setEditTagsTarget] = useState<{ id: string, tags: string[] } | null>(null)

  const chats = useMemo(() => state.chatsOrder.map(id => state.chatsById[id]), [state.chatsOrder, state.chatsById])

  async function onCreate() {
    const id = await createChat('Новый чат')
    nav(`/gpt/chat/${id}`)
  }

  return (
    <aside className={styles.sidebar}>
      <div className={styles.head}>
        <div className={styles.title}>Чаты</div>
        <Button size="sm" onClick={onCreate}>+ Новый</Button>
      </div>

      <div className={styles.list}>
        {chats.length === 0 && <div className={styles.item} style={{ opacity: .7 }}>Нет чатов</div>}
        {chats.map(chat => (
          <div key={chat.id} className={[styles.row, chatId === chat.id ? styles.active : ''].join(' ')}>
            <button className={styles.item} onClick={() => nav(`/gpt/chat/${chat.id}`)}>
              <div className={styles.name}>{chat.name || 'Без названия'}</div>
              {Array.isArray(chat.tags) && chat.tags.length > 0 && (
                <div className={styles.tags}>
                  {chat.tags.map(tag => {
                  const h = hueFromString(tag)
                  const bg = `hsla(${h}, 70%, 45%, .18)`
                  const bd = `hsla(${h}, 70%, 50%, .45)`
                  const fg = `hsla(${h}, 80%, 80%, .95)`
                  return <span key={tag} className={styles.tag} style={{ background: bg, borderColor: bd, color: fg }}>{tag}</span>
                  })}
                </div>
              )}
            </button>
            <Popover
              trigger={<button className={styles.kebabBtn} aria-label="Меню"><KebabIcon/></button>}
              content={<div className={styles.menu}>
                <button className={styles.item} onClick={() => setRenameTarget({ id: chat.id, name: chat.name || '' })}>Переименовать</button>
                <button className={styles.item} onClick={() => setEditTagsTarget({ id: chat.id, tags: chat.tags || [] })}>Теги…</button>
                <button className={styles.item} onClick={() => setDeleteTarget({ id: chat.id, name: chat.name || '' })}>Удалить</button>
              </div>}
              align="end"
            />
          </div>
        ))}
      </div>

      <Modal open={!!renameTarget} onClose={() => setRenameTarget(null)} title="Переименовать чат"
        footer={<>
          <Button variant="ghost" onClick={() => setRenameTarget(null)}>Отмена</Button>
          <Button onClick={async () => {
            if (!renameTarget) return
            await renameChat(renameTarget.id, renameTarget.name || 'Без названия')
            setRenameTarget(null)
          }}>Сохранить</Button>
        </>}
      >
        <Input value={renameTarget?.name || ''} onChange={e => setRenameTarget(v => v ? { ...v, name: e.target.value } : v)} className="w-100" />
      </Modal>

      <Modal open={!!deleteTarget} onClose={() => setDeleteTarget(null)} title="Удалить чат"
        footer={<>
          <Button variant="ghost" onClick={() => setDeleteTarget(null)}>Отмена</Button>
          <Button variant="danger" onClick={async () => {
            if (!deleteTarget) return
            const chat = state.chatsById[deleteTarget.id]
            // Optimistic remove from state
            // We will call API after countdown unless undone
            const secsTotal = 5
            let secs = secsTotal
            // remove locally
            removeChatLocal(deleteTarget.id)
            if (chatId === deleteTarget.id) nav('/gpt/chat')
            setDeleteTarget(null)

            const tid = setTimeout(async () => {
              try { await deleteChatApiOnly(chat.id) } catch(e){ console.error(e) }
              setPendingUndo(null)
            }, secsTotal*1000)
            const iid = setInterval(() => {
              secs -= 1
              setPendingUndo(v => v ? { ...v, secs } : v)
            }, 1000)
            setPendingUndo({ id: chat.id, name: chat?.name || 'Без названия', tags: chat?.tags || [], secs, tid, iid })
          }}>Удалить</Button>
        </>}
      >
        Вы уверены, что хотите удалить чат «{deleteTarget?.name || 'Без названия'}»?
      </Modal>

      {editTagsTarget && (
        <ChatTags
          chatId={editTagsTarget.id}
          tags={editTagsTarget.tags}
          onTagsChange={async (tags) => {
            await updateChatTags(editTagsTarget.id, tags)
            setEditTagsTarget(null)
          }}
        />
      )}
    {pendingUndo && (
        <div className={styles.undoBar} role="status">
          <div className={styles.undoText}>Чат «{pendingUndo.name}» удалён. Отменить можно в течение {pendingUndo.secs} с.</div>
          <button className={styles.undoBtn} onClick={() => {
            clearTimeout(pendingUndo.tid)
            clearInterval(pendingUndo.iid)
            // restore in local state
            restoreChatLocal({ id: pendingUndo.id, name: pendingUndo.name || null, tags: pendingUndo.tags || [] } as any)
            setPendingUndo(null)
          }}>Отменить</button>
        </div>
      )}
    </aside>
  )
}

// ===== app/routes/gpt/ChatPage.tsx =====
import React from 'react'
import styles from './ChatPage.module.css'
import ChatSidebar from './ChatSidebar'
import Chat from './Chat'
import { ChatProvider } from '../../contexts/ChatContext'
import ChatStatus from '../../components/ChatStatus'

export default function ChatPage() {
  return (
    <ChatProvider>
      <div className={styles.shell}>
        <ChatSidebar />
        <div className={styles.main}>
          <Chat />
        </div>
        <ChatStatus />
      </div>
    </ChatProvider>
  )
}

// ===== app/components/__tests__/ChatTags.test.tsx =====
import React from 'react'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import '@testing-library/jest-dom'
import { vi } from 'vitest'
import ChatTags from '../ChatTags'

// Mock the useChat hook
vi.mock('../../contexts/ChatContext', () => ({
  useChat: () => ({
    updateChatTags: vi.fn()
  })
}))

describe('ChatTags', () => {
  const defaultProps = {
    chatId: 'test-chat-id',
    tags: ['test', 'example'],
    onTagsChange: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders existing tags', () => {
    render(<ChatTags {...defaultProps} />)
    
    expect(screen.getByText('test')).toBeInTheDocument()
    expect(screen.getByText('example')).toBeInTheDocument()
  })

  it('renders "No tags" when no tags provided', () => {
    render(<ChatTags {...defaultProps} tags={[]} />)
    
    expect(screen.getByText('Нет тегов')).toBeInTheDocument()
  })

  it('opens modal when edit button is clicked', () => {
    render(<ChatTags {...defaultProps} />)
    
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    expect(screen.getByText('Управление тегами')).toBeInTheDocument()
  })

  it('adds new tag when input is filled and add button clicked', async () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    expect(screen.getByText('new-tag')).toBeInTheDocument()
  })

  it('removes tag when remove button is clicked', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Remove tag
    const removeButtons = screen.getAllByText('×')
    fireEvent.click(removeButtons[0]) // Remove first tag
    
    expect(screen.queryByText('test')).not.toBeInTheDocument()
    expect(screen.getByText('example')).toBeInTheDocument()
  })

  it('saves changes when save button is clicked', async () => {
    const onTagsChange = vi.fn()
    render(<ChatTags {...defaultProps} onTagsChange={onTagsChange} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    // Save changes
    const saveButton = screen.getByText('Сохранить')
    fireEvent.click(saveButton)
    
    await waitFor(() => {
      expect(onTagsChange).toHaveBeenCalledWith(['test', 'example', 'new-tag'])
    })
  })

  it('cancels changes when cancel button is clicked', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    // Cancel changes
    const cancelButton = screen.getByText('Отмена')
    fireEvent.click(cancelButton)
    
    // Modal should be closed and original tags should remain
    expect(screen.queryByText('Управление тегами')).not.toBeInTheDocument()
    expect(screen.getByText('test')).toBeInTheDocument()
    expect(screen.getByText('example')).toBeInTheDocument()
  })

  it('adds tag when Enter key is pressed', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Add new tag with Enter key
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'new-tag' } })
    fireEvent.keyPress(input, { key: 'Enter', code: 'Enter' })
    
    expect(screen.getByText('new-tag')).toBeInTheDocument()
  })

  it('does not add empty tag', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Try to add empty tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: '   ' } })
    
    const addButton = screen.getByText('Добавить')
    expect(addButton).toBeDisabled()
  })

  it('does not add duplicate tag', () => {
    render(<ChatTags {...defaultProps} />)
    
    // Open modal
    const editButton = screen.getByTitle('Управление тегами')
    fireEvent.click(editButton)
    
    // Try to add existing tag
    const input = screen.getByPlaceholderText('Добавить тег...')
    fireEvent.change(input, { target: { value: 'test' } })
    
    const addButton = screen.getByText('Добавить')
    fireEvent.click(addButton)
    
    // Should not add duplicate
    const testTags = screen.getAllByText('test')
    expect(testTags).toHaveLength(1) // Only the original one
  })
})
